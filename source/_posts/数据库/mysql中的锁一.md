---
title: mysql中的锁一
toc: true
author: mirsery
comments: false
date: 2024-01-30 13:47:12
updated: 2024-01-30 13:47:12
tags:
    - 锁
categories:
    - mysql
excerpt: 'MySQL(MYISAM)表级锁有两种模式：表共享锁（Table Read Lock）和表独占写锁（Table Write Lock）....'
---


<!-- toc -->

# 概述

相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。
MySQL大致可归纳为以下3种锁：

|类别|开销|速度|锁粒度|锁冲突|死锁风险|并发度| 
|---|---|---|---|---|---|---|
|表级锁|最小|最快|最大|概率最高|无|最低|
|行级锁|最大|最小|最小|概率最低|有|最高|
|页面锁|中|中|中|中|有|中|

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

## MySQL MyISAM表级锁的锁模式

MySQL表级锁有两种模式：表共享锁（Table Read Lock）和表独占写锁（Table Write Lock）。
对MyISAM的读操作，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求；
对MyISAM的写操作，则会阻塞其他用户对同一表的读和写操作；
MyISAM表的读操作和写操作之间，以及写操作之间是串行的。
当一个线程获得对一个表的写锁后，只有持有锁线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。


## 表级锁的锁模式
 ＭySQL的表锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。

锁模式的兼容性

|请求锁模式|None|读锁|写锁|
|---|---|---|---|
|读锁|Y|Y|N|
|写锁|Y|N|N|

对ＭyISAM引擎的表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；
对ＭyISAM表的写操作，则会阻塞其他用户对同一表的读和写请求；
ＭyISAM表的读和写操作之间，以及写和写操作之间是串行的！（当一线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。）


## 如何加表锁
MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁.
> 在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。

给MyISAM表显示加锁，一般是为了一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表 ***orders*** ，其中记录有订单的总金额 total ，同时还有一个订单明细表 ***order_detail*** ，其中记录有订单每一产品的金额小计 subtotal ,假设我们需要检查这两个表的金额合计是否相等，可能就需要执行如下两条SQL:
```sql
SELECT SUM(total) FROM orders;
SELECT SUM(subtotal) FROM order_detail;
```
这时，如果不先给这两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，***order_detail*** 表可能已经发生了改变。因此，正确的方法应该是：
```sql
LOCK tables orders read local,order_detail read local;
SELECT SUM(total) FROM orders;
SELECT SUM(subtotal) FROM order_detail;
Unlock tables;
```
> 要特别说明以下两点内容。
> 上面的例子在 **LOCK TABLES** 时加了**local**选项，其作用就是在满足**MyISAM**表并发插入条件的情况下，允许其他用户在表尾插入记录.
> 在用**LOCK TABLES**给表显式加表锁时，必须同时取得所有涉及表的锁，并且MySQL支持锁升级。也就是说，在执行**LOCK TABLES**后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MySQL问题一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现**死锁（Deadlock Free）**的原因.
> 一个session使用**LOCK TABLE**命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。
> 当使用**LOCK TABLE**时，不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁多少次，否则也会出错！

## 并发锁
在一定条件下，MyISAM也支持查询和操作的并发进行。
MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。
当concurrent_insert设置为0时，不允许并发插入。
当concurrent_insert设置为1时，MyISAM允许在一个读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。
当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾插入记录，都允许在表尾并发插入记录。
可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入锁争用。例如，将concurrent_insert系统变量为2，总是允许并发插入；同时，通过定期在系统空闲时段执行OPTIONMIZE TABLE语句来整理空间碎片，收到因删除记录而产生的中间空洞。


## 关于死锁
ＭyISAM表锁是deadlock free的，这是因为ＭyISAM总是一次性获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。


## 总结

MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加**读锁**
在执行update、insert、delete操作会自动给涉及的表加**写锁**。

对于ＭyISAM的表锁，主要有以下几点
（１） 共享读锁（S）之间是兼容的，但共享读锁（S）和排他写锁（X）之间，以及排他写锁之间（X）是互斥的，也就是说读和写是串行的。
（２） 在一定条件下，ＭyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表和插入的锁争用问题。
（３） ＭyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIPORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。
（４） 由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，ＭyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。
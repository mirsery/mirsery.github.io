<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mirsery</title>
  
  <subtitle>兴趣使然博客</subtitle>
  <link href="https://mirsery.github.io/atom.xml" rel="self"/>
  
  <link href="https://mirsery.github.io/"/>
  <updated>2024-06-13T12:25:09.000Z</updated>
  <id>https://mirsery.github.io/</id>
  
  <author>
    <name>mirsery</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java SPI 机制</title>
    <link href="https://mirsery.github.io/2024/06/13/java/2024/Java-SPI-%E6%9C%BA%E5%88%B6/"/>
    <id>https://mirsery.github.io/2024/06/13/java/2024/Java-SPI-%E6%9C%BA%E5%88%B6/</id>
    <published>2024-06-13T12:25:09.000Z</published>
    <updated>2024-06-13T12:25:09.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#spi-%E5%AE%9E%E8%B7%B5-demo">SPI 实践 demo</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a></li></ul><!-- tocstop --><p><img src="/2024/06/13/java/2024/Java-SPI-%E6%9C%BA%E5%88%B6/2024-06-13-23.17.43.png"></p><h2><span id="spi-实践-demo">SPI 实践 demo</span></h2><p>先看例子再剖析原因。</p><pre><code class="highlight java"><span class="comment">// 新建一个接口 car</span><span class="keyword">package</span> com.example.testdemo.spi;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;&#125;</code></pre><p>实现该接口 benz 、bmw</p><pre><code class="highlight java"><span class="comment">// bmw</span><span class="keyword">package</span> com.example.testdemo.spi;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BMWCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;BMW start&quot;</span>);    &#125;&#125;<span class="comment">//benz</span><span class="keyword">package</span> com.example.testdemo.spi;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BenzCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;Benz start&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>resources 目录中需要添加对应的文件</p></blockquote><p>在<strong>resources</strong> 目录下即（class path）下新增文件夹<strong>META-INF&#x2F;services</strong>,创建需要使用 SPI 机制的接口文件，<br>文件名在这个示例中为<strong>com.example.testdemo.spi.Car</strong>,内容如下所示:</p><pre><code class="highlight plaintext">com.example.testdemo.spi.BenzCarcom.example.testdemo.spi.BMWCar</code></pre><p>测试类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SPIMainDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        ServiceLoader&lt;Car&gt; cars = ServiceLoader.load(Car.class);        cars.forEach(Car::start);    &#125;&#125;</code></pre><p>运行结果为:</p><pre><code class="highlight plaintext">Benz startBMW start</code></pre><p>从上述的 sample 中我们可以知道Java SPI 实际上还是基于接口的编程+策略模式+配置文件组合实现的动态加载机制。在面向对象的设计中，一般情况我们推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。</p><h2><span id="使用场景">使用场景</span></h2><ul><li>JDBC驱动，加载不同数据库的驱动类</li><li>Spring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等</li><li>Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口</li><li>Tomcat 加载 META-INF&#x2F;services下找需要加载的类</li><li>SpringBoot项目中 使用@SpringBootApplication注解时，会开始自动配置，而启动配置则会去扫描META-INF&#x2F;spring.factories下的配置类</li></ul><blockquote><p>此处引用 原文链接：<a href="https://blog.csdn.net/cold___play/article/details/132074294">https://blog.csdn.net/cold___play/article/details/132074294</a></p></blockquote>]]></content>
    
    
    <summary type="html">SPI 技术全称是 Service Provider Interface 是一种 JDK 内置的动态加载实现扩展点的机制，通过 SPI 技术我们可以动态获取接口的实现类，不需要自己来创建...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://mirsery.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java中的AQS抽象队列同步器</title>
    <link href="https://mirsery.github.io/2024/02/27/java/2024/java%E4%B8%AD%E7%9A%84AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    <id>https://mirsery.github.io/2024/02/27/java/2024/java%E4%B8%AD%E7%9A%84AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/</id>
    <published>2024-02-27T02:57:53.000Z</published>
    <updated>2024-07-02T15:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFaqs">什么是AQS</a></li><li><a href="#abstractqueuedsynchronizer%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90">AbstractQueuedSynchronizer方法解析</a></li><li><a href="#%E8%87%AA%E6%97%8B%E5%92%8C%E9%98%BB%E5%A1%9E">自旋和阻塞</a></li><li><a href="#reentrantlocksemaphore%E4%BB%A5%E5%8F%8Acountdownlatch%E5%AF%B9%E6%AF%94">ReentrantLock，Semaphore以及CountDownLatch对比</a></li><li><a href="#reentrantlock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">ReentrantLock实现原理</a></li><li><a href="#semaphore%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">Semaphore实现原理</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97-aqs-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E7%8B%AC%E5%8D%A0%E9%94%81">使用抽象同步队列 AQS 构建一个不可重入的独占锁</a></li></ul><!-- tocstop --><h2><span id="什么是aqs">什么是AQS</span></h2><p>AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面。</p><p>AbstractQueuedSynchronizer抽象队列同步器——用于构建锁或其他同步组件的基础框架，子类通过继承AQS并实现它的抽象方法来实现锁</p><p>AQS支持两种模式——独占模式，共享模式。</p><p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了， ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式 连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队 列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。<br>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可 以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><h2><span id="abstractqueuedsynchronizer方法解析">AbstractQueuedSynchronizer方法解析</span></h2><p>AbstractQueuedSynchronizer（AQS）是Java并发编程中的一个基础框架，它提供了一种实现同步器的通用方法。AQS内部维护了一个同步队列，通过“自旋”和“阻塞”两种方式来实现同步操作。</p><p>AQS提供了一些核心方法，其含义和作用如下：</p><p>acquire(int arg): 尝试获取同步状态，如果获取失败则加入同步队列并阻塞等待唤醒，直到获取同步状态成功。参数arg表示获取同步状态所需的资源数量。</p><p>tryAcquire(int arg): 尝试获取同步状态，如果获取成功则返回true，否则返回false。参数arg表示获取同步状态所需的资源数量。</p><p>release(int arg): 释放同步状态，通知其他线程可以尝试获取同步状态。参数arg表示释放的资源数量。</p><p>tryRelease(int arg): 尝试释放同步状态，如果释放成功则返回true，否则返回false。参数arg表示释放的资源数量。</p><p>acquireInterruptibly(int arg): 尝试获取同步状态，如果获取失败则加入同步队列并阻塞等待唤醒，直到获取同步状态成功或者被中断。参数arg表示获取同步状态所需的资源数量。</p><p>acquireShared(int arg): 尝试获取共享同步状态，如果获取失败则加入同步队列并阻塞等待唤醒，直到获取共享同步状态成功。参数arg表示获取共享同步状态所需的资源数量。</p><p>tryAcquireShared(int arg): 尝试获取共享同步状态，如果获取成功则返回非负数，否则返回负数。返回值表示当前线程获取到的共享资源数量。参数arg表示获取共享同步状态所需的资源数量。</p><p>releaseShared(int arg): 释放共享同步状态，通知其他线程可以尝试获取共享同步状态。参数arg表示释放的资源数量。</p><p>tryAcquireNanos(int arg, long nanosTimeout): 在规定时间内尝试获取同步状态，如果获取失败则加入同步队列并阻塞等待唤醒，直到获取同步状态成功或者超时。参数arg表示获取同步状态所需的资源数量，参数nanosTimeout表示等待超时时间。</p><p>AQS提供了一些核心方法来实现同步操作，可以用于实现不同类型的同步器，如ReentrantLock、Semaphore、CountDownLatch等。这些方法可以满足不同的并发编程需求，需要根据具体的场景选择合适的同步方式和同步策略。</p><h2><span id="自旋和阻塞">自旋和阻塞</span></h2><p>自旋和阻塞是Java并发编程中两种不同的线程等待方式。</p><p>自旋是指线程在等待某个条件满足时，不断地循环检查条件是否满足，如果不满足就一直循环等待，直到条件满足。自旋的好处是可以减少线程上下文切换的开销，因为线程一直处于执行状态，不需要进行线程状态的切换。但是自旋需要占用CPU资源，如果自旋时间过长会导致CPU资源浪费，降低系统性能。</p><p>阻塞是指线程在等待某个条件满足时，将自己挂起，不再占用CPU资源，直到条件满足时再被唤醒继续执行。阻塞的好处是可以释放CPU资源，避免浪费，但是阻塞需要进行线程状态的切换，如果线程频繁地阻塞和唤醒会增加系统开销。</p><p>在Java中，阻塞通常是通过调用wait()方法或者阻塞式IO来实现的，而自旋通常是在锁等待时实现的。例如，在ReentrantLock中，当线程尝试获取锁失败时，它会在同步队列中自旋等待锁的释放，直到锁被释放或者等待时间超过一定阈值才会阻塞等待。因此，在选择线程等待方式时需要根据具体的场景和需求进行权衡和选择。</p><h2><span id="reentrantlocksemaphore以及countdownlatch对比">ReentrantLock，Semaphore以及CountDownLatch对比</span></h2><p>ReentrantLock、Semaphore和CountDownLatch都是Java并发编程中常用的同步工具类，它们都使用了AQS的实现方式。<br>ReentrantLock（可重入锁）：是一种独占锁，它允许一个线程多次获取锁，支持公平锁和非公平锁。与synchronized关键字相比，ReentrantLock提供了更多的灵活性和功能，如可中断锁、限时锁、公平锁等。<br>Semaphore（信号量）：是一种共享锁，它用于控制对资源的访问数量。Semaphore维护了一个计数器，当有线程获取信号量时，计数器减1，当计数器为0时，其他线程需要等待。Semaphore可以用于实现限流、资源池等功能。<br>CountDownLatch（倒计时器）：是一种同步工具类，它可以让一个或多个线程等待其他线程执行完毕后再继续执行。CountDownLatch维护了一个计数器，当计数器为0时，等待的线程可以继续执行。它可以用于协调多个线程的执行顺序。</p><h2><span id="reentrantlock实现原理">ReentrantLock实现原理</span></h2><p>获取锁：当一个线程请求获取锁时，ReentrantLock会首先尝试获取锁，如果锁未被占用，则该线程可以立即获取锁；否则，该线程将被加入到同步队列中等待获取锁。<br>可重入性：如果当前线程已经持有锁，那么它可以重复获取该锁，而不需要重新等待。为了实现可重入性，ReentrantLock需要维护一个记录锁持有者的ThreadLocal变量，以及一个记录锁持有次数的计数器。<br>公平性和非公平性：ReentrantLock支持公平锁和非公平锁。公平锁是指多个线程获取锁的顺序与它们加入同步队列的顺序相同；非公平锁则不保证获取锁的顺序与加入队列的顺序相同。在公平锁模式下，线程获取锁的顺序是有序的，但是会降低并发性能；在非公平锁模式下，线程获取锁的顺序是不确定的，但是可以提高并发性能。<br>释放锁：当一个线程释放锁时，ReentrantLock会将state变量置为0，以表示该锁已经被释放。同时，它会从同步队列中选择一个等待的线程唤醒，使其重新尝试获取锁。如果当前线程还持有该锁，那么需要将计数器减1，直到计数器为0才能完全释放锁。<br>ReentrantLock源码中compareAndSetState的方法</p><p>在ReentrantLock的源码中，比较并交换（CompareAndSet）状态值是实现锁的核心部分之一。在ReentrantLock中，状态值的改变可以表示锁的获取和释放，因此状态值的比较并交换是实现锁的关键。</p><p>在ReentrantLock中，状态值是由AQS（AbstractQueuedSynchronizer）的内部类Node中的state字段表示的。具体来说，当线程获取锁时，它会创建一个Node节点并尝试将状态值从0（表示锁未被占用）改变为1（表示锁已被占用）。当线程释放锁时，它会将状态值从1改变为0，表示锁已被释放。</p><p>在AQS中，compareAndSetState(int expect, int update)方法用于比较并交换状态值。具体来说，该方法会比较当前状态值是否等于expect，如果是则将状态值修改为update，否则不进行修改。这个方法是原子的，可以保证状态值的改变是线程安全的。在ReentrantLock中，使用compareAndSetState方法实现锁的获取和释放，比如在获取锁时将状态值从0修改为1，在释放锁时将状态值从1修改为0。</p><p>下面是ReentrantLock源码中compareAndSetState方法的具体实现：</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);&#125;</code></pre><p>该方法调用了unsafe类的compareAndSwapInt方法，该方法是一个本地方法，用于实现原子的比较并交换操作。其中，this表示当前对象，stateOffset表示state字段在对象中的偏移量，expect表示期望的状态值，update表示要修改的状态值。如果当前状态值等于expect，则将状态值修改为update并返回true，否则返回false。<br>总之，ReentrantLock中的compareAndSetState方法实现了状态值的原子性修改，是实现锁的关键部分之一。</p><h2><span id="semaphore实现原理">Semaphore实现原理</span></h2><p>Semaphore是一个计数信号量，它可以用于控制同时访问某个资源的线程数量。Semaphore内部维护了一个计数器，表示可以访问资源的线程数量，线程在访问资源时需要先获取Semaphore的许可，当计数器的值大于0时，线程可以获取许可并访问资源，计数器的值减一；当计数器的值为0时，线程需要等待其他线程释放许可才能获取许可并访问资源。</p><p>Semaphore的实现原理主要是基于AQS（AbstractQueuedSynchronizer）类，Semaphore通过AQS实现了许可的获取和释放，并且保证了线程之间的互斥和同步。</p><p>Semaphore的实现可以分为两个部分：获取许可和释放许可。</p><ul><li><p>获取许可<br>Semaphore的acquire方法用于获取许可，如果当前有可用的许可则获取成功，如果没有则线程会被阻塞等待。acquire方法的具体实现如下：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    sync.acquireSharedInterruptibly(<span class="number">1</span>);&#125;</code></pre><p>acquire方法内部调用了AQS的acquireSharedInterruptibly方法，该方法实现了阻塞等待。如果当前计数器的值大于0，线程可以获取许可并将计数器的值减一，如果计数器的值为0，则线程会被阻塞等待其他线程释放许可。在AQS中，线程的阻塞等待是通过将线程添加到同步队列中实现的。</p></li><li><p>释放许可<br>Semaphore的release方法用于释放许可，如果当前没有线程等待许可则将许可的数量加一，如果有线程等待许可则唤醒一个等待线程并将许可的数量加一。release方法的具体实现如下：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;    sync.releaseShared(<span class="number">1</span>);&#125;</code></pre><p>release方法内部调用了AQS的releaseShared方法，该方法实现了许可的释放和等待线程的唤醒。如果当前有等待线程，则会从同步队列中唤醒一个线程，让其获取许可并执行；如果当前没有等待线程，则将许可的数量加一。</p></li></ul><p>Semaphore是基于AQS实现的一个计数信号量，通过计数器实现了对许可的控制，并通过同步队列实现了线程之间的同步和互斥。Semaphore的实现为线程的访问资源提供了一个简单而可靠的机制。</p><h2><span id="使用抽象同步队列-aqs-构建一个不可重入的独占锁">使用抽象同步队列 AQS 构建一个不可重入的独占锁</span></h2><pre><code class="highlight java:n">public class UnReentrantLock implements Lock &#123;    private static class Sync extends AbstractQueuedSynchronizer&#123;        @Override        protected boolean isHeldExclusively() &#123;           return getState() == 1;        &#125;        @Override        protected boolean tryRelease(int arg) &#123;            if(getState()==0)&#123;                throw new IllegalMonitorStateException();            &#125;else &#123;                setState(0);                setExclusiveOwnerThread(null);                return true;            &#125;        &#125;        @Override        protected boolean tryAcquire(int arg) &#123;            assert arg == 1;            if(compareAndSetState(0,1))&#123;                setExclusiveOwnerThread(Thread.currentThread());                return true;            &#125;            return false;        &#125;        public ConditionObject newCondition()&#123;            return new ConditionObject();        &#125;    &#125;    private final Sync sync = new Sync();    @Override    public void lock() &#123;        sync.acquire(1);    &#125;    @Override    public void lockInterruptibly() throws InterruptedException &#123;        sync.acquireInterruptibly(1);    &#125;    @Override    public boolean tryLock() &#123;        return sync.tryAcquire(1);    &#125;    @Override    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;        return sync.tryAcquireNanos(1,unit.toNanos(time));    &#125;    @Override    public void unlock() &#123;        sync.release(1);    &#125;    @Override    public Condition newCondition() &#123;        return sync.newCondition();    &#125;    public boolean isLocked()&#123;        return sync.isHeldExclusively();    &#125;&#125;</code></pre><p>利用自定义的锁实现一个消费者和生产者线程</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUnReentrantLock</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">UnReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnReentrantLock</span>();    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">prodCondition</span> <span class="operator">=</span> lock.newCondition(); <span class="comment">// 信号</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">customCondition</span> <span class="operator">=</span> lock.newCondition();    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Queue&lt;String&gt; taskQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">limitSize</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            lock.lock();            <span class="keyword">try</span> &#123;                <span class="keyword">while</span>(taskQueue.size() &gt;= limitSize) &#123;                    prodCondition.await();                &#125;                taskQueue.add(<span class="string">&quot;Hello&quot;</span>);                System.out.println(<span class="string">&quot;prod &quot;</span>+ <span class="string">&quot;Hello&quot;</span>);                customCondition.signalAll();            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125; <span class="keyword">finally</span> &#123;                lock.unlock();            &#125;        &#125;);        <span class="type">Thread</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            lock.lock();            <span class="keyword">try</span>&#123;                <span class="keyword">while</span>(taskQueue.isEmpty())&#123;                    customCondition.await();                &#125;                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> taskQueue.poll();                System.out.println(<span class="string">&quot;customer &quot;</span>+ msg);                prodCondition.signalAll();            &#125;<span class="keyword">catch</span> (Exception e)&#123;                e.printStackTrace();            &#125;<span class="keyword">finally</span> &#123;                lock.unlock();            &#125;        &#125;);        producer.start();        customer.start();    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">AQS是Java中的一个抽象队列同步器（AbstractQueuedSynchronizer）类，它提供了一种实现同步器的框架和实现方式。它是Java并发编程中的一个重要组成部分，广泛用于实现ReentrantLock、Semaphore、CountDownLatch等同步工具类。</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://mirsery.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java线程池的七大参数</title>
    <link href="https://mirsery.github.io/2024/02/27/java/2024/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0/"/>
    <id>https://mirsery.github.io/2024/02/27/java/2024/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0/</id>
    <published>2024-02-27T01:49:10.000Z</published>
    <updated>2024-07-03T05:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 线程池主要有7个核心线程数，最大线程数，最大线程存活时间，单位，等待线程，线程工厂，拒绝策略。在请求到来时，优先在核心线程中取线程给消费者（核心线程是一直开启的），核心线程全部分配出去后，消费者的请求会放到等待队列中。如果等待队列也满了，则会开启到最大线程数处理请求（最大线程数的线程在空闲存活时间后会被回收），如果前三者都满了，则会触发拒绝策略（抛弃等待队列队首或者队尾的请求，抛出或者不抛出异常）。</p><p>线程池参数源码</p><pre><code class="highlight java:n">/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the *        pool * @param keepAliveTime when the number of threads is greater than *        the core, this is the maximum time that excess idle threads *        will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are *        executed.  This queue will hold only the &#123;@code Runnable&#125; *        tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor *        creates a new thread * @param handler the handler to use when execution is blocked *        because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; *         &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) &#123;    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;= 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;&#125;</code></pre><h2><span id="corepoolsize-核心线程数">corePoolSize 核心线程数</span></h2><p>指的是核心线程大小，线程池中维护一个最小的线程数量，即使这些线程处于空闲状态，也一直存在池中，除非设置了核心线程超时时间。</p><h2><span id="maximunpoolsize">maximunPoolSize</span></h2><p>指的是线程池中允许的最大线程数量。当线程池中核心线程都处理执行状态，有新请求的任务：<br>1、工作队列未满：新请求的任务加入工作队列<br>2、工作队列已满：线程池会创建新线程，来执行这个任务。当然，创建新线程不是无限制的，因为会受到 <strong>maximumPoolSize</strong> 最大线程数量的限制。</p><h2><span id="keepalivetime">keepAliveTime</span></h2><p>指的是空闲线程存活时间。具体说，当线程数大于核心线程数时，空闲线程在等待新任务到达的最大时间，如果超过这个时间还没有任务请求，该空闲线程就会被销毁。</p><h2><span id="unit">unit</span></h2><p>指空闲线程存活时间的单位。keepAliveTime的计量单位。枚举类型TimeUnit类</p><h2><span id="workqueue">workQueue</span></h2><h3><span id="arrayblockingqueue">ArrayBlockingQueue</span></h3><p>基于数组的有界阻塞队列，特点FIFO（先进先出）。<br>当线程池中已经存在最大数量的线程时候，再请求新的任务，这时就会将任务加入工作队列的队尾，一旦有空闲线程，就会取出队头执行任务。<br>因为是基于数组的有界阻塞队列，所以可以避免系统资源的耗尽。如果出现有界队列已满，最大数量的所有线程都处于执行状态，这时又有新的任务请求，会采用Handler拒绝策略，对请求的任务进行处理。</p><h3><span id="linkedblockingqueue">LinkedBlockingQueue</span></h3><p>基于链表的无界阻塞队列，默认最大容量Integer.MAX_VALUE( 2^{32}-1​)，可认为是无限队列，特点FIFO。<br>关于<strong>maximumPoolSize</strong>参数在工作队列为LinkedBlockingQueue时候，是否起作用这个问题，我们需要视情况而定！</p><blockquote><p>情况①：如果指定了工作队列大小，比如core&#x3D;2，max&#x3D;3，workQueue&#x3D;2，任务数task&#x3D;5，这种情况的最大线程数量的限制是有效的。<br>情况②：如果工作队列大小默认<strong>2^32 -1</strong>，这时<strong>maximumPoolSize</strong>不起作用，因为新请求的任务一直可以加到队列中。</p></blockquote><h3><span id="priorityblockingqueue">PriorityBlockingQueue</span></h3><p>优先级无界阻塞队列，优先级阻塞队列可以通过参数Comparator实现对任务进行排序。</p><h3><span id="synchronousqueue">SynchronousQueue</span></h3><p>不缓存任务的阻塞队列，它实际上不是真正的队列，因为它没有提供存储任务的空间。生产者一个任务请求到来，会直接执行，也就是说这种队列在消费者充足的情况下更加适合。</p><h2><span id="threadfactory">threadFactory</span></h2><p>线程工厂，创建一个新线程时使用的工厂，可以用来设定线程名、是否为<strong>daemon线程</strong>等。</p><p>Java线程分两种：用户线程和守护线程。<br>守护线程，是指在程序运行的时，后台提供一种通用服务的线程。比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。<br>守护线程和用户线程的没有本质的区别，不同之处在于虚拟机的离开；若用户线程已全部退出运行，只剩守护线程存在，虚拟机也即退出。 因没有了被守护者，守护线程也就无工作可做，也就没有继续运行程序的必要了。<br>将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。在使用守护线程时需要注意一下几点：<br>(1)thread.setDaemon(true)须在thread.start()之前设置，不能把正在运行的常规线程设置为守护线程，否则会抛出IllegalThreadStateException异常。<br>(2) 在Daemon线程中创建的新线程也是Daemon的。<br>(3) 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。<br>(4)java多线程编程，偏向使用java自带的多线程框架，比如ExecutorService，但是java的线程池会将守护线程转换为用户线程，所以如果要使用后台线程就不能用java的线程池。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * The default thread factory</span><span class="comment"> */</span><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;    DefaultThreadFactory() &#123;        <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();        group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :                              Thread.currentThread().getThreadGroup();        namePrefix = <span class="string">&quot;pool-&quot;</span> +                      poolNumber.getAndIncrement() +                     <span class="string">&quot;-thread-&quot;</span>;    &#125;    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,                              namePrefix + threadNumber.getAndIncrement(),                              <span class="number">0</span>);        <span class="keyword">if</span> (t.isDaemon())            t.setDaemon(<span class="literal">false</span>);        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)            t.setPriority(Thread.NORM_PRIORITY);        <span class="keyword">return</span> t;    &#125;&#125;</code></pre><h2><span id="rejectedexecutionhandler-拒绝执行处理器">RejectedExecutionHandler 拒绝执行处理器</span></h2><p>Java 并发超出线程数和工作队列时候的任务请求处理策略，使用了策略设计模式。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * A handler for tasks that cannot be executed by a &#123;<span class="doctag">@link</span> ThreadPoolExecutor&#125;.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@since</span> 1.5</span><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RejectedExecutionHandler</span> &#123;    <span class="comment">/**</span><span class="comment">     * Method that may be invoked by a &#123;<span class="doctag">@link</span> ThreadPoolExecutor&#125; when</span><span class="comment">     * &#123;<span class="doctag">@link</span> ThreadPoolExecutor#execute execute&#125; cannot accept a</span><span class="comment">     * task.  This may occur when no more threads or queue slots are</span><span class="comment">     * available because their bounds would be exceeded, or upon</span><span class="comment">     * shutdown of the Executor.</span><span class="comment">     *</span><span class="comment">     * &lt;p&gt;In the absence of other alternatives, the method may throw</span><span class="comment">     * an unchecked &#123;<span class="doctag">@link</span> RejectedExecutionException&#125;, which will be</span><span class="comment">     * propagated to the caller of &#123;<span class="doctag">@code</span> execute&#125;.</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span><span class="comment">     * <span class="doctag">@param</span> executor the executor attempting to execute this task</span><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if there is no remedy</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span>;&#125;</code></pre><h3><span id="threadpoolexecutorabortpolicy">ThreadPoolExecutor.AbortPolicy</span></h3><p>在默认的处理策略。该处理在拒绝时抛出RejectedExecutionException，拒绝执行。<br>默认处理器直接抛出异常</p><pre><code class="highlight java:n">public static class AbortPolicy implements RejectedExecutionHandler &#123;     /**      * Creates an &#123;@code AbortPolicy&#125;.      */     public AbortPolicy() &#123; &#125;     /**      * Always throws RejectedExecutionException.      *      * @param r the runnable task requested to be executed      * @param e the executor attempting to execute this task      * @throws RejectedExecutionException always      */     public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;         throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +                                              &quot; rejected from &quot; +                                              e.toString());     &#125; &#125;</code></pre><h3><span id="threadpoolexecutorcallerrunspolicy">ThreadPoolExecutor.CallerRunsPolicy</span></h3><p>调用 execute 方法的线程(current thread) 本身运行任务。并提供了一个简单的反馈控制机制，可以降低新任务提交的速度。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * A handler for rejected tasks that runs the rejected task</span><span class="comment"> * directly in the calling thread of the &#123;<span class="doctag">@code</span> execute&#125; method,</span><span class="comment"> * unless the executor has been shut down, in which case the task</span><span class="comment"> * is discarded.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;    <span class="comment">/**</span><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> CallerRunsPolicy&#125;.</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="title function_">CallerRunsPolicy</span><span class="params">()</span> &#123; &#125;    <span class="comment">/**</span><span class="comment">     * Executes task r in the caller&#x27;s thread, unless the executor</span><span class="comment">     * has been shut down, in which case the task is discarded.</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;        <span class="keyword">if</span> (!e.isShutdown()) &#123;            r.run();        &#125;    &#125;&#125;</code></pre><h3><span id="threadpoolexecutordiscardoldestpolicy">ThreadPoolExecutor.DiscardOldestPolicy</span></h3><p>如果执行程序未关闭，则删除工作队列头部的任务，然后重试执行(可能再次失败，导致重复执行)。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;    <span class="comment">/**</span><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="title function_">DiscardOldestPolicy</span><span class="params">()</span> &#123; &#125;    <span class="comment">/**</span><span class="comment">     * Obtains and ignores the next task that the executor</span><span class="comment">     * would otherwise execute, if one is immediately available,</span><span class="comment">     * and then retries execution of task r, unless the executor</span><span class="comment">     * is shut down, in which case task r is instead discarded.</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;        <span class="keyword">if</span> (!e.isShutdown()) &#123;            e.getQueue().poll();            e.execute(r);        &#125;    &#125;&#125;</code></pre><h3><span id="threadpoolexecutordiscardpolicy">ThreadPoolExecutor.DiscardPolicy</span></h3><p>无法执行的任务被简单地删除，将会丢弃当前任务，通过源码可以看出，该策略不会执行任务操作。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;    <span class="comment">/**</span><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> DiscardPolicy&#125;.</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="title function_">DiscardPolicy</span><span class="params">()</span> &#123; &#125;    <span class="comment">/**</span><span class="comment">     * Does nothing, which has the effect of discarding task r.</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">java线程池的七大参数,corePoolSize、maximunPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler...</summary>
    
    
    
    <category term="java线程池" scheme="https://mirsery.github.io/categories/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="java" scheme="https://mirsery.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>netty 高性能框架的原理</title>
    <link href="https://mirsery.github.io/2024/02/03/java/2024/netty-%E9%AB%98%E6%80%A7%E8%83%BD%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://mirsery.github.io/2024/02/03/java/2024/netty-%E9%AB%98%E6%80%A7%E8%83%BD%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2024-02-03T05:47:52.000Z</published>
    <updated>2024-02-03T05:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#netty-%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E5%9B%A0">netty 高性能原因</a><ul><li><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a></li><li><a href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF-io">异步通讯 IO</a></li><li><a href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF">零拷贝技术</a></li><li><a href="#%E5%86%85%E5%AD%98%E6%B1%A0%E6%8A%80%E6%9C%AF">内存池技术</a></li><li><a href="#%E9%AB%98%E6%95%88%E7%9A%84-reactor-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">高效的 Reactor 线程模型</a></li><li><a href="#reactor-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">Reactor 单线程模型</a></li></ul></li></ul><!-- tocstop --><h2><span id="netty-高性能原因">netty 高性能原因</span></h2><h3><span id="多路复用">多路复用</span></h3><p>Netty 的 IO 线程 NioEventLoop 由于聚合了多路复用器 Selector、epoll，可以同时并发处理成百上千个客户端 Channel。<br>由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 IO 阻塞导致的线程挂起。</p><h3><span id="异步通讯-io">异步通讯 IO</span></h3><p>Netty 采用了异步通信模式，一个IO 线程可以并发处理N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p><h3><span id="零拷贝技术">零拷贝技术</span></h3><p>netty 接收和发送 Bytebuffer 采用堆外直接内存进行 socket 读写。<br>传统网络传输情况下，网卡首先接收到数据，并将数据拷贝至操作系统的缓冲区，此时内核态切换至用户态，应用程序读取内核缓冲区的数据，用户态切换成内核态，cpu 将数据拷贝至用户缓存空间中，这样用户程序就可以操作这些数据。用户处理完数据之后，向用户缓冲区中发送数据并刷新缓存。此时用户态转换成内核态，cpu 将数据拷贝至操作内核 socket缓冲区，利用 DMA技术将数据拷贝至网卡然后发送出去。<br>netty 框架使用Bytebuf 来接收处理这些数据，netty 读取数据的时候采用内存映射 <strong>mmap 技术</strong>，此时用户态可以直接访问内核缓冲区的数据并不需要 cpu 进行拷贝，减少了一次上下文切换以及数据的拷贝。<br>当 netty 发送数据时，采用 Bytebuf，利用底层的 sendfile 方法（linux2.1 之后提供的方法，java 中对应的是FileChannel.transferTo方法）文件映射的技术直接访问向内核缓冲区发送数据，减少一次上下文切换以及 cpu 的拷贝。采用零拷贝技术减少了 2 次上下文切换以及避免了数据发送过程中 cpu 参与的数据拷贝降低的 cpu 的负载使得系统性能得以提升。</p><h3><span id="内存池技术">内存池技术</span></h3><p>随着 JVM 虚拟机和 JIT 即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区 Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。</p><h3><span id="高效的-reactor-线程模型">高效的 Reactor 线程模型</span></h3><p>常用的 Reactor 线程模型有三种，Reactor 单线程模型, Reactor 多线程模型, 主从 Reactor 多线程模型。</p><h3><span id="reactor-单线程模型">Reactor 单线程模型</span></h3><p>Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程的职责如下：</p><ol><li><p>作为 NIO 服务端，接收客户端的 TCP 连接；</p></li><li><p>作为 NIO 客户端，向服务端发起 TCP 连接；</p></li><li><p>读取通信对端的请求或者应答消息</p></li><li><p>向通信对端发送消息请求或者应答消息。</p></li></ol><p>由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独立处理所有 IO 相关的操作。从架构层面看，一个 NIO 线程确实可以完成其承担的职责。例如，通过Acceptor 接收客户端的 TCP 连接请求消息，链路建立成功之后，通过 Dispatch 将对应的 ByteBuffer 派发到指定的 Handler 上进行消息解码。用户 Handler 可以通过 NIO 线程将消息发送给客户端。</p>]]></content>
    
    
    <summary type="html">‘netty 是一个高性能、异步事件驱动的 nio 框架，所有的操作都是异步非阻塞的...’</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="netty" scheme="https://mirsery.github.io/tags/netty/"/>
    
    <category term="nio" scheme="https://mirsery.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的锁二</title>
    <link href="https://mirsery.github.io/2024/01/30/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/"/>
    <id>https://mirsery.github.io/2024/01/30/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/</id>
    <published>2024-01-30T05:47:18.000Z</published>
    <updated>2024-01-30T05:47:18.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#innodb-%E9%94%81">InnoDB 锁</a><ul><li><a href="#%E4%BA%8B%E5%8A%A1transaction%E5%8F%8A%E5%85%B6acid%E5%B1%9E%E6%80%A7">事务（Transaction）及其ACID属性</a></li><li><a href="#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98">事务并发问题</a></li><li><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务隔离级别</a></li><li><a href="#%E8%8E%B7%E5%8F%96inonodb%E8%A1%8C%E9%94%81%E4%BA%89%E7%94%A8%E6%83%85%E5%86%B5">获取InonoDB行锁争用情况</a></li><li><a href="#innodb%E7%9A%84%E8%A1%8C%E9%94%81%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%8A%A0%E9%94%81%E6%96%B9%E6%B3%95">InnoDB的行锁模式及加锁方法</a></li><li><a href="#innodb%E8%A1%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">InnoDB行锁实现方式</a></li><li><a href="#%E9%97%B4%E9%9A%99%E9%94%81next-key%E9%94%81">间隙锁（Next-Key锁）</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E8%A1%A8%E9%94%81">什么时候使用表锁</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E6%AD%BB%E9%94%81">关于死锁</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul><!-- tocstop --><h1><span id="innodb-锁">InnoDB 锁</span></h1><p>InnoDB与MyISAM的最大不同有两点：</p><ul><li>一是支持事务（TRANSACTION）</li><li>二是采用了行级锁。</li></ul><h2><span id="事务transaction及其acid属性">事务（Transaction）及其ACID属性</span></h2><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p><ul><li>原性性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li><li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li><li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li></ul><h2><span id="事务并发问题">事务并发问题</span></h2><pre><code>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。</code></pre><p>并发事务处理也会带来一些问题，主要包括以下几种情况：</p><ol><li>更新丢失（Lost Update）<br>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。<br>例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。<br>如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。</li><li>脏读（Dirty Reads）<br>一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</li><li>不可重复读（Non-Repeatable Reads）<br> 一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li><li>幻读（Phantom Reads）<br>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</li></ol><h2><span id="事务隔离级别">事务隔离级别</span></h2><p>在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。<br>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。<br>数据库实现事务隔离的方式，基本可以分为以下两种。</p><ol><li>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li><li>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</li></ol><p>数据库的事务隔离级别越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的，同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。<br>为了解决“隔离”与“并发”的矛盾，ISO&#x2F;ANSI SQL92定义了４个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己业务逻辑要求，通过选择不同的隔离级别来平衡＂隔离＂与＂并发＂的矛盾。</p><table><thead><tr><th align="left">隔离级别&#x2F;读数据一致性及允许的并发副作用</th><th align="left">读数据一致性</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="left">未提交读（Read uncommitted）</td><td align="left">最低级别，只能保证不读取物理上损坏的数据</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="left">已提交读（Read committed）</td><td align="left">语句级</td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="left">可重复读（Repeatable read）</td><td align="left">事务级</td><td align="center">否</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="left">可序列化（Serializable）</td><td align="left">最高级别事务级</td><td align="center">否</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><h2><span id="获取inonodb行锁争用情况">获取InonoDB行锁争用情况</span></h2><p>可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：</p><pre><code class="highlight sql"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</code></pre><p><img src="/2024/01/30/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/InnoDB_row_lock.png"></p><table><thead><tr><th align="center">Innodb_row_lock_current_waits</th><th align="center">当前正在等待锁定的数量</th></tr></thead><tbody><tr><td align="center">Innodb_row_lock_time</td><td align="center">从系统启动到现在锁定总时间长度</td></tr><tr><td align="center">Innodb_row_lock_time_avg</td><td align="center">每次等待所花平均时间</td></tr><tr><td align="center">Innodb_row_lock_time_max</td><td align="center">从系统启动到现在等待最长的一次所花时间</td></tr><tr><td align="center">Innodb_row_lock_waits</td><td align="center">系统启动后到现在总共等待的次数</td></tr></tbody></table><p>如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高。<br>还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p><h2><span id="innodb的行锁模式及加锁方法">InnoDB的行锁模式及加锁方法</span></h2><p>InnoDB实现了以下两种类型的<strong>行锁</strong>。</p><ul><li>共享锁（s）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（Ｘ）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。</li></ul><p>意向锁（Intention Lock）：又称I锁，针对表锁，主要是为了提高加表锁的效率，是mysql数据库自己加的。当有事务给表的数据行加了共享锁或排他锁，同时会给表设置一个标识，代表已经有行锁了，其他事务要想对表加表锁时，就不必逐行判断有没有行锁可能跟表锁冲突了，直接读这个标识就可以确定自己该不该加表锁。特别是表中的记录很多时，逐行判断加表锁的方式效率很低。而这个标识就是意向锁。<br>意向共享锁，IS锁，对整个表加共享锁之前，需要先获取到意向共享锁。<br>意向排他锁，IX锁，对整个表加排他锁之前，需要先获取到意向排他锁。</p><p>另外，为了允许行锁和表锁共存，实现多粒度锁机制。InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>。</p><ul><li>意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ul><p>InnoDB行锁模式兼容性列表</p><table><thead><tr><th align="left">当前锁模式&#x2F;是否兼容&#x2F;请求锁模式</th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="left">X</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">冲突</td></tr><tr><td align="left">IX</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">冲突</td><td align="center">兼容</td></tr><tr><td align="left">S</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="left">IS</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。意向锁是InnoDB自动加的，不需用户干预。</p><p>对于<strong>UPDATE</strong>、<strong>DELETE</strong>和<strong>INSERT</strong>语句，InnoDB会自动给涉及及数据集加排他锁（Ｘ）；</p><p>对于普通<strong>SELECT</strong>语句，InnoDB不会加任何锁；</p><p>事务可以通过以下语句显示给记录集加共享锁或排锁。<br>共享锁（Ｓ）：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code><br>排他锁（X）：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code></p><p>用<code>SELECT .. IN SHARE MODE</code>获得共享锁，主要用在需要数据依存关系时确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT … FOR UPDATE方式获取排他锁。</p><h2><span id="innodb行锁实现方式">InnoDB行锁实现方式</span></h2><p>InnoDB行锁是通过<strong>索引上的索引项</strong>来实现的。InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁。在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><h2><span id="间隙锁next-key锁">间隙锁（Next-Key锁）</span></h2><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；</p><p>对于键值在条件范围内但并不存在的记录，叫做“<strong>间隙(GAP)<strong>”，InnoDB也会对这个“</strong>间隙</strong>”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p><p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></code></pre><ul><li><strong>FOR UPDATE</strong>：表示对查询结果进行加锁，其他事务不能修改或删除查询结果中涉及到的行。</li><li><strong>FOR SHARE</strong>：表示对查询结果进行共享锁，其他事务可以读取查询结果中涉及到的行，但不能修改或删除。</li></ul><p>上面 sql 语句是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><p>InnoDB使用间隙锁的目的：<br>    - 一方面是为了防止幻读，以满足相关隔离级别的要求；对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；<br>    - 另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。</p><blockquote><p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。<br>因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p></blockquote><h2><span id="什么时候使用表锁">什么时候使用表锁</span></h2><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。</p><p>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</p><p>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</p><p>当然，应用中这两种事务不能太多，否则，就应该考虑使用ＭyISAＭ表。<br>在InnoDB下 ，使用表锁要注意以下两点。<br>（１） 使用<strong>LOCK TALBES</strong>虽然可以给<strong>InnoDB</strong>加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层ＭySQL Server负责的，仅当autocommit&#x3D;0、innodb_table_lock&#x3D;1（默认设置）时，InnoDB层才能知道MySQL加的表锁，ＭySQL Server才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。<br>（２） 在用<strong>LOCAK TABLES</strong>对<strong>InnoDB</strong>加锁时要注意，要将<strong>AUTOCOMMIT设为0</strong>，否则ＭySQL不会给表加锁；事务结束前，不要用<strong>UNLOCAK TABLES</strong>释放表锁，因为<strong>UNLOCK TABLES</strong>会隐含地提交事务；<br>COMMIT或ROLLBACK不能释放用LOCAK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁，正确的方式见如下语句. 例如，如果需要写表t1并从表t读，可以按如下做：</p><pre><code class="highlight sql"><span class="keyword">SET</span> AUTOCOMMIT<span class="operator">=</span><span class="number">0</span>;LOCAK TABLES t1 WRITE, t2 READ, ...;[do something <span class="keyword">with</span> tables t1 <span class="keyword">and</span> here];<span class="keyword">COMMIT</span>;UNLOCK TABLES;</code></pre><h2><span id="关于死锁">关于死锁</span></h2><p>在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了InnoDB发生死锁是可能的。发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并退回，另一个事务获得锁，继续完成事务。<br>但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。<br>需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获取所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖垮数据库。<br>我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小、以及访问数据库的SQL语句，绝大部分都可以避免。<br>下面就通过实例来介绍几种避免死锁的常用方法:<br>（１） 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序为访问表，这样可以大大降低产生死锁的机会。如果两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可能避免。<br>（２） 在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低死锁的可能。<br>（３） 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁。<br>（４） 在<strong>REPEATEABLE-READ</strong>隔离级别下，如果两个线程同时对相同条件记录用<code>SELECT...ROR UPDATE</code>加排他锁，在没有符合该记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成<code>READ COMMITTED</code>，就可以避免问题。<br>（５） 当隔离级别为<strong>READ COMMITED</strong>时，如果两个线程都先执行<code>SELECT...FOR UPDATE</code>，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第１个线程提交后，第２个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第３个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。</p><p>尽管通过上面的设计和优化等措施，可以大减少死锁，但死锁很难完全避免。因此，在程序设计中总是捕获并处理死锁异常是一个很好的编程习惯。<br>如果出现死锁，可以用SHOW INNODB STATUS命令来确定最后一个死锁产生的原因和改进措施。</p><h2><span id="总结">总结</span></h2><p>InnoDB在执行查询语句SELECT时，因为有mvcc机制不会加锁。但是update、insert、delete操作会加行锁。<br>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。<br>无索引行锁会升级为表锁(RR级别会升级为表锁，RC级别不会升级为表锁)。<br>锁定某一行还可以用lock in share mode(共享锁) 和for update(排它锁)，例如：<code>select * from test_innodb_lock where a = 2 for update;</code><br>这样其他session只能读这行数据，修改则会被阻塞，直到锁定行的session提交</p><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一下，但是在整体并发处理能力方面要远远优于MYISAM的表级锁定的。当系统并发量高的时候，Innodb的整体性能和MYISAM相比就会有比较明显的优势了。但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MYISAM高，甚至可能会更差。</p><p>对于InnoDB表，主要有以下几点:<br>（１） InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。<br>（２） InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。<br>（３） 在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。<br>（４） ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。<br>（５） 锁冲突甚至死锁很难完全避免。</p><p>在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</p><ol><li>尽量使用较低的隔离级别</li><li>精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li><li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li><li>不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li></ol>]]></content>
    
    
    <summary type="html">‘InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）、二是采用了行级锁....’</summary>
    
    
    
    <category term="mysql" scheme="https://mirsery.github.io/categories/mysql/"/>
    
    
    <category term="锁" scheme="https://mirsery.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的锁一</title>
    <link href="https://mirsery.github.io/2024/01/30/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%80/"/>
    <id>https://mirsery.github.io/2024/01/30/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%80/</id>
    <published>2024-01-30T05:47:12.000Z</published>
    <updated>2024-01-30T05:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a><ul><li><a href="#mysql-myisam%E8%A1%A8%E7%BA%A7%E9%94%81%E7%9A%84%E9%94%81%E6%A8%A1%E5%BC%8F">MySQL MyISAM表级锁的锁模式</a></li><li><a href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E7%9A%84%E9%94%81%E6%A8%A1%E5%BC%8F">表级锁的锁模式</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%8A%A0%E8%A1%A8%E9%94%81">如何加表锁</a></li><li><a href="#%E5%B9%B6%E5%8F%91%E9%94%81">并发锁</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E6%AD%BB%E9%94%81">关于死锁</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul><!-- tocstop --><h1><span id="概述">概述</span></h1><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。<br>MySQL大致可归纳为以下3种锁：</p><table><thead><tr><th>类别</th><th>开销</th><th>速度</th><th>锁粒度</th><th>锁冲突</th><th>死锁风险</th><th>并发度</th></tr></thead><tbody><tr><td>表级锁</td><td>最小</td><td>最快</td><td>最大</td><td>概率最高</td><td>无</td><td>最低</td></tr><tr><td>行级锁</td><td>最大</td><td>最小</td><td>最小</td><td>概率最低</td><td>有</td><td>最高</td></tr><tr><td>页面锁</td><td>中</td><td>中</td><td>中</td><td>中</td><td>有</td><td>中</td></tr></tbody></table><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p><h2><span id="mysql-myisam表级锁的锁模式">MySQL MyISAM表级锁的锁模式</span></h2><p>MySQL表级锁有两种模式：表共享锁（Table Read Lock）和表独占写锁（Table Write Lock）。<br>对MyISAM的读操作，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求；<br>对MyISAM的写操作，则会阻塞其他用户对同一表的读和写操作；<br>MyISAM表的读操作和写操作之间，以及写操作之间是串行的。<br>当一个线程获得对一个表的写锁后，只有持有锁线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</p><h2><span id="表级锁的锁模式">表级锁的锁模式</span></h2><p> ＭySQL的表锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。</p><p>锁模式的兼容性</p><table><thead><tr><th>请求锁模式</th><th>None</th><th>读锁</th><th>写锁</th></tr></thead><tbody><tr><td>读锁</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>写锁</td><td>Y</td><td>N</td><td>N</td></tr></tbody></table><p>对ＭyISAM引擎的表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；<br>对ＭyISAM表的写操作，则会阻塞其他用户对同一表的读和写请求；<br>ＭyISAM表的读和写操作之间，以及写和写操作之间是串行的！（当一线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。）</p><h2><span id="如何加表锁">如何加表锁</span></h2><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁.</p><blockquote><p>在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p></blockquote><p>给MyISAM表显示加锁，一般是为了一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表 <em><strong>orders</strong></em> ，其中记录有订单的总金额 total ，同时还有一个订单明细表 <em><strong>order_detail</strong></em> ，其中记录有订单每一产品的金额小计 subtotal ,假设我们需要检查这两个表的金额合计是否相等，可能就需要执行如下两条SQL:</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(total) <span class="keyword">FROM</span> orders;<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(subtotal) <span class="keyword">FROM</span> order_detail;</code></pre><p>这时，如果不先给这两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，<em><strong>order_detail</strong></em> 表可能已经发生了改变。因此，正确的方法应该是：</p><pre><code class="highlight sql">LOCK tables orders read <span class="keyword">local</span>,order_detail read <span class="keyword">local</span>;<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(total) <span class="keyword">FROM</span> orders;<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(subtotal) <span class="keyword">FROM</span> order_detail;Unlock tables;</code></pre><blockquote><p>要特别说明以下两点内容。<br>上面的例子在 <strong>LOCK TABLES</strong> 时加了<strong>local</strong>选项，其作用就是在满足<strong>MyISAM</strong>表并发插入条件的情况下，允许其他用户在表尾插入记录.<br>在用<strong>LOCK TABLES</strong>给表显式加表锁时，必须同时取得所有涉及表的锁，并且MySQL支持锁升级。也就是说，在执行<strong>LOCK TABLES</strong>后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MySQL问题一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现<strong>死锁（Deadlock Free）</strong>的原因.<br>一个session使用<strong>LOCK TABLE</strong>命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。<br>当使用<strong>LOCK TABLE</strong>时，不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁多少次，否则也会出错！</p></blockquote><h2><span id="并发锁">并发锁</span></h2><p>在一定条件下，MyISAM也支持查询和操作的并发进行。<br>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。<br>当concurrent_insert设置为0时，不允许并发插入。<br>当concurrent_insert设置为1时，MyISAM允许在一个读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。<br>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾插入记录，都允许在表尾并发插入记录。<br>可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入锁争用。例如，将concurrent_insert系统变量为2，总是允许并发插入；同时，通过定期在系统空闲时段执行OPTIONMIZE TABLE语句来整理空间碎片，收到因删除记录而产生的中间空洞。</p><h2><span id="关于死锁">关于死锁</span></h2><p>ＭyISAM表锁是deadlock free的，这是因为ＭyISAM总是一次性获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。</p><h2><span id="总结">总结</span></h2><p>MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加<strong>读锁</strong><br>在执行update、insert、delete操作会自动给涉及的表加<strong>写锁</strong>。</p><p>对于ＭyISAM的表锁，主要有以下几点<br>（１） 共享读锁（S）之间是兼容的，但共享读锁（S）和排他写锁（X）之间，以及排他写锁之间（X）是互斥的，也就是说读和写是串行的。<br>（２） 在一定条件下，ＭyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表和插入的锁争用问题。<br>（３） ＭyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIPORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。<br>（４） 由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，ＭyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</p>]]></content>
    
    
    <summary type="html">MySQL(MYISAM)表级锁有两种模式：表共享锁（Table Read Lock）和表独占写锁（Table Write Lock）....</summary>
    
    
    
    <category term="mysql" scheme="https://mirsery.github.io/categories/mysql/"/>
    
    
    <category term="锁" scheme="https://mirsery.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq笔记</title>
    <link href="https://mirsery.github.io/2024/01/29/talk/2024/rabbitmq%E7%AC%94%E8%AE%B0/"/>
    <id>https://mirsery.github.io/2024/01/29/talk/2024/rabbitmq%E7%AC%94%E8%AE%B0/</id>
    <published>2024-01-29T02:43:45.000Z</published>
    <updated>2024-01-29T02:43:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#exchange-%E7%B1%BB%E5%9E%8B">exchange 类型</a><ul><li><a href="#fanout">fanout</a></li><li><a href="#direct">direct</a></li><li><a href="#topic-%E4%BA%A4%E6%8D%A2%E6%9C%BA">topic 交换机</a></li></ul></li><li><a href="#rabbitmq%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B">rabbitmq的架构模型</a></li></ul><!-- tocstop --><h2><span id="概述">概述</span></h2><p><img src="/2024/01/29/talk/2024/rabbitmq%E7%AC%94%E8%AE%B0/rabbitmq_info.png"></p><p>Rabbitmq一些常见的角色</p><ul><li>publisher 生产者</li><li>consumer 消费者</li><li>exchange 交换机，负责消息路由</li><li>queue 队列，存储信息</li><li>virtualHost 虚拟主机</li></ul><h2><span id="exchange-类型">exchange 类型</span></h2><p>发布订阅模式与之前案例的区别就是允许将同一消息发送给多个消费者。实现方式是加入了exchange（交换机）。</p><p>常见exchange类型包括：<br>Fanout：广播-将消息交给所有绑定到交换机的队列<br>Direct：定向-把消息交给符合指定routing key 的队列<br>Topic：通配符-把消息交给符合routing pattern（路由模式） 的队列</p><h3><span id="fanout">fanout</span></h3><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。</p><h3><span id="direct">direct</span></h3><p>在Direct模型下：<br>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）<br>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。<br>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息。</p><h3><span id="topic-交换机">topic 交换机</span></h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p>通配符规则：</p><ul><li><code>#</code>：匹配一个或多个词 <code>item.spu.insert</code></li><li><code>*</code>：匹配不多不少恰好1个词 <code>item.spu</code></li></ul><h2><span id="rabbitmq的架构模型">rabbitmq的架构模型</span></h2>]]></content>
    
    
    <summary type="html">MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker，从而实现异步调用(同步调用用Feign)</summary>
    
    
    
    <category term="笔记" scheme="https://mirsery.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="mq" scheme="https://mirsery.github.io/tags/mq/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁</title>
    <link href="https://mirsery.github.io/2024/01/18/linux/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>https://mirsery.github.io/2024/01/18/linux/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</id>
    <published>2024-01-18T06:25:24.000Z</published>
    <updated>2024-01-18T06:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">乐观锁和悲观锁</a><ul><li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a></li><li><a href="#%E4%BC%98%E7%BC%BA%E7%82%B9">优缺点</a></li><li><a href="#cas%E7%9A%84%E4%B8%8D%E8%B6%B3">CAS的不足</a></li></ul></li></ul><!-- tocstop --><h1><span id="乐观锁和悲观锁">乐观锁和悲观锁</span></h1><p>对待数据并发的锁的设计思想分为乐观锁和悲观锁。</p><ul><li>乐观锁<br>乐观锁对每次数据操作保持乐观态度，不会对数据进行上锁。每次修改数据的时候需要对数据判断是否被修改过。</li><li>悲观锁<br>悲观锁在操作数据时候比较悲观，认为别人会同时修改数据。每次操作的时候会对数据上锁，防止在操作的过程中被他人同时操作导致更新丢失。</li></ul><h2><span id="实现方式">实现方式</span></h2><ul><li>乐观锁：</li></ul><ol><li><p>采用版本号或者时间戳。在表中增加version 或者 updatetime 字段，在每次更新操作的时候对比下该字段，如果一直则更新数据，数据不等则放弃本次修改，根据实际业务需求做相应的处理。</p><blockquote><p>CAS包含了Compare和Swap两个操作,CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。</p></blockquote></li><li><p>采用 CAS 方式，对应 java 中的（compareAndSwap）。CAS 操作涉及到三个操作数，内存值（valueOffSet）、期望值（expect）、更新值（update）。当内存值和期望值一致的时候会更新数据，反之不会操作。</p></li></ol><ul><li>悲观锁：</li></ul><ol><li>数据库实现方式：使用数据库的读锁、写锁、行锁等实现进程的悬挂阻塞等当前操作完成之后才能进行下一个操作。</li><li>java 中采用 <em><strong>synchronize</strong></em> 关键字实现悲观锁。</li></ol><h2><span id="优缺点">优缺点</span></h2><p>乐观锁和悲观锁并没有优劣之分，下面从功能上和竞争激烈程度两个方面来分析其各自的优势以及适用场景。</p><ul><li><p>适用场景：<br>  乐观锁：由于不上锁的特性，性能方面由于悲观锁，适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。<br>  悲观锁 适合写操作比较多的场景，具有排他性。采用悲观锁的方式可以在数据库层面阻止其他事务对该数据的操作权限，防止读-写和写-写冲突。</p></li><li><p>功能限制<br>与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。<br>例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。</p></li><li><p>竞争激烈程度<br>如果悲观锁和乐观锁都可以使用，那么选择就要考虑竞争的激烈程度：<br>当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。<br>当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。</p></li></ul><h2><span id="cas的不足">CAS的不足</span></h2><ol><li><p>无法解决ABA问题<br> (1)线程1读取内存中数据为A<br> (2)线程2将该数据修改为B<br> (3)线程2将该数据修改为A<br> (4)线程1对数据进行CAS操作<br>在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。<br>但是在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。</p></li><li><p>高竞争下的开销问题 在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。</p></li><li><p>功能限制 CAS的功能是比较受限的，例如CAS只能保证单个变量（或者说单个内存值）操作的原子性。<br> (1) 原子性不一定能保证线程安全，例如在Java中需要与volatile配合来保证线程安全；<br> (2) 当涉及到多个变量(内存值)时，CAS也无能为力。</p></li></ol>]]></content>
    
    
    <summary type="html">‘乐观锁和悲观锁对待数据并发的锁的设计思想分为乐观锁和悲观锁。’</summary>
    
    
    
    <category term="并发" scheme="https://mirsery.github.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://mirsery.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java" scheme="https://mirsery.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁</title>
    <link href="https://mirsery.github.io/2024/01/18/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>https://mirsery.github.io/2024/01/18/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</id>
    <published>2024-01-18T06:25:24.000Z</published>
    <updated>2024-01-18T06:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">乐观锁和悲观锁</a><ul><li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a></li><li><a href="#%E4%BC%98%E7%BC%BA%E7%82%B9">优缺点</a></li><li><a href="#cas%E7%9A%84%E4%B8%8D%E8%B6%B3">CAS的不足</a></li></ul></li></ul><!-- tocstop --><h1><span id="乐观锁和悲观锁">乐观锁和悲观锁</span></h1><p>对待数据并发的锁的设计思想分为乐观锁和悲观锁。</p><ul><li>乐观锁<br>乐观锁对每次数据操作保持乐观态度，不会对数据进行上锁。每次修改数据的时候需要对数据判断是否被修改过。</li><li>悲观锁<br>悲观锁在操作数据时候比较悲观，认为别人会同时修改数据。每次操作的时候会对数据上锁，防止在操作的过程中被他人同时操作导致更新丢失。</li></ul><h2><span id="实现方式">实现方式</span></h2><ul><li>乐观锁：</li></ul><ol><li><p>采用版本号或者时间戳。在表中增加version 或者 updatetime 字段，在每次更新操作的时候对比下该字段，如果一直则更新数据，数据不等则放弃本次修改，根据实际业务需求做相应的处理。</p><blockquote><p>CAS包含了Compare和Swap两个操作,CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。</p></blockquote></li><li><p>采用 CAS 方式，对应 java 中的（compareAndSwap）。CAS 操作涉及到三个操作数，内存值（valueOffSet）、期望值（expect）、更新值（update）。当内存值和期望值一致的时候会更新数据，反之不会操作。</p></li></ol><ul><li>悲观锁：</li></ul><ol><li>数据库实现方式：使用数据库的读锁、写锁、行锁等实现进程的悬挂阻塞等当前操作完成之后才能进行下一个操作。</li><li>java 中采用 <em><strong>synchronize</strong></em> 关键字实现悲观锁。</li></ol><h2><span id="优缺点">优缺点</span></h2><p>乐观锁和悲观锁并没有优劣之分，下面从功能上和竞争激烈程度两个方面来分析其各自的优势以及适用场景。</p><ul><li><p>适用场景：<br>  乐观锁：由于不上锁的特性，性能方面由于悲观锁，适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。<br>  悲观锁 适合写操作比较多的场景，具有排他性。采用悲观锁的方式可以在数据库层面阻止其他事务对该数据的操作权限，防止读-写和写-写冲突。</p></li><li><p>功能限制<br>与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。<br>例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。</p></li><li><p>竞争激烈程度<br>如果悲观锁和乐观锁都可以使用，那么选择就要考虑竞争的激烈程度：<br>当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。<br>当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。</p></li></ul><h2><span id="cas的不足">CAS的不足</span></h2><ol><li><p>无法解决ABA问题<br> (1)线程1读取内存中数据为A<br> (2)线程2将该数据修改为B<br> (3)线程2将该数据修改为A<br> (4)线程1对数据进行CAS操作<br>在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。<br>但是在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。</p></li><li><p>高竞争下的开销问题 在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。</p></li><li><p>功能限制 CAS的功能是比较受限的，例如CAS只能保证单个变量（或者说单个内存值）操作的原子性。<br> (1) 原子性不一定能保证线程安全，例如在Java中需要与volatile配合来保证线程安全；<br> (2) 当涉及到多个变量(内存值)时，CAS也无能为力。</p></li></ol>]]></content>
    
    
    <summary type="html">‘乐观锁和悲观锁对待数据并发的锁的设计思想分为乐观锁和悲观锁。’</summary>
    
    
    
    <category term="并发" scheme="https://mirsery.github.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://mirsery.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java" scheme="https://mirsery.github.io/tags/java/"/>
    
    <category term="锁" scheme="https://mirsery.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>水平触发和边缘触发</title>
    <link href="https://mirsery.github.io/2024/01/09/linux/%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E5%92%8C%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91/"/>
    <id>https://mirsery.github.io/2024/01/09/linux/%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E5%92%8C%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91/</id>
    <published>2024-01-09T05:37:26.000Z</published>
    <updated>2024-01-09T05:37:26.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#et%E6%A8%A1%E5%BC%8F">ET模式</a></li><li><a href="#lt%E6%A8%A1%E5%BC%8F">LT模式</a></li><li><a href="#%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E5%92%8C%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB">水平触发和边缘触发模式区别</a></li></ul><!-- tocstop --><p>EPOLL事件有两种模型:水平触发和边缘触发。</p><p>Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。<br>Level Triggered (LT) 水平触发只要有数据都会触发。<br>(两种触发模式，减少epoll_wait()调用的次数)<br>Epoll ET非阻塞IO 最优</p><h2><span id="et模式">ET模式</span></h2><p>ET模式即Edge Triggered工作模式，边缘触发。<br>ET(edge-triggered)：ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once).<br>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。<br>基于非阻塞文件句柄<br>只有当read或者write返回EAGAIN(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。<br>当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知。<br>当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知。<br>边缘触发仅仅在空变为非空的时候通知一次。</p><h2><span id="lt模式">LT模式</span></h2><p>LT模式即Level Triggered工作模式，水平触发。<br>与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用。<br>LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select&#x2F;poll都是这种模型的代表。<br>只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，<br>当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知<br>LT模式支持阻塞和非阻塞两种方式。epoll默认的模式是LT。</p><h2><span id="水平触发和边缘触发模式区别">水平触发和边缘触发模式区别</span></h2><pre><code>1.读缓冲区刚开始是空的2.读缓冲区写入2KB数据3.水平触发和边缘触发模式此时都会发出可读信号4.收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据5.水平触发会再次进行通知，而边缘触发不会再进行通知所以，边缘触发需要一次性的把缓冲区的数据读完为止，也就是一直读，直到读到EGAIN为止，EGAIN说明缓冲区已经空了，因为这一点，边缘触发需要设置文件句柄为非阻塞。</code></pre><p>epoll的两种工作方式：1.水平触发（LT）2.边缘触发（ET）<br>LT模式：若就绪的事件一次没有处理完要做的事件，就会一直去处理。即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表），一直进行处理。<br>ET模式：就绪的事件只能处理一次，若没有处理完会在下次的其它事件就绪时再进行处理。而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。<br>由此可见：ET模式的效率比LT模式的效率要高很多。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失，这样对编写代码的人要求就比较高。<br>注意：ET模式只支持非阻塞的读写。</p>]]></content>
    
    
    <summary type="html">epoll 水平触发和边缘触发</summary>
    
    
    
    <category term="linux" scheme="https://mirsery.github.io/categories/linux/"/>
    
    
    <category term="io 通讯" scheme="https://mirsery.github.io/tags/io-%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>AVL树二</title>
    <link href="https://mirsery.github.io/2023/10/24/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%E6%A0%91%E4%BA%8C/"/>
    <id>https://mirsery.github.io/2023/10/24/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%E6%A0%91%E4%BA%8C/</id>
    <published>2023-10-24T01:06:02.000Z</published>
    <updated>2023-10-24T01:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E8%8A%82%E7%82%B9node%E7%9A%84%E5%AE%9A%E4%B9%89">节点Node的定义</a></li><li><a href="#avl-%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89">AVL 树的结构定义</a></li><li><a href="#avl%E6%A0%91%E7%9A%84%E6%96%B9%E6%B3%95">AVL树的方法</a></li></ul><!-- tocstop --><h2><span id="节点node的定义">节点Node的定义</span></h2><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;    <span class="keyword">public</span> K key;       <span class="comment">// 节点key值</span>    <span class="keyword">public</span> V value;     <span class="comment">// 节点值</span>    <span class="keyword">public</span> Node left;   <span class="comment">// 左子树节点</span>    <span class="keyword">public</span> Node right;  <span class="comment">// 右子树节点</span>    <span class="keyword">public</span> <span class="type">int</span> height;  <span class="comment">// 高度</span>    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;        <span class="built_in">this</span>.key = key;        <span class="built_in">this</span>.value = value;        <span class="built_in">this</span>.height = <span class="number">1</span>;        left = <span class="literal">null</span>;        right = <span class="literal">null</span>;    &#125;&#125;</code></pre><h2><span id="avl-树的结构定义">AVL 树的结构定义</span></h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVLTree</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;        <span class="keyword">private</span> Node root;  <span class="comment">// 根节点 </span>    <span class="keyword">private</span> <span class="type">int</span> size;   <span class="comment">// 节点数</span>    <span class="keyword">public</span> <span class="title function_">AVLTree</span><span class="params">()</span> &#123;        root = <span class="literal">null</span>;        size = <span class="number">0</span>;    &#125;    ...&#125;</code></pre><h2><span id="avl树的方法">AVL树的方法</span></h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 获取节点高度</span><span class="comment"> **/</span><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(Node node)</span> &#123;    <span class="keyword">if</span> (node==<span class="literal">null</span>) &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="keyword">return</span> node.height;&#125;<span class="comment">/**</span><span class="comment"> * 计算平衡因子</span><span class="comment"> **/</span><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(Node node)</span> &#123;    <span class="keyword">if</span> (node==<span class="literal">null</span>) &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="keyword">return</span> getHeight(node.left) - getHeight(node.right);&#125;<span class="comment">/* 二分搜索树</span><span class="comment"> *</span><span class="comment"> * 二分搜索树 所有节点满足，左节点小于根节点，右节点大于根节点</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBST</span><span class="params">()</span> &#123;    ArrayList&lt;K&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    inOrder(root, keys);    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; keys.size(); i++) &#123;        <span class="keyword">if</span> (keys.get(i - <span class="number">1</span>).compareTo(keys.get(i)) &gt; <span class="number">0</span>) &#123;            <span class="keyword">return</span> <span class="literal">false</span>;        &#125;    &#125;    <span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(Node node, ArrayList&lt;K&gt; keys)</span> &#123;    <span class="keyword">if</span> (node==<span class="literal">null</span>) &#123;        <span class="keyword">return</span>;    &#125;    inOrder(node.left, keys);    keys.add(node.key);    inOrder(node.right, keys);&#125;<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">()</span>&#123;    <span class="keyword">return</span> isBalanced(root);&#125;<span class="comment">/*</span><span class="comment"> * 判断Node为根的二叉树是否平衡 即平衡因子绝对值小于2</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(Node node)</span> &#123;    <span class="keyword">if</span> (node==<span class="literal">null</span>) &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(node);    <span class="keyword">if</span> (Math.abs(balanceFactor) &gt; <span class="number">1</span>) &#123;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="keyword">return</span> isBalanced(node.left) &amp;&amp; isBalanced(node.right);&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(K key, V value)</span> &#123;    root = add(root, key, value);&#125;<span class="keyword">private</span> Node <span class="title function_">add</span><span class="params">(Node node, K key, V value)</span> &#123;    <span class="keyword">if</span> (node==<span class="literal">null</span>) &#123;        size++;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);    &#125;    <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>) &#123;        node.left = add(node.left, key, value);    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>) &#123;        node.right = add(node.right, key, value);    &#125; <span class="keyword">else</span> &#123;        node.value = value;    &#125;    node.height = <span class="number">1</span> + Math.max(getHeight(node.left), getHeight(node.right));    <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(node);    <span class="comment">/* 判断所属情况是LL LR RL RR等情形 */</span>    <span class="comment">// LL 整体顺时针旋转</span>    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>) &#123;        <span class="keyword">return</span> rightRotate(node);    &#125;    <span class="comment">//RR 整体逆时针旋转</span>    <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>) &#123;        <span class="keyword">return</span> leftRotate(node);    &#125;    <span class="comment">//LR 左子树左旋转 转化成 LL，之后整体右旋转</span>    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>) &#123;        node.left = leftRotate(node.left);        <span class="keyword">return</span> rightRotate(node);    &#125;    <span class="comment">//RL 右子树右旋转转化成 RR ，之后整体左旋转</span>    <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>) &#123;        node.right = rightRotate(node.right);        <span class="keyword">return</span> leftRotate(node);    &#125;    <span class="keyword">return</span> node;&#125;<span class="comment">// 右旋转 顺时针</span><span class="comment">/*</span><span class="comment"> *              y                   x</span><span class="comment"> *             / \                 / \</span><span class="comment"> *            T1  x     -----&gt;    y   T3</span><span class="comment"> *               / \             / \</span><span class="comment"> *              T2  T3          T1 T2</span><span class="comment"> */</span><span class="keyword">private</span> Node <span class="title function_">rightRotate</span><span class="params">(Node y)</span> &#123;    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> y.left;    <span class="type">Node</span> <span class="variable">T3</span> <span class="operator">=</span> x.right;    x.right = y;    y.left = T3;    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="number">1</span>;    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="number">1</span>;    <span class="keyword">return</span> x;&#125;<span class="comment">// 左旋转 逆时针</span><span class="keyword">private</span> Node <span class="title function_">leftRotate</span><span class="params">(Node y)</span> &#123;    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> y.right;    <span class="type">Node</span> <span class="variable">T2</span> <span class="operator">=</span> x.left;    y.right = T2;    x.left = y;    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="number">1</span>;    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="number">1</span>;    <span class="keyword">return</span> x;&#125;<span class="comment">/**</span><span class="comment"> * <span class="doctag">@param</span> node 树根节点</span><span class="comment"> * <span class="doctag">@param</span> key  节点属性</span><span class="comment"> * <span class="doctag">@return</span> key 所在的节点</span><span class="comment"> **/</span><span class="keyword">private</span> Node <span class="title function_">getNode</span><span class="params">(Node node, K key)</span> &#123;    <span class="keyword">if</span> (node==<span class="literal">null</span>) &#123;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;    <span class="keyword">if</span> (key.equals(node.key)) &#123;        <span class="keyword">return</span> node;    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>) &#123;        <span class="keyword">return</span> getNode(node.left, key);    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> getNode(node.right, key);    &#125;&#125;<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(K key)</span> &#123;    <span class="keyword">return</span> getNode(root, key)!=<span class="literal">null</span>;&#125;<span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> getNode(root, key);    <span class="keyword">return</span> node==<span class="literal">null</span> ? <span class="literal">null</span> : node.value;&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(K key, V newVal)</span> &#123;    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> getNode(root, key);    <span class="keyword">if</span> (node==<span class="literal">null</span>) &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(key + <span class="string">&quot; 不存在&quot;</span>);    &#125;    node.value = newVal;&#125;<span class="comment">/**</span><span class="comment"> * 返回node为根的二分搜索树的最小值所在的节点</span><span class="comment"> */</span><span class="keyword">private</span> Node <span class="title function_">minimum</span><span class="params">(Node node)</span> &#123;    <span class="keyword">if</span> (node.left==<span class="literal">null</span>) &#123;        <span class="keyword">return</span> node;    &#125;    <span class="keyword">return</span> minimum(node.left);&#125;<span class="comment">/**</span><span class="comment"> * 删除最小节点</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> Node 返回新树的根节点</span><span class="comment"> **/</span><span class="keyword">private</span> Node <span class="title function_">removeMin</span><span class="params">(Node node)</span> &#123;    <span class="keyword">if</span> (node.left==<span class="literal">null</span>) &#123;        <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.right;        node.right = <span class="literal">null</span>;        size--;        <span class="keyword">return</span> rightNode;    &#125;    node.left = removeMin(node.left);    <span class="keyword">return</span> node;&#125;<span class="keyword">private</span> Node <span class="title function_">remove</span><span class="params">(Node node, K key)</span> &#123;    <span class="keyword">if</span> (node==<span class="literal">null</span>) &#123;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;    Node retNode;    <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>) &#123;        node.left = remove(node.left, key);        retNode = node;    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>) &#123;        node.right = remove(node.right, key);        retNode = node;    &#125; <span class="keyword">else</span> &#123;        <span class="comment">//  1.左子树为空</span>        <span class="keyword">if</span> (node.left==<span class="literal">null</span>) &#123;            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.right;            node.right = <span class="literal">null</span>;            size--;            retNode = rightNode;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right==<span class="literal">null</span>) &#123;            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> node.left;            node.left = <span class="literal">null</span>;            size--;            retNode = leftNode;        &#125; <span class="keyword">else</span> &#123;            <span class="type">Node</span> <span class="variable">successor</span> <span class="operator">=</span> minimum(node.right);            successor.right = remove(node.right, successor.key);            successor.left = node.left;            node.left = node.right = <span class="literal">null</span>;            retNode = successor;        &#125;        <span class="keyword">if</span> (retNode==<span class="literal">null</span>) &#123;            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;        retNode.height = <span class="number">1</span> + Math.max(getHeight(retNode.left), getHeight(retNode.right));        <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(retNode);        <span class="comment">//LL</span>        <span class="keyword">if</span>(balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &gt;= <span class="number">0</span> )&#123;            <span class="keyword">return</span> rightRotate(retNode);        &#125;                <span class="comment">//RR</span>        <span class="keyword">if</span>(balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &lt;= <span class="number">0</span> )&#123;            <span class="keyword">return</span> leftRotate(retNode);        &#125;        <span class="comment">//LR</span>        <span class="keyword">if</span>(balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &lt; <span class="number">0</span>)&#123;            retNode.left = leftRotate(retNode.left);            <span class="keyword">return</span> rightRotate(retNode);        &#125;        <span class="comment">//RL</span>        <span class="keyword">if</span>(balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &gt; <span class="number">0</span>)&#123;            retNode.right = rightRotate(retNode.right);            <span class="keyword">return</span> leftRotate(retNode);        &#125;    &#125;    <span class="keyword">return</span> retNode;&#125;</code></pre>]]></content>
    
    
    <summary type="html">AVL树（Adelson-Velsky and Landis Tree）是计算机科学中最早被发明的自平衡二叉查找树。java实现avl树...</summary>
    
    
    
    <category term="算法和数据结构" scheme="https://mirsery.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://mirsery.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>AVL树(一)</title>
    <link href="https://mirsery.github.io/2023/10/16/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%E6%A0%91%E4%B8%80/"/>
    <id>https://mirsery.github.io/2023/10/16/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%E6%A0%91%E4%B8%80/</id>
    <published>2023-10-16T08:30:53.000Z</published>
    <updated>2023-10-16T08:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91-bstbinary-search-tree">二叉查找树 BST（binary search tree）</a></li><li><a href="#avl%E6%A0%91%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">AVL树时间复杂度</a></li><li><a href="#%E6%A0%91%E7%9A%84%E5%B9%B3%E8%A1%A1">树的平衡</a></li><li><a href="#%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90">平衡因子</a></li><li><a href="#%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC">树的旋转</a></li><li><a href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9">删除节点</a></li></ul><!-- tocstop --><p>AVL树查找、插入和删除在平均和最坏的情况下的时间复杂度均为O(logN),增加和删除元素的操作可能需要借由一次或者多次的树旋转，来实现树结构的重新平衡。</p><h2><span id="二叉查找树-bstbinary-search-tree">二叉查找树 BST（binary search tree）</span></h2><p>也叫二叉排序树 BST （binary sort tree）  </p><ol><li>如果左子树不为空，则左子树上的所有节点均小于根节点的值</li><li>如果右子树不为空，则右子树上的所有节点的值均大于根节点的值</li><li>左、右子树也都是二叉查找树</li></ol><p>对于一个节点分布相对均衡的二叉查找树来说，如果节点的总数为n,则搜索的时间复杂度就是O（log n）和树的深度是一样的。 </p><p><img src="/2023/10/16/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%E6%A0%91%E4%B8%80/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><h2><span id="avl树时间复杂度">AVL树时间复杂度</span></h2><table><thead><tr><th>算法</th><th>平均</th><th>最差</th></tr></thead><tbody><tr><td>空间</td><td>O(n)</td><td>O(n)</td></tr><tr><td>搜索</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>插入</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>删除</td><td>O(log n)</td><td>O(log n)</td></tr></tbody></table><h2><span id="树的平衡">树的平衡</span></h2><p>树的平衡是指对于给定数量的节点，保证树的高度尽可能短的过程。如果可以满足树所有叶子结点都在最后两层上，且倒数第二层是满的，则这棵树是平衡的。如果一个平衡树最后一层叶子结点都在最左边的位置上，则这棵树是左平衡的。</p><h2><span id="平衡因子">平衡因子</span></h2><p>某结点的左子树与右子树的高度(深度)差即为该结点的平衡因子（BF,Balance Factor）。平衡二叉树上所有结点的平衡因子只可能是 -1，0 或 1。一个结点数为n的完全二叉树的高度为 log2（n）    </p><h2><span id="树的旋转">树的旋转</span></h2><pre><code>AVL树的基本操作一般涉及运作在同在不平衡的二叉查找树所引用的同样的算法。但是要进行一次或者多次的AVL旋转。以下是四种不平衡的情况以及对应的处理方式。</code></pre><ul><li>LL 情况<br>根节点平衡因子大于1，且其左子树与右子树的高度差大于等于0<br>处理LL情况，需要将树整体进行右旋转（即对根节点Y进行右旋转,顺时针），效果如下所示:</li></ul><p><img src="/2023/10/16/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%E6%A0%91%E4%B8%80/LL.png"></p><ul><li>RR 情况<br>根节点平衡因子小于-1，且左子树和右子树的高度差小于等于0<br>处理RR情况需要将树整体进行左旋转（即对根节点Y进行左旋转逆时针），效果如图所示:</li></ul><p><img src="/2023/10/16/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%E6%A0%91%E4%B8%80/RR.png"></p><ul><li>LR 情况<br>根节点平衡因子大于1,且左子树和右子树的高度差小于0<br>处理LR情况需要将其左子树进行左旋转 为LL，然后在将整体树进行右旋转，效果如图所示:</li></ul><p><img src="/2023/10/16/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%E6%A0%91%E4%B8%80/LR.png"></p><ul><li>RL 情况<br>根节点平衡因子小于-1，且左子树与右子树的高度差大于0<br>处理RL情况需要将其右子树进行右旋转 为RR，然后再将整体树进行左旋转，效果如图所示：</li></ul><p><img src="/2023/10/16/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%E6%A0%91%E4%B8%80/RL.png"></p><h2><span id="删除节点">删除节点</span></h2><p>从AVL树中删除，可以通过把要删除的节点向下旋转成一个叶子节点，接着直接移除这个叶子节点来完成。因为在旋转成葉子節點期间最多有log n个节点被旋转，而每次AVL旋转耗费固定的时间，所以删除处理在整体上耗费O(logN)</p>]]></content>
    
    
    <summary type="html">AVL树（Adelson-Velsky and Landis Tree）是计算机科学中最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logN)</summary>
    
    
    
    <category term="算法和数据结构" scheme="https://mirsery.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://mirsery.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>tcp协议小记（1）</title>
    <link href="https://mirsery.github.io/2023/01/31/talk/2023/tcp%E5%8D%8F%E8%AE%AE%E5%B0%8F%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://mirsery.github.io/2023/01/31/talk/2023/tcp%E5%8D%8F%E8%AE%AE%E5%B0%8F%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2023-01-31T14:40:03.000Z</published>
    <updated>2024-01-23T04:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#tcp-transmission-control-protocol">TCP (Transmission Control Protocol)</a></li><li><a href="#tcp%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE">TCP窗口协议</a><ul><li><a href="#%E7%AA%97%E5%8F%A3%E7%BC%93%E5%AD%98">窗口缓存</a></li><li><a href="#%E7%BD%91%E5%8D%A1%E7%BC%93%E5%AD%98">网卡缓存</a></li></ul></li><li><a href="#java-%E5%AF%B9%E4%BA%8Etcp%E7%9A%84%E5%AE%9E%E7%8E%B0">Java 对于tcp的实现</a><ul><li><a href="#netty%E5%AE%A3%E7%A7%B0%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D">netty宣称的“零拷贝”</a></li><li><a href="#java-nio">Java NIO</a></li><li><a href="#tcp%E4%BF%9D%E9%9A%9C%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BC%A0%E8%BE%93">tcp保障可靠的传输</a></li></ul></li></ul><!-- tocstop --><h2><span id="tcp-transmission-control-protocol">TCP (Transmission Control Protocol)</span></h2><p>TCP是一种常用的网络传输协议，用于在两个设备之间进行可靠的数据传输。</p><ul><li>面向连接：建立一条可靠的连接，再进行数据传输。</li><li>流量控制：避免发送端数据过多导致接收端缓存溢出。</li><li>拥塞控制：避免网络拥塞导致传输效率降低。</li><li>可靠性保证：确保数据的正确接收，并在必要时进行重传。</li><li>顺序保证：保证数据的接收顺序和发送顺序一致。</li><li>TCP协议是应用层与传输层之间的协议，使用三次握手建立连接，四次挥手关闭连接，保证数据的正确传输。</li></ul><h2><span id="tcp窗口协议">TCP窗口协议</span></h2><p>TCP窗口协议是指TCP协议中的流量控制机制。流量控制的目的是避免发送端数据太快导致接收端缓存区溢出，窗口协议就是实现流量控制的一种方法。每个TCP连接都有一个窗口大小，代表接收端缓存区的大小，发送端每次发送数据前都要查询接收端的窗口大小，确保发送的数据量不超过窗口大小。当接收端的缓存区已满时，接收端可以通过减小窗口大小来限制发送端的数据发送量；当缓存区已经有足够的空间时，接收端可以通过增大窗口大小来鼓励发送端发送数据。这样，窗口协议就实现了发送端和接收端之间的动态平衡，确保了网络资源的有效利用，避免了网络拥塞。对于每个TCP连接，服务端都有一个独立的窗口与该连接相关联。窗口大小是根据接收端的缓存区大小和网络状况动态调整的，因此每个TCP连接的窗口大小都可能不同。这样，窗口协议能够灵活地控制网络流量，确保不同的TCP连接的流量能够得到平衡的分配。</p><p>服务端的每个TCP连接的窗口都有独立的缓存，每个窗口都是独立管理和控制的。这部分缓存是操作系统实现的，由操作系统维护缓存的大小和内容。操作系统在处理TCP数据包时，会把数据包存储在对应的窗口的缓存中，并维护每个窗口的状态。发送端通过窗口协议查询窗口大小来决定数据发送量，接收端通过修改窗口大小来控制流量，操作系统会根据窗口大小来决定接收到的数据包的处理方式。因此，窗口协议的实现是由操作系统和网络协议栈共同完成的，涉及到了操作系统的缓存管理和网络协议栈的数据包处理。</p><p>TCP协议的窗口协议是自动启用的。当两台计算机通过TCP协议建立连接时，窗口协议将自动启用，并在数据传输过程中自动协调流量控制和错误控制。在TCP协议的实现中，窗口协议是一种内置的功能，不需要开发人员显式地启用或配置。所以，在使用TCP协议进行数据传输时，窗口协议是自动启用的。</p><h3><span id="窗口缓存">窗口缓存</span></h3><p>窗口缓存通常存在于内核态。窗口缓存是网络协议栈（内核）实现的一部分，它存储了数据包，并负责在发送端和接收端之间协调数据传输。<br>内核态是操作系统内核运行的状态，它提供了一种抽象的接口来访问和管理系统的硬件资源和管理程序的共享资源。在内核态中，操作系统有较高的权限，可以读取和修改系统内存、访问硬件和驱动程序等。<br>因此，窗口缓存存在于内核态，它可以直接读取和修改内存，以实现数据传输的高效处理。开发人员不需要直接访问窗口缓存，只需要通过高层次的API来发送和接收数据。</p><h3><span id="网卡缓存">网卡缓存</span></h3><p>网卡是与操作系统内核中的网络协议栈相连的硬件，它负责接收来自网络的数据并将数据传输到操作系统内核中。 在接收到数据时，网卡可以将数据缓存在其内部，以等待操作系统内核处理。网卡缓存可以减少系统的网络负载，因为它可以在网卡的缓存中缓存数据，而不是立即将数据传输到操作系统内核中。但是，如果网卡缓存的数据过多，则可能会影响网卡的性能。因此，通常需要在网卡的配置中设置合适的缓存大小，以保证网卡性能的最佳平衡。</p><h2><span id="java-对于tcp的实现">Java 对于tcp的实现</span></h2><p>Java使用的是操作系统的socket来实现TCP协议。 Java的socket编程是在操作系统的socket API的基础上实现的，它提供了一种简单的高层次的API来访问操作系统的socket，而操作系统的socket实现则是基于网络协议栈的。因此，在Java中实现TCP连接时，也是通过操作系统的socket实现的，用户编写的Java代码发出的请求和数据发送均通过操作系统的socket完成。在Java中，TCP协议是通过java.net包中的Socket和ServerSocket类实现的。开发人员可以在Java中通过这些类来编写高层次的网络应用程序，而不用考虑操作系统的底层细节。</p><h3><span id="netty宣称的零拷贝">netty宣称的“零拷贝”</span></h3><p>Netty的”零拷贝”是指在处理网络数据时，Netty避免了将数据从内核空间拷贝到用户空间的操作。这意味着，在从网络读取数据时，Netty可以直接在内核空间读取数据，而无需将数据从内核空间拷贝到用户空间。<br>这样做的好处是：<br>减少了数据在内核空间和用户空间之间的拷贝操作，提高了网络性能<br>避免了用户空间内存的占用，减少了内存压力<br>Netty通过使用Java NIO的特性，如内存映射文件和直接字节缓冲区，来实现零拷贝。</p><blockquote><p>需要注意的是网卡缓存的信息还是需要传输到内核态中的。</p></blockquote><p>Netty是通过使用Java NIO（非阻塞I&#x2F;O）实现来实现零拷贝的。Java NIO提供了通道（Channel）和缓冲区（Buffer）的概念，允许Java程序直接与操作系统的内核空间交互。通道可以直接读取或写入缓冲区，而缓冲区可以存储数据。Netty可以直接使用Java NIO在内核空间和用户空间之间进行数据交换，不需要将内核空间的数据复制到用户空间，从而实现零拷贝。这与其他传统的网络框架的处理方式不同，因为它们通常需要将内核空间的数据复制到用户空间，这样会增加额外的性能开销。所以，Netty在使用Java NIO的基础上实现了零拷贝，这是它实现高性能网络通信的关键原因。Netty中实现零拷贝是通过将底层系统I&#x2F;O读写数据接口和用户空间内存对应连接起来，避免了从内核空间到用户空间的数据拷贝。在Java NIO中，通过使用DirectByteBuffer类型的缓冲区，操作系统会把该缓冲区直接映射到内存，系统读写数据时不需要复制到用户空间的临时缓冲区。这样避免了数据从内核空间到用户空间的复制，减少了内存的拷贝开销，提高了系统性能。<br>Java NIO实现的内核空间和用户空间的数据交换通过Java NIO的Buffer（缓存）机制实现。使用Buffer作为两个空间之间的数据桥梁。数据读取到Buffer，再从Buffer写入到另一个空间。这种方式可以让内核和用户空间的数据在缓存中进行交换，避免频繁的内存复制，提高传输性能。</p><h3><span id="java-nio">Java NIO</span></h3><p>Java NIO中的Buffer（缓存）是Java NIO的核心组件，它用于存储数据。Java NIO提供了多种不同类型的Buffer，如ByteBuffer、CharBuffer、ShortBuffer、IntBuffer等。在Java NIO中，每个Buffer都有一个position（位置）和limit（限制）。position指示下一个要读&#x2F;写的数据的位置，limit指示当前Buffer的数据的最大范围。Java NIO的Buffer是基于内存映射的，可以直接访问内核空间的数据，但Java程序不能直接访问内核空间的数据。通过使用Buffer，内核空间和用户空间的数据可以在缓存中进行交换，而不需要频繁的内存复制。如果在内核空间接收到数据，它可以将数据存储到Buffer中，然后在用户空间读取数据时，可以直接从Buffer中读取数据。同样的，如果要发送数据，它可以先写入到Buffer中，然后在内核空间将数据从Buffer中发送出去。这就是Java NIO实现内核空间和用户空间的数据交换的方式，使用Buffer作为数据桥梁，避免频繁的内存复制，提高传输性能。<br>DirectByteBuffer类型的缓存和内存映射是由Java虚拟机来控制的。Java虚拟机可以通过使用相应的本地方法，直接在内存上进行读写操作，而不需要进行数据的拷贝。使用DirectByteBuffer映射文件并利用通道进行读写操作可以实现高速的文件复制。</p><blockquote><p>但需要注意的是，DirectByteBuffer对系统内存的占用可能较高，因此使用时需谨慎考虑。</p></blockquote><h3><span id="tcp保障可靠的传输">tcp保障可靠的传输</span></h3><ol><li>建立连接：通过三次握手建立连接，保证连接实体真实存在</li><li>序号机制：保证数据是按序、完整到达</li><li>合理分片：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。</li><li>数据校验：TCP报文头有校验和，用于校验报文是否损坏</li><li>超时重传：如果发送一直收不到应答，可能是发送数据丢失，也可能是应答丢失，发送方再等待一段时间之后都会进行重传。</li><li>流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li><li>拥塞控制：网络层拥堵造成的拥塞，包括慢启动，拥塞避免，快速重传三种机制</li></ol>]]></content>
    
    
    <summary type="html">TCP (Transmission Control Protocol)是一种常用的网络传输协议，用于在两个设备之间进行可靠的数据传输...</summary>
    
    
    
    <category term="通讯协议" scheme="https://mirsery.github.io/categories/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="tcp" scheme="https://mirsery.github.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>常用的进程线程查看命令</title>
    <link href="https://mirsery.github.io/2023/01/06/talk/2023/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4/"/>
    <id>https://mirsery.github.io/2023/01/06/talk/2023/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4/</id>
    <published>2023-01-06T02:27:19.000Z</published>
    <updated>2023-01-06T02:27:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E5%8D%A0%E7%94%A8cpu%E6%9C%80%E5%A4%9A%E7%9A%84%E8%BF%9B%E7%A8%8B">查看占用cpu最多的进程</a><ul><li><a href="#%E9%87%87%E7%94%A8-ps-%E5%91%BD%E4%BB%A4">采用 ps 命令</a></li><li><a href="#%E9%87%87%E7%94%A8top%E5%91%BD%E4%BB%A4">采用top命令</a></li></ul></li><li><a href="#%E6%A0%B9%E6%8D%AE%E8%BF%9B%E7%A8%8Bid%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%90%8D">根据进程ID查看服务名</a><ul><li><a href="#ps%E5%91%BD%E4%BB%A4">ps命令</a></li><li><a href="#proc%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2">proc命令查询</a></li></ul></li><li><a href="#%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%8A%B6%E5%86%B5">查看端口的连接状况</a></li></ul><!-- tocstop --><h2><span id="查看占用cpu最多的进程">查看占用cpu最多的进程</span></h2><h3><span id="采用-ps-命令">采用 ps 命令</span></h3><pre><code class="highlight shell">ps H -eo pid,pcpu | sort -nk2 | tail</code></pre><h3><span id="采用top命令">采用top命令</span></h3><pre><code class="highlight shell">top<span class="meta prompt_"># </span><span class="language-bash">键盘按下 Shift + t</span></code></pre><blockquote><p>也可以采用 <strong>htop</strong> 命令进行可视化的查看</p></blockquote><h2><span id="根据进程id查看服务名">根据进程ID查看服务名</span></h2><h3><span id="ps命令">ps命令</span></h3><pre><code class="highlight shell">ps aux | fgrep pid</code></pre><h3><span id="proc命令查询">proc命令查询</span></h3><pre><code class="highlight shell">ll /proc/&#123;pid&#125;</code></pre><h2><span id="查看端口的连接状况">查看端口的连接状况</span></h2><pre><code class="highlight shell">netstat -lap | fgrep &#123;port&#125;</code></pre><pre><code class="highlight shell">lsof -i :&#123;port&#125;</code></pre>]]></content>
    
    
    <summary type="html">常用线程进程查看指令snap code....</summary>
    
    
    
    <category term="shell" scheme="https://mirsery.github.io/categories/shell/"/>
    
    
    <category term="shell" scheme="https://mirsery.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>scoop安装</title>
    <link href="https://mirsery.github.io/2023/01/04/talk/2023/scoop%E5%AE%89%E8%A3%85/"/>
    <id>https://mirsery.github.io/2023/01/04/talk/2023/scoop%E5%AE%89%E8%A3%85/</id>
    <published>2023-01-04T14:40:03.000Z</published>
    <updated>2023-01-04T14:40:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86">基础命令合集</a></li><li><a href="#%E5%8D%B8%E8%BD%BD%E5%91%BD%E4%BB%A4">卸载命令</a></li><li><a href="#%E6%8D%A2%E6%BA%90">换源</a></li><li><a href="#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6">安装软件</a></li><li><a href="#%E6%A3%80%E6%B5%8B%E5%BD%93%E5%89%8D%E5%AE%89%E8%A3%85%E6%98%AF%E5%90%A6%E6%9C%89%E9%97%AE%E9%A2%98">检测当前安装是否有问题</a></li><li><a href="#%E5%88%A9%E7%94%A8aria2%E8%BF%9B%E8%A1%8C%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0">利用aria2进行断点续传</a></li><li><a href="#%E6%89%93%E5%BC%80%E6%9F%90%E4%B8%AAapp%E7%9A%84%E4%B8%BB%E9%A1%B5">打开某个app的主页</a></li><li><a href="#%E6%98%BE%E7%A4%BA%E6%9F%90%E4%B8%AAapp%E7%9A%84%E4%BF%A1%E6%81%AF">显示某个app的信息</a></li></ul><!-- tocstop --><p>mac 有homebrew，linux有yum，apt，apk等等。对于win平台如果高效快捷的管理软件，我们可以使用scoop来管理我们的软件。</p><p>以下是安装命令，在powershell中直接运行如下代码：</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">scoop 安装</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">更改脚本执行策略</span>Set-ExecutionPolicy RemoteSigned -scope CurrentUser;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装命令</span>iwr -useb https://gitee.com/glsnames/scoop-installer/raw/master/bin/install.ps1 | iexscoop config SCOOP_REPO &#x27;https://gitee.com/glsnames/scoop-installer&#x27;scoop update</code></pre><h2><span id="基础命令合集">基础命令合集</span></h2><pre><code class="highlight shell">scoop help #查看帮助scoop help &lt;cmdName&gt; # 具体查看某个命令的帮助scoop install &lt;appName&gt;   # 安装 APPscoop uinstall &lt;app&gt;  # 卸载 APPscoop list  # 列出已安装的 APPscoop search # 搜索 APPscoop status # 检查哪些软件有更新scoop update # 更新 Scoop 自身scoop update appName1 appName2 # 更新某些appscoop update *  # 更新所有 app （前提是需要在apps目录下操作）scoop bucket known #通过此命令列出已知所有 bucket（软件源）scoop bucket add bucketName #添加某个 bucketscoop cache rm &lt;appName&gt; # 移除某个app的缓存</code></pre><h2><span id="卸载命令">卸载命令</span></h2><blockquote><p>很危险，此命令会删除scoop下面的所有软件</p></blockquote><pre><code class="highlight shell">scoop uninstall scoop</code></pre><h2><span id="换源">换源</span></h2><pre><code class="highlight shell">scoop bucket add extras</code></pre><h2><span id="安装软件">安装软件</span></h2><pre><code class="highlight shell">scoop install [appname]</code></pre><h2><span id="检测当前安装是否有问题">检测当前安装是否有问题</span></h2><pre><code class="highlight shell">scoop checkup</code></pre><h2><span id="利用aria2进行断点续传">利用aria2进行断点续传</span></h2><p>首先安装aria2</p><pre><code class="highlight shell">scoop install aria2</code></pre><p>下载其他软件失败后进行断点续传</p><pre><code class="highlight shell">aria2c.exe --input-file=&#x27;&#123;your path&#125;&#x27;</code></pre><p>当提示下载完成之后需要再次运行scoop对应的更新或者安装命令，即可完成app的更新或者安装</p><pre><code class="highlight shell">scoop update &lt;appName&gt;</code></pre><h2><span id="打开某个app的主页">打开某个app的主页</span></h2><pre><code class="highlight shell">scoop home &lt;appName&gt;</code></pre><h2><span id="显示某个app的信息">显示某个app的信息</span></h2><pre><code class="highlight shell">scoop info &lt;appName&gt;</code></pre>]]></content>
    
    
    <summary type="html">让win像linux一样管理软件</summary>
    
    
    
    <category term="软件安装" scheme="https://mirsery.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="win" scheme="https://mirsery.github.io/tags/win/"/>
    
  </entry>
  
  <entry>
    <title>nginx使用中的一点注意事项</title>
    <link href="https://mirsery.github.io/2023/01/03/web/2023/nginx%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E7%82%B9%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://mirsery.github.io/2023/01/03/web/2023/nginx%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E7%82%B9%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-01-03T01:26:04.000Z</published>
    <updated>2023-01-03T01:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#nginx-%E5%BF%BD%E7%95%A5%E8%B5%B7%E5%A7%8B%E4%B8%BA_-%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E8%BD%AC%E5%8F%91">nginx 忽略起始为’_’ 的参数的转发</a></li><li><a href="#nginx%E7%BB%91%E5%AE%9A%E4%B8%BB%E6%9C%BA%E5%A4%B4">nginx绑定主机头</a></li><li><a href="#nginx%E6%8A%A5%E9%94%99accept4-failed-23-too-many-open-files-in-system">nginx报错accept4() failed (23: Too many open files in system)</a></li><li><a href="#nginx%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F">nginx跨域配置(允许跨域)</a></li></ul><!-- tocstop --><h2><span id="nginx-忽略起始为_-的参数的转发">nginx 忽略起始为’_’ 的参数的转发</span></h2><p>nginx的默认配置会忽略’_’的请求头参数的转发需要在配置文件中增加如下配置，才可以实现参数的转发。</p><pre><code class="highlight plaintext">underscores_in_headers on;</code></pre><h2><span id="nginx绑定主机头">nginx绑定主机头</span></h2><pre><code class="highlight plaintext">server &#123;    listen 80 default;    return 404;&#125;</code></pre><h2><span id="nginx报错accept4-failed-23-too-many-open-files-in-system">nginx报错accept4() failed (23: Too many open files in system)</span></h2><ul><li>首先查看系统对打开文件数目的限制</li></ul><pre><code class="highlight shell">ulimit -nulimit -Sn #查看软限制ulimit -Hn #查看硬限制</code></pre><ul><li><p>修改ulimit的限制</p><pre><code class="highlight shell">ulimit -SHn 65535 # /etc/bashrc 文件末尾新增如下内容</code></pre></li><li><p>解除linux系统最大打开文件数量可以修改 Linux 的极限配置文件 ** &#x2F;etc&#x2F;security&#x2F;limits.conf ** 来解决，修改此文件加入</p><pre><code class="highlight shell">soft nofile 100000hard nofile 100000</code></pre></li><li><p>修改nginx.conf配置文件</p></li></ul><pre><code class="highlight shell">worker_processes auto;worker_rlimit_nofile 65535;events &#123;    worker_connections 65535;&#125;</code></pre><h2><span id="nginx跨域配置允许跨域">nginx跨域配置(允许跨域)</span></h2><pre><code class="highlight shell"><span class="meta prompt_">#</span><span class="language-bash">坑：1、<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="literal">true</span> 是不能*  可以 add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="variable">$http_origin</span>;</span>if ($request_method = &#x27;OPTIONS&#x27;) &#123;add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">Custom headers and headers various browsers *should* be OK with but aren<span class="string">&#x27;t</span></span>add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Tell client that this pre-flight info is valid for 20 days</span></span>add_header &#x27;Access-Control-Max-Age&#x27; 1728000;add_header &#x27;Content-Type&#x27; &#x27;text/plain charset=UTF-8&#x27;;add_header &#x27;Content-Length&#x27; 0;return 204;&#125;if ($request_method = &#x27;POST&#x27;) &#123;add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;;add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;;&#125;if ($request_method = &#x27;GET&#x27;) &#123;add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;;add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;;&#125;</code></pre>]]></content>
    
    
    <summary type="html">关于nginx服务器配置反向代理的一些xiaoweenti </summary>
    
    
    
    <category term="nginx" scheme="https://mirsery.github.io/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://mirsery.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>企业微信搭建周报机器人</title>
    <link href="https://mirsery.github.io/2022/11/14/talk/2022/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%90%AD%E5%BB%BA%E5%91%A8%E6%8A%A5%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>https://mirsery.github.io/2022/11/14/talk/2022/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%90%AD%E5%BB%BA%E5%91%A8%E6%8A%A5%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2022-11-14T14:30:40.000Z</published>
    <updated>2022-11-14T14:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%94%B3%E8%AF%B7%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA">申请企业微信机器人</a></li><li><a href="#%E4%BA%86%E8%A7%A3%E7%A7%81%E6%9C%8D%E7%9A%84gitlab%E6%8E%A5%E5%8F%A3">了解私服的gitlab接口</a></li><li><a href="#private-token">PRIVATE-TOKEN</a></li><li><a href="#%E5%BC%80%E5%A7%8B%E7%BC%96%E7%A0%81">开始编码</a></li></ul><!-- tocstop --><p>最近实在是懒得写周报以及一个个去询问同事的工作进度做汇总，故就产生了本项目。本人的思路是希望可以收集最近一周所有项目开发上传代码的Commit记录生成一个周报并且将周报信息发送至企业微信群中。</p><h2><span id="申请企业微信机器人">申请企业微信机器人</span></h2><p>此步骤省略，直接手机企业微信群里面添加企业微信机器人即可，对于我们项目来说只需要拿到机器人对应的webhook。<br>注意： 你需要安全妥善保存好你的webhook不能被第三方所知晓。</p><h2><span id="了解私服的gitlab接口">了解私服的gitlab接口</span></h2><p>对应的Commits类型的接口地址如下：https:&#x2F;&#x2F;{私服host地址}&#x2F;help&#x2F;api&#x2F;commits.md</p><pre><code class="highlight plaintext">GET /projects/:id/repository/commits</code></pre><h2><span id="private-token">PRIVATE-TOKEN</span></h2><p><strong>PRIVATE-TOKEN</strong> 可以在gitlab私服 https:&#x2F;&#x2F;{私服host地址}&#x2F;profile&#x2F;personal_access_tokens 这个页面中生成并配置相应的权限。</p><blockquote><p>保存好你的PRIVATE-TOKEN 字符串</p></blockquote><h2><span id="开始编码">开始编码</span></h2><p>下面是git Commits收集代码</p><pre><code class="highlight java:n">@Servicepublic class GitlabService &#123;    @Value(&quot;$&#123;gitlab.pojects&#125;&quot;)    private String projects; //项目名称数组用;隔开    @Value(&quot;$&#123;gitlab.refName&#125;&quot;)    private String refName;    @Value(&quot;$&#123;gitlab.token&#125;&quot;)    private String gitlabToken; //上面的PRIVATE-TOKEN    private final Logger logger = LoggerFactory.getLogger(GitlabService.class);    public String doAction(String url, Map&lt;String, String&gt; params) throws IOException &#123;        OkHttpClient client = new OkHttpClient().newBuilder()                .build();        Request.Builder reqBuild = new Request.Builder();        HttpUrl.Builder urlBuilder = Objects.requireNonNull(HttpUrl.parse(url))                .newBuilder();        params.keySet().forEach(key -&gt; urlBuilder.addQueryParameter(key, params.get(key)));        reqBuild.url(urlBuilder.build());        reqBuild.addHeader(&quot;PRIVATE-TOKEN&quot;, gitlabToken);        reqBuild.addHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);        reqBuild.method(&quot;GET&quot;, null);        Request request = reqBuild.build();        Response response = client.newCall(request).execute();        return Objects.requireNonNull(response.body()).string();    &#125;    public List&lt;WxDto&gt; getSimpleCommits(String since, String until) &#123;        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();        params.put(&quot;since&quot;, since);        params.put(&quot;until&quot;, until);        params.put(&quot;ref_name&quot;, refName);        List&lt;WxDto&gt; result = new ArrayList&lt;&gt;();        String[] ps = projects.split(&quot;;&quot;);        for (String p : ps) &#123;            try &#123;                WxDto wxDto = new WxDto();                List&lt;SimpleCommit&gt; simpleCommits = new ArrayList&lt;&gt;();                String iid = URLEncoder.encode(p, &quot;utf-8&quot;);                String url =                        &quot;https://&#123;gitlab私服地址&#125;/api/v4/projects/&quot; + iid + &quot;/repository/commits&quot;;                String responseBody = this.doAction(url, params);                List&lt;GitCommit&gt; gitCommits = JSON.parseObject(responseBody,                                                              new TypeReference&lt;List&lt;GitCommit&gt;&gt;() &#123;                                                              &#125;);                assert gitCommits!=null;                for (int i = gitCommits.size() - 1; i &gt;= 0; i--) &#123;                    GitCommit temp = gitCommits.get(i);                    if (temp.getParent_ids().size()==1) &#123;                        SimpleCommit simpleCommit = new SimpleCommit();                        simpleCommit.setAuthor(temp.getCommitter_name());                        simpleCommit.setContent(temp.getMessage());                        simpleCommits.add(simpleCommit);                    &#125;                &#125;                wxDto.setTitle(p);                wxDto.setCommits(simpleCommits);                if (simpleCommits.size() &gt; 0) &#123;                    result.add(wxDto);                &#125;            &#125; catch (Exception e) &#123;                logger.error(e.getMessage());            &#125;        &#125;        return result;    &#125;&#125;</code></pre><pre><code class="highlight java:n">public class WxMarkdown &#123;    private String content;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxObj</span> &#123;    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msgtype</span> <span class="operator">=</span> <span class="string">&quot;markdown&quot;</span>;    <span class="keyword">private</span> WxMarkdown markdown;    <span class="keyword">public</span> String <span class="title function_">getMsgtype</span><span class="params">()</span> &#123;        <span class="keyword">return</span> msgtype;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsgtype</span><span class="params">(String msgtype)</span> &#123;        <span class="built_in">this</span>.msgtype = msgtype;    &#125;    <span class="keyword">public</span> WxMarkdown <span class="title function_">getMarkdown</span><span class="params">()</span> &#123;        <span class="keyword">return</span> markdown;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMarkdown</span><span class="params">(WxMarkdown markdown)</span> &#123;        <span class="built_in">this</span>.markdown = markdown;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="meta">@Repository</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxReporter</span> &#123;<span class="comment">//wx周报发送</span>    <span class="meta">@Value(&quot;$&#123;wxHook&#125;&quot;)</span>    <span class="keyword">private</span> String wxHook;    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(WxReporter.class);    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doReport</span><span class="params">(List&lt;WxDto&gt; wxDto, String sinceTime, String endTime)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">WxObj</span> <span class="variable">wxObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WxObj</span>();            <span class="type">WxMarkdown</span> <span class="variable">wxMarkdown</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WxMarkdown</span>();            <span class="type">StringBuilder</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;# &quot;</span> + sinceTime + <span class="string">&quot;-&quot;</span> + endTime + <span class="string">&quot;周报\n&quot;</span>);            wxDto.forEach(item -&gt; content.append(item.toString()));            wxMarkdown.setContent(content.toString());            wxObj.setMarkdown(wxMarkdown);            <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>().newBuilder()                    .build();            <span class="type">MediaType</span> <span class="variable">mediaType</span> <span class="operator">=</span> MediaType.parse(<span class="string">&quot;application/json&quot;</span>);            <span class="type">RequestBody</span> <span class="variable">body</span> <span class="operator">=</span> RequestBody.create(mediaType, JSON.toJSONString(wxObj));            <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()                    .url(wxHook)                    .method(<span class="string">&quot;POST&quot;</span>, body)                    .addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)                    .build();            client.newCall(request).execute();        &#125; <span class="keyword">catch</span> (IOException e) &#123;            logger.error(e.getMessage());        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">希望可以收集最近一周所有项目开发上传代码的Commit记录生成一个周报并且将周报信息发送至企业微信群中....</summary>
    
    
    
    <category term="talk" scheme="https://mirsery.github.io/categories/talk/"/>
    
    
    <category term="微信" scheme="https://mirsery.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>springboot结合swing</title>
    <link href="https://mirsery.github.io/2022/11/14/java/2022/springboot%E7%BB%93%E5%90%88swing/"/>
    <id>https://mirsery.github.io/2022/11/14/java/2022/springboot%E7%BB%93%E5%90%88swing/</id>
    <published>2022-11-14T14:11:56.000Z</published>
    <updated>2022-11-14T14:11:56.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF">项目背景</a></li><li><a href="#%E9%A1%B9%E7%9B%AEpom%E6%96%87%E4%BB%B6">项目pom文件</a></li><li><a href="#%E4%B8%BB%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0">主窗口函数</a></li></ul><!-- tocstop --><h2><span id="项目背景">项目背景</span></h2><p>公司项目中涉及到硬件的开发，需要做一个检测的工装软件。<br>该软件要求如下：</p><ol><li>界面简单</li><li>业务全自动</li><li>逻辑清晰简单易用</li><li>同时容易部署<br>介于本人的技术栈以及项目的情况，在考虑再三之后决定采用java语言进行相应的开发工具，在图形化中选择了老古董swing，这玩意估计也就是学生时代接触过了。本文主要描述swing的应用。</li></ol><h2><span id="项目pom文件">项目pom文件</span></h2><p>项目采用maven进行架构搭建，去除一些业务相关的包之后pom文件如下所示：</p><pre><code class="highlight xml:n">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.7.5&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.xxx&lt;/groupId&gt;    &lt;artifactId&gt;xxxxxxx&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;xxxxx/name&gt;    &lt;description&gt;xxxxxxx&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>项目采用spring容器管理各个类的创建生成。其中Application中的关键代码如下所示：</p><pre><code class="highlight java:n">SpringApplicationBuilder builder = new SpringApplicationBuilder(XXXXXApplication.class);ApplicationContext context = builder.headless(false).web(WebApplicationType.NONE).run(args);//该项目不是web项目MainFrame mainFrame = context.getBean(MainFrame.class);     //MainFrame入口文件mainFrame.init(); //绘制窗口</code></pre><h2><span id="主窗口函数">主窗口函数</span></h2><pre><code class="highlight java"><span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;    <span class="meta">@Resource</span>    <span class="keyword">private</span> TitleJPanel titleJPanel;    <span class="comment">//标题JPanel</span>    <span class="meta">@Resource</span>    <span class="keyword">private</span> BodyJPanel bodyJPanel;    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initChildComponent</span><span class="params">()</span> &#123;        titleJPanel.init();        bodyJPanel.init();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.initChildComponent();        <span class="built_in">this</span>.setSize(<span class="number">1920</span>, <span class="number">1080</span>);        <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    <span class="comment">//关闭按钮</span>        <span class="built_in">this</span>.setLocation(<span class="number">800</span>, <span class="number">200</span>);        <span class="built_in">this</span>.setResizable(<span class="literal">true</span>);        <span class="built_in">this</span>.setTitle(<span class="string">&quot;xxxxx&quot;</span>);        <span class="built_in">this</span>.setLayout(<span class="literal">null</span>);        <span class="built_in">this</span>.setResizable(<span class="literal">false</span>);        titleJPanel.setBorder(<span class="keyword">new</span> <span class="title class_">LineBorder</span>(Color.DARK_GRAY,<span class="number">2</span>));        titleJPanel.setBounds(<span class="number">10</span>, <span class="number">10</span>, <span class="number">1890</span>, <span class="number">200</span>);        bodyJPanel.setBorder(<span class="keyword">new</span> <span class="title class_">LineBorder</span>(Color.DARK_GRAY,<span class="number">2</span>));        bodyJPanel.setBounds(<span class="number">10</span>, <span class="number">250</span>, <span class="number">1890</span>, <span class="number">760</span>);        <span class="built_in">this</span>.getContentPane().add(titleJPanel);        <span class="built_in">this</span>.getContentPane().add(bodyJPanel);        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);    &#125;&#125;</code></pre><pre><code class="highlight java:n">@Componentpublic class BodyJPanel extends JPanel &#123;    private JPanel left;    @Resource    private ComJPanel comJPanel;    @Resource    private QsNoCheckin qsNoCheckin;    @Resource    private RightJPanel rightJPanel;    public BodyJPanel() &#123;        //配置body画板上组件的字体        FontUIResource fontRes = new FontUIResource(new Font(&quot;alias&quot;, Font.PLAIN, 30));        for (Enumeration&lt;Object&gt; keys = UIManager.getDefaults().keys();             keys.hasMoreElements(); ) &#123;            Object key = keys.nextElement();            Object value = UIManager.get(key);            if (value instanceof FontUIResource) &#123;                UIManager.put(key, fontRes);            &#125;        &#125;    &#125;    public void init() &#123;        GridLayout gridLayout = new GridLayout(1,2);        this.setLayout(gridLayout);//设置布局方式        FlowLayout flowLayout = new FlowLayout(FlowLayout.LEFT,5,10);        left = new JPanel();        left.setLayout(flowLayout);        left.add(comJPanel);        left.add(qsNoCheckin);        this.add(left);        this.add(rightJPanel);    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">在考虑再三之后决定采用java语言进行相应的开发工具，在图形化中选择了老古董swing，这玩意估计也就是学生时代接触过了。本文主要描述swing的应用...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://mirsery.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ECAM22.110.SB咖啡机的除垢</title>
    <link href="https://mirsery.github.io/2022/11/09/talk/2022/ECAM22-110-SB%E5%92%96%E5%95%A1%E6%9C%BA%E7%9A%84%E9%99%A4%E5%9E%A2/"/>
    <id>https://mirsery.github.io/2022/11/09/talk/2022/ECAM22-110-SB%E5%92%96%E5%95%A1%E6%9C%BA%E7%9A%84%E9%99%A4%E5%9E%A2/</id>
    <published>2022-11-09T05:40:58.000Z</published>
    <updated>2022-11-09T05:40:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>家中的全自动咖啡机用了也有段时间了，最近中间的指示灯开始闪来闪去，如下图所示：<br><img src="/2022/11/09/talk/2022/ECAM22-110-SB%E5%92%96%E5%95%A1%E6%9C%BA%E7%9A%84%E9%99%A4%E5%9E%A2/1.png"><br>这种情况就表示咖啡机需要进行除垢了。购买说明书中指定的除垢剂，按照说明书进行除垢操作。</p><p>接下来是比较坑的部分，除垢的过程中不能中途停止，除垢的水一定要多，一定要多一定要多。一旦中途被打断，操作不当则必须重新开始才能进行。说明书中有不正确的地方，就是第一次30min的除菌之后，再次用水冲洗时，需要冲洗2水箱水，第一次冲洗的是咖啡口；第二次是清洗的奶泡口。</p><p>三次加水均需超过max水位线。</p>]]></content>
    
    
    <summary type="html">记录一次咖啡机的除垢过程....</summary>
    
    
    
    <category term="生活" scheme="https://mirsery.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="杂谈" scheme="https://mirsery.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>lottie动效的使用</title>
    <link href="https://mirsery.github.io/2022/09/05/%E5%89%8D%E7%AB%AF/lottie%E5%8A%A8%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://mirsery.github.io/2022/09/05/%E5%89%8D%E7%AB%AF/lottie%E5%8A%A8%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-09-05T08:33:21.000Z</published>
    <updated>2022-09-05T08:33:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#ae%E4%B8%8A%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85">AE上插件的安装</a></li><li><a href="#web%E7%AB%AF%E4%BD%BF%E7%94%A8">web端使用</a></li><li><a href="#%E7%AE%80%E5%8D%95%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D">简单功能介绍</a></li></ul><!-- tocstop --><h2><span id="ae上插件的安装">AE上插件的安装</span></h2><p>AE需要安装<strong>bodymovin插件</strong></p><p><strong>BodyMovin</strong>插件可以将AE源文件导出为json。</p><ul><li><p>下载 ZXP 安装程序<br><a href="http://aescripts.com/learn/zxp-installer/">点击下载ZXP</a></p></li><li><p>下载最新的bodymovin扩展</p></li></ul><p><a href="https://github.com/airbnb/lottie-web/tree/master/build/extension">下载最新的扩展文件</a></p><ul><li>打开ZXP安装程序并选择bodymovin扩展安装</li></ul><h2><span id="web端使用">web端使用</span></h2><p>安装<strong>lottie-web</strong></p><pre><code class="highlight json">npm install lottie-web</code></pre><p>下面是示例代码:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">template</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;height:100%;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bodymovin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="keyword">import</span> lottie <span class="keyword">from</span> <span class="string">&#x27;lottie-web&#x27;</span></span><span class="language-javascript"></span><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&quot;AnimationComponent&quot;</span>,</span><span class="language-javascript">  <span class="attr">methods</span>:&#123;</span><span class="language-javascript">    <span class="title function_">loadAnimation</span>(<span class="params"></span>)&#123;</span><span class="language-javascript">      <span class="keyword">let</span> animData = &#123;</span><span class="language-javascript">        <span class="attr">wrapper</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;bodymovin&#x27;</span>),</span><span class="language-javascript">        <span class="attr">animType</span>: <span class="string">&#x27;html&#x27;</span>,</span><span class="language-javascript">        <span class="attr">loop</span>: <span class="literal">false</span>,</span><span class="language-javascript">        <span class="attr">prerender</span>: <span class="literal">true</span>,</span><span class="language-javascript">        <span class="attr">autoplay</span>: <span class="literal">true</span>,</span><span class="language-javascript">        <span class="attr">path</span>: <span class="string">&#x27;static/data.json&#x27;</span>,</span><span class="language-javascript">      &#125;;</span><span class="language-javascript">      <span class="keyword">let</span> lottiePlayer = lottie.<span class="title function_">loadAnimation</span>(animData);</span><span class="language-javascript">      <span class="keyword">let</span> temp = <span class="number">1</span>;</span><span class="language-javascript">      lottiePlayer.<span class="title function_">addEventListener</span>(<span class="string">&quot;complete&quot;</span>,<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;动画完成&quot;</span>)</span><span class="language-javascript">        <span class="comment">// lottiePlayer.playSegments([158,226], true)</span></span><span class="language-javascript">        <span class="keyword">if</span>(temp &gt; <span class="number">0</span>)&#123;</span><span class="language-javascript">          lottiePlayer.<span class="title function_">playSegments</span>([<span class="number">158</span>,<span class="number">226</span>], <span class="literal">true</span>)</span><span class="language-javascript">        &#125;<span class="keyword">else</span>&#123;</span><span class="language-javascript">          lottiePlayer.<span class="title function_">playSegments</span>([<span class="number">226</span>,<span class="number">158</span>], <span class="literal">true</span>)</span><span class="language-javascript">        &#125;</span><span class="language-javascript"></span><span class="language-javascript">        temp = -<span class="number">1</span> * temp;</span><span class="language-javascript">      &#125;)</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">loadAnimation</span>();</span><span class="language-javascript">  &#125;</span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></code></pre><h2><span id="简单功能介绍">简单功能介绍</span></h2><ul><li><p>lottiePlayer.play()：播放，从当前帧开始播放</p></li><li><p>lottiePlayer.stop()：停止，并回到第0帧</p></li><li><p>lottiePlayer.pause()：暂停，并保持当前帧</p></li><li><p>lottiePlayer.goToAndStop(value, isFrame)：跳到某个时刻&#x2F;帧并停止</p></li><li><p>isFrame（可省略，默认false：毫秒；true：帧）指明value的单位是毫秒还是帧</p></li><li><p>lottiePlayer.goToAndPlay(value, isFrame)：跳到某个时刻&#x2F;帧并播放</p></li><li><p>lottiePlayer.goToAndPlay(value, isFrame)：跳到某个时刻&#x2F;帧并播放</p></li><li><p>lottiePlayer.goToAndStop(30, true)     &#x2F;&#x2F; 跳转到第30帧并停止</p></li><li><p>lottiePlayer.goToAndPlay(300)          &#x2F;&#x2F; 跳转到第300毫秒并播放</p></li><li><p>lottiePlayer.playSegments(arr, forceFlag)：以帧为单位，播放指定片段</p><blockquote><p>arr可以包含两个数字或者两个数字组成的数组，forceFlag表示是否立即强制播放该片段</p></blockquote></li><li><p>lottiePlayer.playSegments([10,20], false)          &#x2F;&#x2F; 播放完之前的片段，播放10-20帧</p></li><li><p>lottiePlayer.playSegments([[0,5],[10,18]], true)   &#x2F;&#x2F; 直接播放0-5帧和10-18帧</p></li><li><p>lottiePlayer.setSpeed(speed)：设置播放速度，speed为1表示正常速度</p></li><li><p>lottiePlayer.setDirection(direction)： 设置播放方向，1表示正向播放，-1表示反向播放</p></li><li><p>lottiePlayer.destroy()： 删除该动画，移除相应的元素标签等。</p></li></ul>]]></content>
    
    
    <summary type="html">Lottie 从UI动画场景出发解决矢量动画渲染的问题，使用 AE Script SDK 来导出 AE 工程。</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="动画" scheme="https://mirsery.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>

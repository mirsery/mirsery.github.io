<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mirsery</title>
  
  <subtitle>兴趣使然博客</subtitle>
  <link href="https://mirsery.github.io/atom.xml" rel="self"/>
  
  <link href="https://mirsery.github.io/"/>
  <updated>2022-11-14T14:30:40.000Z</updated>
  <id>https://mirsery.github.io/</id>
  
  <author>
    <name>mirsery</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>企业微信搭建周报机器人</title>
    <link href="https://mirsery.github.io/2022/11/14/talk/2022/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%90%AD%E5%BB%BA%E5%91%A8%E6%8A%A5%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>https://mirsery.github.io/2022/11/14/talk/2022/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%90%AD%E5%BB%BA%E5%91%A8%E6%8A%A5%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2022-11-14T14:30:40.000Z</published>
    <updated>2022-11-14T14:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#---------">申请企业微信机器人</a></li><li><a href="#-----gitlab--">了解私服的gitlab接口</a></li><li><a href="#private-token-">PRIVATE-TOKEN*</a></li><li><a href="#----">开始编码</a></li></ul><!-- tocstop --><p>最近实在是懒得写周报以及一个个去询问同事的工作进度做汇总，故就产生了本项目。本人的思路是希望可以收集最近一周所有项目开发上传代码的Commit记录生成一个周报并且将周报信息发送至企业微信群中。</p><h2 id="申请企业微信机器人"><a href="#申请企业微信机器人" class="headerlink" title="申请企业微信机器人"></a>申请企业微信机器人</h2><p>此步骤省略，直接手机企业微信群里面添加企业微信机器人即可，对于我们项目来说只需要拿到机器人对应的webhook。<br>注意： 你需要安全妥善保存好你的webhook不能被第三方所知晓。</p><h2 id="了解私服的gitlab接口"><a href="#了解私服的gitlab接口" class="headerlink" title="了解私服的gitlab接口"></a>了解私服的gitlab接口</h2><p>对应的Commits类型的接口地址如下：https://{私服host地址}/help/api/commits.md</p><pre><code class="highlight plaintext">GET /projects/:id/repository/commits</code></pre><h2 id="PRIVATE-TOKEN"><a href="#PRIVATE-TOKEN" class="headerlink" title="PRIVATE-TOKEN*"></a>PRIVATE-TOKEN*</h2><p><strong>PRIVATE-TOKEN</strong> 可以在gitlab私服 https://{私服host地址}/profile/personal_access_tokens 这个页面中生成并配置相应的权限。</p><blockquote><p>保存好你的PRIVATE-TOKEN 字符串</p></blockquote><h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><p>下面是git Commits收集代码</p><pre><code class="highlight java:n">@Servicepublic class GitlabService &#123;    @Value(&quot;$&#123;gitlab.pojects&#125;&quot;)    private String projects; //项目名称数组用;隔开    @Value(&quot;$&#123;gitlab.refName&#125;&quot;)    private String refName;    @Value(&quot;$&#123;gitlab.token&#125;&quot;)    private String gitlabToken; //上面的PRIVATE-TOKEN    private final Logger logger = LoggerFactory.getLogger(GitlabService.class);    public String doAction(String url, Map&lt;String, String&gt; params) throws IOException &#123;        OkHttpClient client = new OkHttpClient().newBuilder()                .build();        Request.Builder reqBuild = new Request.Builder();        HttpUrl.Builder urlBuilder = Objects.requireNonNull(HttpUrl.parse(url))                .newBuilder();        params.keySet().forEach(key -&gt; urlBuilder.addQueryParameter(key, params.get(key)));        reqBuild.url(urlBuilder.build());        reqBuild.addHeader(&quot;PRIVATE-TOKEN&quot;, gitlabToken);        reqBuild.addHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);        reqBuild.method(&quot;GET&quot;, null);        Request request = reqBuild.build();        Response response = client.newCall(request).execute();        return Objects.requireNonNull(response.body()).string();    &#125;    public List&lt;WxDto&gt; getSimpleCommits(String since, String until) &#123;        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();        params.put(&quot;since&quot;, since);        params.put(&quot;until&quot;, until);        params.put(&quot;ref_name&quot;, refName);        List&lt;WxDto&gt; result = new ArrayList&lt;&gt;();        String[] ps = projects.split(&quot;;&quot;);        for (String p : ps) &#123;            try &#123;                WxDto wxDto = new WxDto();                List&lt;SimpleCommit&gt; simpleCommits = new ArrayList&lt;&gt;();                String iid = URLEncoder.encode(p, &quot;utf-8&quot;);                String url =                        &quot;https://&#123;gitlab私服地址&#125;/api/v4/projects/&quot; + iid + &quot;/repository/commits&quot;;                String responseBody = this.doAction(url, params);                List&lt;GitCommit&gt; gitCommits = JSON.parseObject(responseBody,                                                              new TypeReference&lt;List&lt;GitCommit&gt;&gt;() &#123;                                                              &#125;);                assert gitCommits!=null;                for (int i = gitCommits.size() - 1; i &gt;= 0; i--) &#123;                    GitCommit temp = gitCommits.get(i);                    if (temp.getParent_ids().size()==1) &#123;                        SimpleCommit simpleCommit = new SimpleCommit();                        simpleCommit.setAuthor(temp.getCommitter_name());                        simpleCommit.setContent(temp.getMessage());                        simpleCommits.add(simpleCommit);                    &#125;                &#125;                wxDto.setTitle(p);                wxDto.setCommits(simpleCommits);                if (simpleCommits.size() &gt; 0) &#123;                    result.add(wxDto);                &#125;            &#125; catch (Exception e) &#123;                logger.error(e.getMessage());            &#125;        &#125;        return result;    &#125;&#125;</code></pre><pre><code class="highlight java:n">public class WxMarkdown &#123;    private String content;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WxObj</span> </span>&#123;    <span class="keyword">private</span> String msgtype = <span class="string">&quot;markdown&quot;</span>;    <span class="keyword">private</span> WxMarkdown markdown;    <span class="function"><span class="keyword">public</span> String <span class="title">getMsgtype</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> msgtype;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgtype</span><span class="params">(String msgtype)</span> </span>&#123;        <span class="keyword">this</span>.msgtype = msgtype;    &#125;    <span class="function"><span class="keyword">public</span> WxMarkdown <span class="title">getMarkdown</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> markdown;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMarkdown</span><span class="params">(WxMarkdown markdown)</span> </span>&#123;        <span class="keyword">this</span>.markdown = markdown;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="meta">@Repository</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WxReporter</span> </span>&#123;<span class="comment">//wx周报发送</span>    <span class="meta">@Value(&quot;$&#123;wxHook&#125;&quot;)</span>    <span class="keyword">private</span> String wxHook;    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WxReporter.class);    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReport</span><span class="params">(List&lt;WxDto&gt; wxDto, String sinceTime, String endTime)</span> </span>&#123;        <span class="keyword">try</span> &#123;            WxObj wxObj = <span class="keyword">new</span> WxObj();            WxMarkdown wxMarkdown = <span class="keyword">new</span> WxMarkdown();            StringBuilder content = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;# &quot;</span> + sinceTime + <span class="string">&quot;-&quot;</span> + endTime + <span class="string">&quot;周报\n&quot;</span>);            wxDto.forEach(item -&gt; content.append(item.toString()));            wxMarkdown.setContent(content.toString());            wxObj.setMarkdown(wxMarkdown);            OkHttpClient client = <span class="keyword">new</span> OkHttpClient().newBuilder()                    .build();            MediaType mediaType = MediaType.parse(<span class="string">&quot;application/json&quot;</span>);            RequestBody body = RequestBody.create(mediaType, JSON.toJSONString(wxObj));            Request request = <span class="keyword">new</span> Request.Builder()                    .url(wxHook)                    .method(<span class="string">&quot;POST&quot;</span>, body)                    .addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)                    .build();            client.newCall(request).execute();        &#125; <span class="keyword">catch</span> (IOException e) &#123;            logger.error(e.getMessage());        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">希望可以收集最近一周所有项目开发上传代码的Commit记录生成一个周报并且将周报信息发送至企业微信群中....</summary>
    
    
    
    <category term="talk" scheme="https://mirsery.github.io/categories/talk/"/>
    
    
    <category term="微信" scheme="https://mirsery.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>springboot结合swing</title>
    <link href="https://mirsery.github.io/2022/11/14/java/2022/springboot%E7%BB%93%E5%90%88swing/"/>
    <id>https://mirsery.github.io/2022/11/14/java/2022/springboot%E7%BB%93%E5%90%88swing/</id>
    <published>2022-11-14T14:11:56.000Z</published>
    <updated>2022-11-14T14:11:56.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----">项目背景</a></li><li><a href="#--pom--">项目pom文件</a></li><li><a href="#-----">主窗口函数</a></li></ul><!-- tocstop --><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>公司项目中涉及到硬件的开发，需要做一个检测的工装软件。<br>该软件要求如下：</p><ol><li>界面简单</li><li>业务全自动</li><li>逻辑清晰简单易用</li><li>同时容易部署<br>介于本人的技术栈以及项目的情况，在考虑再三之后决定采用java语言进行相应的开发工具，在图形化中选择了老古董swing，这玩意估计也就是学生时代接触过了。本文主要描述swing的应用。</li></ol><h2 id="项目pom文件"><a href="#项目pom文件" class="headerlink" title="项目pom文件"></a>项目pom文件</h2><p>项目采用maven进行架构搭建，去除一些业务相关的包之后pom文件如下所示：</p><pre><code class="highlight xml:n">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.7.5&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.xxx&lt;/groupId&gt;    &lt;artifactId&gt;xxxxxxx&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;xxxxx/name&gt;    &lt;description&gt;xxxxxxx&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>项目采用spring容器管理各个类的创建生成。其中Application中的关键代码如下所示：</p><pre><code class="highlight java:n">SpringApplicationBuilder builder = new SpringApplicationBuilder(XXXXXApplication.class);ApplicationContext context = builder.headless(false).web(WebApplicationType.NONE).run(args);//该项目不是web项目MainFrame mainFrame = context.getBean(MainFrame.class);     //MainFrame入口文件mainFrame.init(); //绘制窗口</code></pre><h2 id="主窗口函数"><a href="#主窗口函数" class="headerlink" title="主窗口函数"></a>主窗口函数</h2><pre><code class="highlight java"><span class="meta">@Component</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;    <span class="meta">@Resource</span>    <span class="keyword">private</span> TitleJPanel titleJPanel;    <span class="comment">//标题JPanel</span>    <span class="meta">@Resource</span>    <span class="keyword">private</span> BodyJPanel bodyJPanel;    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initChildComponent</span><span class="params">()</span> </span>&#123;        titleJPanel.init();        bodyJPanel.init();    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;        <span class="keyword">this</span>.initChildComponent();        <span class="keyword">this</span>.setSize(<span class="number">1920</span>, <span class="number">1080</span>);        <span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    <span class="comment">//关闭按钮</span>        <span class="keyword">this</span>.setLocation(<span class="number">800</span>, <span class="number">200</span>);        <span class="keyword">this</span>.setResizable(<span class="keyword">true</span>);        <span class="keyword">this</span>.setTitle(<span class="string">&quot;xxxxx&quot;</span>);        <span class="keyword">this</span>.setLayout(<span class="keyword">null</span>);        <span class="keyword">this</span>.setResizable(<span class="keyword">false</span>);        titleJPanel.setBorder(<span class="keyword">new</span> LineBorder(Color.DARK_GRAY,<span class="number">2</span>));        titleJPanel.setBounds(<span class="number">10</span>, <span class="number">10</span>, <span class="number">1890</span>, <span class="number">200</span>);        bodyJPanel.setBorder(<span class="keyword">new</span> LineBorder(Color.DARK_GRAY,<span class="number">2</span>));        bodyJPanel.setBounds(<span class="number">10</span>, <span class="number">250</span>, <span class="number">1890</span>, <span class="number">760</span>);        <span class="keyword">this</span>.getContentPane().add(titleJPanel);        <span class="keyword">this</span>.getContentPane().add(bodyJPanel);        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);    &#125;&#125;</code></pre><pre><code class="highlight java:n">@Componentpublic class BodyJPanel extends JPanel &#123;    private JPanel left;    @Resource    private ComJPanel comJPanel;    @Resource    private QsNoCheckin qsNoCheckin;    @Resource    private RightJPanel rightJPanel;    public BodyJPanel() &#123;        //配置body画板上组件的字体        FontUIResource fontRes = new FontUIResource(new Font(&quot;alias&quot;, Font.PLAIN, 30));        for (Enumeration&lt;Object&gt; keys = UIManager.getDefaults().keys();             keys.hasMoreElements(); ) &#123;            Object key = keys.nextElement();            Object value = UIManager.get(key);            if (value instanceof FontUIResource) &#123;                UIManager.put(key, fontRes);            &#125;        &#125;    &#125;    public void init() &#123;        GridLayout gridLayout = new GridLayout(1,2);        this.setLayout(gridLayout);//设置布局方式        FlowLayout flowLayout = new FlowLayout(FlowLayout.LEFT,5,10);        left = new JPanel();        left.setLayout(flowLayout);        left.add(comJPanel);        left.add(qsNoCheckin);        this.add(left);        this.add(rightJPanel);    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">在考虑再三之后决定采用java语言进行相应的开发工具，在图形化中选择了老古董swing，这玩意估计也就是学生时代接触过了。本文主要描述swing的应用...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://mirsery.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ECAM22.110.SB咖啡机的除垢</title>
    <link href="https://mirsery.github.io/2022/11/09/talk/2022/ECAM22-110-SB%E5%92%96%E5%95%A1%E6%9C%BA%E7%9A%84%E9%99%A4%E5%9E%A2/"/>
    <id>https://mirsery.github.io/2022/11/09/talk/2022/ECAM22-110-SB%E5%92%96%E5%95%A1%E6%9C%BA%E7%9A%84%E9%99%A4%E5%9E%A2/</id>
    <published>2022-11-09T05:40:58.000Z</published>
    <updated>2022-11-09T05:40:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>家中的全自动咖啡机用了也有段时间了，最近中间的指示灯开始闪来闪去，如下图所示：<br><img src="/1.png"><br>这种情况就表示咖啡机需要进行除垢了。购买说明书中指定的除垢剂，按照说明书进行除垢操作。</p><p>接下来是比较坑的部分，除垢的过程中不能中途停止，除垢的水一定要多，一定要多一定要多。一旦中途被打断，操作不当则必须重新开始才能进行。说明书中有不正确的地方，就是第一次30min的除菌之后，再次用水冲洗时，需要冲洗2水箱水，第一次冲洗的是咖啡口；第二次是清洗的奶泡口。</p><p>三次加水均需超过max水位线。</p>]]></content>
    
    
    <summary type="html">记录一次咖啡机的除垢过程....</summary>
    
    
    
    <category term="生活" scheme="https://mirsery.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="杂谈" scheme="https://mirsery.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>lottie动效的使用</title>
    <link href="https://mirsery.github.io/2022/09/05/%E5%89%8D%E7%AB%AF/lottie%E5%8A%A8%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://mirsery.github.io/2022/09/05/%E5%89%8D%E7%AB%AF/lottie%E5%8A%A8%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-09-05T08:33:21.000Z</published>
    <updated>2022-09-05T08:33:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#ae------">AE上插件的安装</a></li><li><a href="#web---">web端使用</a></li><li><a href="#------">简单功能介绍</a></li></ul><!-- tocstop --><h2 id="AE上插件的安装"><a href="#AE上插件的安装" class="headerlink" title="AE上插件的安装"></a>AE上插件的安装</h2><p>AE需要安装<strong>bodymovin插件</strong></p><p><strong>BodyMovin</strong>插件可以将AE源文件导出为json。</p><ul><li><p>下载 ZXP 安装程序<br><a href="http://aescripts.com/learn/zxp-installer/">点击下载ZXP</a></p></li><li><p>下载最新的bodymovin扩展</p></li></ul><p><a href="https://github.com/airbnb/lottie-web/tree/master/build/extension">下载最新的扩展文件</a></p><ul><li>打开ZXP安装程序并选择bodymovin扩展安装</li></ul><h2 id="web端使用"><a href="#web端使用" class="headerlink" title="web端使用"></a>web端使用</h2><p>安装<strong>lottie-web</strong></p><pre><code class="highlight json">npm install lottie-web</code></pre><p>下面是示例代码:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">template</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;height:100%;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bodymovin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span><span class="javascript"><span class="keyword">import</span> lottie <span class="keyword">from</span> <span class="string">&#x27;lottie-web&#x27;</span></span><span class="javascript"></span><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;AnimationComponent&quot;</span>,</span><span class="javascript">  <span class="attr">methods</span>:&#123;</span><span class="javascript">    <span class="function"><span class="title">loadAnimation</span>(<span class="params"></span>)</span>&#123;</span><span class="javascript">      <span class="keyword">let</span> animData = &#123;</span><span class="javascript">        <span class="attr">wrapper</span>: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;bodymovin&#x27;</span>),</span><span class="javascript">        <span class="attr">animType</span>: <span class="string">&#x27;html&#x27;</span>,</span><span class="javascript">        <span class="attr">loop</span>: <span class="literal">false</span>,</span><span class="javascript">        <span class="attr">prerender</span>: <span class="literal">true</span>,</span><span class="javascript">        <span class="attr">autoplay</span>: <span class="literal">true</span>,</span><span class="javascript">        <span class="attr">path</span>: <span class="string">&#x27;static/data.json&#x27;</span>,</span><span class="javascript">      &#125;;</span><span class="javascript">      <span class="keyword">let</span> lottiePlayer = lottie.loadAnimation(animData);</span><span class="javascript">      <span class="keyword">let</span> temp = <span class="number">1</span>;</span><span class="javascript">      lottiePlayer.addEventListener(<span class="string">&quot;complete&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;动画完成&quot;</span>)</span><span class="javascript">        <span class="comment">// lottiePlayer.playSegments([158,226], true)</span></span><span class="javascript">        <span class="keyword">if</span>(temp &gt; <span class="number">0</span>)&#123;</span><span class="javascript">          lottiePlayer.playSegments([<span class="number">158</span>,<span class="number">226</span>], <span class="literal">true</span>)</span><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span><span class="javascript">          lottiePlayer.playSegments([<span class="number">226</span>,<span class="number">158</span>], <span class="literal">true</span>)</span><span class="javascript">        &#125;</span><span class="javascript"></span><span class="javascript">        temp = -<span class="number">1</span> * temp;</span><span class="javascript">      &#125;)</span><span class="javascript">    &#125;</span><span class="javascript">  &#125;,</span><span class="javascript">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><span class="javascript">    <span class="built_in">this</span>.loadAnimation();</span><span class="javascript">  &#125;</span><span class="javascript">&#125;</span><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></code></pre><h2 id="简单功能介绍"><a href="#简单功能介绍" class="headerlink" title="简单功能介绍"></a>简单功能介绍</h2><ul><li><p>lottiePlayer.play()：播放，从当前帧开始播放</p></li><li><p>lottiePlayer.stop()：停止，并回到第0帧</p></li><li><p>lottiePlayer.pause()：暂停，并保持当前帧</p></li><li><p>lottiePlayer.goToAndStop(value, isFrame)：跳到某个时刻/帧并停止</p></li><li><p>isFrame（可省略，默认false：毫秒；true：帧）指明value的单位是毫秒还是帧</p></li><li><p>lottiePlayer.goToAndPlay(value, isFrame)：跳到某个时刻/帧并播放</p></li><li><p>lottiePlayer.goToAndPlay(value, isFrame)：跳到某个时刻/帧并播放</p></li><li><p>lottiePlayer.goToAndStop(30, true)     // 跳转到第30帧并停止</p></li><li><p>lottiePlayer.goToAndPlay(300)          // 跳转到第300毫秒并播放</p></li><li><p>lottiePlayer.playSegments(arr, forceFlag)：以帧为单位，播放指定片段</p><blockquote><p>arr可以包含两个数字或者两个数字组成的数组，forceFlag表示是否立即强制播放该片段</p></blockquote></li><li><p>lottiePlayer.playSegments([10,20], false)          // 播放完之前的片段，播放10-20帧</p></li><li><p>lottiePlayer.playSegments([[0,5],[10,18]], true)   // 直接播放0-5帧和10-18帧</p></li><li><p>lottiePlayer.setSpeed(speed)：设置播放速度，speed为1表示正常速度</p></li><li><p>lottiePlayer.setDirection(direction)： 设置播放方向，1表示正向播放，-1表示反向播放</p></li><li><p>lottiePlayer.destroy()： 删除该动画，移除相应的元素标签等。</p></li></ul>]]></content>
    
    
    <summary type="html">Lottie 从UI动画场景出发解决矢量动画渲染的问题，使用 AE Script SDK 来导出 AE 工程。</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="动画" scheme="https://mirsery.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>将exe封装为系统服务开机自启</title>
    <link href="https://mirsery.github.io/2022/08/31/talk/2022/%E5%B0%86exe%E5%B0%81%E8%A3%85%E4%B8%BA%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/"/>
    <id>https://mirsery.github.io/2022/08/31/talk/2022/%E5%B0%86exe%E5%B0%81%E8%A3%85%E4%B8%BA%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</id>
    <published>2022-08-31T07:10:57.000Z</published>
    <updated>2022-08-31T07:10:57.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--------">目录列表如下所示</a></li><li><a href="#installbat------------">install.bat 安装程序为系统服务脚本</a></li><li><a href="#uninstallbat-------">uninstall.bat 移除服务脚本</a></li></ul><!-- tocstop --><blockquote><p>本文使用的资源地址</p></blockquote><p><a href="tools.zip">点击下载微软提供的开发者工具</a></p><h2 id="目录列表如下所示"><a href="#目录列表如下所示" class="headerlink" title="目录列表如下所示"></a>目录列表如下所示</h2><p>将下载下的资源解压到根目录，目录结构如下所示:</p><pre><code class="highlight plaintext">instsrv.exesrvany.exe[targetEXE].exeinstall.batuninstall.bat</code></pre><blockquote><p>其中 <strong>[targetEXE].exe</strong> 为所需要打包的exe程序，<strong>instsrv.exe 和 srvany.exe</strong>是开发工具内的文件</p></blockquote><h2 id="install-bat-安装程序为系统服务脚本"><a href="#install-bat-安装程序为系统服务脚本" class="headerlink" title="install.bat 安装程序为系统服务脚本"></a>install.bat 安装程序为系统服务脚本</h2><pre><code class="highlight bat">@<span class="built_in">echo</span> off<span class="built_in">cd</span> /d %~dp0<span class="comment"></span><span class="comment">rem 定义需要运行的程序路径</span><span class="built_in">set</span> curExe=%~dp0[targetEXE].exe<span class="comment">rem 定义注册表路径</span><span class="built_in">set</span> regpath=HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\[customServieName]\Parameters\<span class="comment">rem 定义srvany.exe文件路径</span><span class="built_in">set</span> sourcePath=%~dp0srvany.exe<span class="comment"></span><span class="comment">rem 安装引导服务</span>instsrv [customServieName]  &quot;<span class="variable">%sourcePath%</span>&quot;@<span class="built_in">echo</span> 服务添加完成<span class="comment"></span><span class="comment">rem 添加注册表语法: reg add 注册表路径 /v 项名称 /t 值类型 /d 数据 /f 表示强行修改不提示</span><span class="comment"></span><span class="comment">rem 名称 Application 值为你要作为服务运行的程序地址 /d对应的参数有斜杠不是为了转义引号，而是路径还有斜杠，默认将引号转义了，额外添加斜杠是为了保留引号</span>reg add <span class="variable">%regpath%</span> /v AppDirectory /t REG_SZ /d &quot;%~dp0\&quot; /f<span class="comment"></span><span class="comment">rem 名称 AppDirectory 值为你要作为服务运行的程序所在文件夹路径</span>reg add <span class="variable">%regpath%</span> /v Application /t REG_SZ /d &quot;<span class="variable">%curExe%</span>&quot; /f<span class="comment"></span><span class="comment">rem 名称 AppParameters 值为你要作为服务运行的程序启动所需要的参数</span>reg add <span class="variable">%regpath%</span> /v AppParameters /t REG_SZ /f<span class="built_in">net</span> <span class="built_in">start</span> [customServieName]@<span class="built_in">echo</span> 注册表添加完成<span class="built_in">pause</span></code></pre><h2 id="uninstall-bat-移除服务脚本"><a href="#uninstall-bat-移除服务脚本" class="headerlink" title="uninstall.bat 移除服务脚本"></a>uninstall.bat 移除服务脚本</h2><pre><code class="highlight bat">@<span class="built_in">echo</span> off<span class="comment">rem 进入当前目录</span><span class="built_in">cd</span> /d %~dp0<span class="built_in">net</span> stop [customServieName]<span class="comment"></span><span class="comment">rem 卸载引导服务</span>instsrv [customServieName] remove@<span class="built_in">echo</span> 卸载完成<span class="built_in">pause</span></code></pre>]]></content>
    
    
    <summary type="html">使用微软提供的开发者工具进行exe程序的封装...</summary>
    
    
    
    <category term="运维" scheme="https://mirsery.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="win" scheme="https://mirsery.github.io/tags/win/"/>
    
  </entry>
  
  <entry>
    <title>配置oh-my-posh</title>
    <link href="https://mirsery.github.io/2022/08/31/talk/2022/%E9%85%8D%E7%BD%AEoh-my-posh/"/>
    <id>https://mirsery.github.io/2022/08/31/talk/2022/%E9%85%8D%E7%BD%AEoh-my-posh/</id>
    <published>2022-08-31T04:59:08.000Z</published>
    <updated>2022-08-31T04:59:08.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----oh-my-posh">下载安装oh-my-posh</a></li><li><a href="#---------">下载并预览主题文件</a></li><li><a href="#--">主题</a><ul><li><a href="#--------">新建主题保存目录</a></li><li><a href="#------">修改应用主题</a></li></ul></li></ul><!-- tocstop --><h2 id="下载安装oh-my-posh"><a href="#下载安装oh-my-posh" class="headerlink" title="下载安装oh-my-posh"></a>下载安装oh-my-posh</h2><ul><li>window平台</li></ul><pre><code class="highlight shell">scoop install oh-my-posh</code></pre><ul><li>macos</li></ul><pre><code class="highlight shell">brew install oh-my-posh</code></pre><h2 id="下载并预览主题文件"><a href="#下载并预览主题文件" class="headerlink" title="下载并预览主题文件"></a>下载并预览主题文件</h2><p><a href="https://ohmyposh.dev/docs/themes">主题预览地址https://ohmyposh.dev/docs/themes</a> ，点击即可预览相关的主题文件。</p><p><a href="https://github.com/JanDeDobbeleer/oh-my-posh/tree/main/themes">主题下载地址https://github.com/JanDeDobbeleer/oh-my-posh/tree/main/themes</a>点击可以下载对应预览页面的主题文件</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><h3 id="新建主题保存目录"><a href="#新建主题保存目录" class="headerlink" title="新建主题保存目录"></a>新建主题保存目录</h3><ul><li><p>window平台<br>创建文件</p><pre><code class="highlight shell">oh-my-posh init pwsh | Invoke-Expression</code></pre><p>在terminal中执行如下指令:</p><pre><code class="highlight shell">notepad $profile</code></pre><p>在文件中添加如下代码:</p><pre><code class="highlight plaintext">oh-my-posh --init --shell pwsh --config 主题路径 | Invoke-ExpressionSet-PoshPrompt -Theme 主题名</code></pre></li><li><p>linux和mac os平台</p><ul><li>bash<br>  Bash 的配置文件一般是<del>/.bashrc 或者</del>/.profile  <pre><code class="highlight shell">eval &quot;$(oh-my-posh --init --shell bash --config 主题路径)&quot;</code></pre></li><li>zsh<br>  Zsh 的配置文件为~/.zshrc  <pre><code class="highlight shell">eval &quot;$(oh-my-posh --init --shell zsh --config 主题路径)&quot;</code></pre></li></ul></li></ul><h3 id="修改应用主题"><a href="#修改应用主题" class="headerlink" title="修改应用主题"></a>修改应用主题</h3><p>windows下面可以执行<strong>Get-PoshThemes</strong>查看主题保存的路径，并根据提示可以修改应用相关的主题</p><pre><code class="highlight shell">oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH/jandedobbeleer.omp.json&quot; | Invoke-Expression</code></pre><p>其他的操作系统参考上一小节</p>]]></content>
    
    
    <summary type="html">全平台通用神器oh-my-posh 美化终端..</summary>
    
    
    
    <category term="装机必备" scheme="https://mirsery.github.io/categories/%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"/>
    
    
    <category term="shell" scheme="https://mirsery.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>win11使用git的小问题</title>
    <link href="https://mirsery.github.io/2022/08/31/git/win11%E4%BD%BF%E7%94%A8git%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://mirsery.github.io/2022/08/31/git/win11%E4%BD%BF%E7%94%A8git%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-31T02:49:40.000Z</published>
    <updated>2022-08-31T02:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----">解决问题</a></li></ul><!-- tocstop --><p>参考资料<a href="https://brendanforster.com/notes/fixing-invalid-git-paths-on-windows/">invalid-git-paths-on-windows/</a></p><p>近期换了笔记本，win11的操作系统。在使用git的时候突然发现了一个问题，在下载项目的时候报了一个比较奇怪的错误，错误内容如下所示：</p><pre><code class="highlight plaintext">error: invalid path &#x27;....*******......&#x27;</code></pre><p>类似这种路径不合法的错误，一开始我在远程仓库修改文件的名称，但是于事无补。</p><p>其他的电脑访问这个仓库没有任何异常。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>一开始我以为是git版本的问题，随即就更新了git的版本</p><pre><code class="highlight shell">scoop update git</code></pre><p>但是更新完成之后错误依然在。查了下资料发现是由于ntfs格式的保护原因，关闭ntfs的保护即可解决问题</p><pre><code class="highlight shell">git global config core.protectNTFS false</code></pre>]]></content>
    
    
    <summary type="html">mac电脑切换win11 git 遇到的一些奇怪的问题...</summary>
    
    
    
    <category term="随笔" scheme="https://mirsery.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="git" scheme="https://mirsery.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务的查看和清除</title>
    <link href="https://mirsery.github.io/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%B8%85%E9%99%A4/"/>
    <id>https://mirsery.github.io/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%B8%85%E9%99%A4/</id>
    <published>2022-07-16T09:03:53.000Z</published>
    <updated>2022-07-16T09:03:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--------">查看当前打开的表</a></li><li><a href="#-------------">查看当前的线程数和表的关系</a></li><li><a href="#---------">查看正在执行的事务</a></li><li><a href="#----">结束连接</a></li><li><a href="#--------">查看正在锁的事务</a></li><li><a href="#----------">查看正在等待锁的事务</a></li><li><a href="#-----------">查看当前运行的现成列表</a></li></ul><!-- tocstop --><h2 id="查看当前打开的表"><a href="#查看当前打开的表" class="headerlink" title="查看当前打开的表"></a>查看当前打开的表</h2><pre><code class="highlight sql"><span class="keyword">show</span> <span class="keyword">open</span> tables;</code></pre><h2 id="查看当前的线程数和表的关系"><a href="#查看当前的线程数和表的关系" class="headerlink" title="查看当前的线程数和表的关系"></a>查看当前的线程数和表的关系</h2><pre><code class="highlight sql"><span class="keyword">show</span> <span class="keyword">OPEN</span> TABLES  <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</code></pre><h2 id="查看正在执行的事务"><a href="#查看正在执行的事务" class="headerlink" title="查看正在执行的事务"></a>查看正在执行的事务</h2><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TRX;</code></pre><p>若<strong>trx_state为LOCK WAIT</strong>或者<strong>trx_rows_locked &gt; 0</strong>均表示有锁的等待</p><h2 id="结束连接"><a href="#结束连接" class="headerlink" title="结束连接"></a>结束连接</h2><pre><code class="highlight sql">kill <span class="operator">&lt;</span>PID<span class="operator">&gt;</span></code></pre><h2 id="查看正在锁的事务"><a href="#查看正在锁的事务" class="headerlink" title="查看正在锁的事务"></a>查看正在锁的事务</h2><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_LOCKS;</code></pre><h2 id="查看正在等待锁的事务"><a href="#查看正在等待锁的事务" class="headerlink" title="查看正在等待锁的事务"></a>查看正在等待锁的事务</h2><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</code></pre><h2 id="查看当前运行的现成列表"><a href="#查看当前运行的现成列表" class="headerlink" title="查看当前运行的现成列表"></a>查看当前运行的现成列表</h2><pre><code class="highlight sql"><span class="keyword">show</span> processlist;<span class="keyword">show</span> <span class="keyword">full</span> processlist;</code></pre>]]></content>
    
    
    <summary type="html">mysql的一些调试指令</summary>
    
    
    
    <category term="mysql" scheme="https://mirsery.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://mirsery.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>xml和properties的读写</title>
    <link href="https://mirsery.github.io/2022/07/14/java/2022/xml%E5%92%8Cproperties%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/"/>
    <id>https://mirsery.github.io/2022/07/14/java/2022/xml%E5%92%8Cproperties%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/</id>
    <published>2022-07-14T14:34:31.000Z</published>
    <updated>2022-07-14T14:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#------">环境路径问题</a></li><li><a href="#xml-----">xml文件的载入</a></li><li><a href="#properties----">properties文件载入</a></li><li><a href="#xml----">xml的序列化</a><ul><li><a href="#properties---">properties序列化</a></li></ul></li></ul><!-- tocstop --><h2 id="环境路径问题"><a href="#环境路径问题" class="headerlink" title="环境路径问题"></a>环境路径问题</h2><p>SpringBoot中我们可以利用<strong>ClassPathResource</strong>类，利用相对路径载入<strong>classPath</strong>路径下的文件配置。</p><h2 id="xml文件的载入"><a href="#xml文件的载入" class="headerlink" title="xml文件的载入"></a>xml文件的载入</h2><pre><code class="highlight java"><span class="comment">/*</span><span class="comment"> * 读入xml文件并序列化成javaBean</span><span class="comment"> */</span>    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> DeviceList <span class="title">getDevice</span><span class="params">()</span> <span class="keyword">throws</span> IOException, JAXBException </span>&#123;        String fileName = <span class="string">&quot;device.xml&quot;</span>;        File file = <span class="keyword">new</span> File(fileName);        InputStream inputStream = <span class="keyword">null</span>;        <span class="keyword">if</span> (!file.exists()) &#123;            inputStream = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;device.xml&quot;</span>).getInputStream();        &#125; <span class="keyword">else</span> &#123;            inputStream = Files.newInputStream(file.toPath());        &#125;        BufferedReader br = <span class="keyword">new</span> BufferedReader(                <span class="keyword">new</span> InputStreamReader(inputStream, StandardCharsets.UTF_8));        StringBuilder buffer = <span class="keyword">new</span> StringBuilder();        String line = <span class="string">&quot;&quot;</span>;        <span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>) &#123;            buffer.append(line);        &#125;        br.close();        Object xmlObject = <span class="keyword">null</span>;        Reader reader = <span class="keyword">null</span>;        JAXBContext context = JAXBContext.newInstance(DeviceList.class);        Unmarshaller unmarshaller = context.createUnmarshaller();        reader = <span class="keyword">new</span> StringReader(buffer.toString());        <span class="comment">//以文件流的方式传入这个string</span>        xmlObject = unmarshaller.unmarshal(reader);        reader.close();        DeviceList deviceList = (DeviceList) xmlObject;        <span class="keyword">return</span> deviceList;    &#125;</code></pre><pre><code class="highlight java"><span class="comment">//child节点类</span><span class="meta">@XmlRootElement(name = &quot;device&quot;)</span><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span> </span>&#123;    <span class="meta">@XmlElement(name = &quot;name&quot;)</span>    <span class="keyword">private</span> String name; <span class="comment">//channelCode</span>    <span class="meta">@XmlElement(name = &quot;deviceNo&quot;)</span>    <span class="keyword">private</span> String deviceNo;    <span class="meta">@XmlElement(name = &quot;address&quot;)</span>    <span class="keyword">private</span> String address;    <span class="meta">@XmlElement(name = &quot;enter&quot;, defaultValue = &quot;0&quot;)</span>    <span class="keyword">private</span> <span class="keyword">int</span> enter;    <span class="meta">@XmlElement(name = &quot;type&quot;, defaultValue = &quot;0&quot;)</span>    <span class="keyword">private</span> <span class="keyword">int</span> type;    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> name;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getDeviceNo</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> deviceNo;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeviceNo</span><span class="params">(String deviceNo)</span> </span>&#123;        <span class="keyword">this</span>.deviceNo = deviceNo;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> address;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;        <span class="keyword">this</span>.address = address;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEnter</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> enter;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnter</span><span class="params">(<span class="keyword">int</span> enter)</span> </span>&#123;        <span class="keyword">this</span>.enter = enter;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> type;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;        <span class="keyword">this</span>.type = type;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="meta">@XmlRootElement(name = &quot;devices&quot;)</span><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceList</span> </span>&#123;    <span class="meta">@XmlElement(name = &quot;device&quot;)</span>    <span class="keyword">private</span> List&lt;Device&gt; deviceList;    <span class="function"><span class="keyword">public</span> List&lt;Device&gt; <span class="title">getDeviceList</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> deviceList;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeviceList</span><span class="params">(List&lt;Device&gt; deviceList)</span> </span>&#123;        <span class="keyword">this</span>.deviceList = deviceList;    &#125;&#125;</code></pre><p>载入的device.xml文件</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">devices</span>&gt;</span>    <span class="tag">&lt;<span class="name">device</span>&gt;</span>        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hilee<span class="tag">&lt;/<span class="name">name</span>&gt;</span>        <span class="tag">&lt;<span class="name">deviceNo</span>&gt;</span>xjxjxjx<span class="tag">&lt;/<span class="name">deviceNo</span>&gt;</span>        <span class="tag">&lt;<span class="name">address</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">address</span>&gt;</span>        <span class="tag">&lt;<span class="name">enter</span>&gt;</span>0<span class="tag">&lt;/<span class="name">enter</span>&gt;</span>         <span class="tag">&lt;<span class="name">type</span>&gt;</span>0<span class="tag">&lt;/<span class="name">type</span>&gt;</span>    <span class="tag">&lt;/<span class="name">device</span>&gt;</span><span class="tag">&lt;/<span class="name">devices</span>&gt;</span></code></pre><h2 id="properties文件载入"><a href="#properties文件载入" class="headerlink" title="properties文件载入"></a>properties文件载入</h2><pre><code class="highlight java"><span class="meta">@Bean</span><span class="function"><span class="keyword">public</span> IccConfig <span class="title">getIccConfig</span><span class="params">()</span> </span>&#123;    <span class="keyword">try</span> &#123;        String fileName = <span class="string">&quot;icc.properties&quot;</span>;        Properties properties = <span class="keyword">new</span> Properties();        File file = <span class="keyword">new</span> File(fileName);        <span class="keyword">if</span> (file.exists()) &#123;            properties.load(Files.newInputStream(file.toPath()));        &#125; <span class="keyword">else</span> &#123;            properties.load(<span class="keyword">new</span> ClassPathResource(fileName).getInputStream());        &#125;        IccConfig icConfig = <span class="keyword">new</span> IccConfig();        icConfig.setHost(properties.getProperty(<span class="string">&quot;host&quot;</span>));        icConfig.setUsername(properties.getProperty(<span class="string">&quot;username&quot;</span>));        icConfig.setPassword(properties.getProperty(<span class="string">&quot;password&quot;</span>));        icConfig.setClientId(properties.getProperty(<span class="string">&quot;clientId&quot;</span>));        icConfig.setClientSecret(properties.getProperty(<span class="string">&quot;clientSecret&quot;</span>));        icConfig.setPwdClientId(properties.getProperty(<span class="string">&quot;pwdClientId&quot;</span>));        icConfig.setPwdClientSecret(properties.getProperty(<span class="string">&quot;pwdClientSecret&quot;</span>));        <span class="keyword">return</span> icConfig;    &#125; <span class="keyword">catch</span> (IOException e) &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IccConfig</span> </span>&#123;    <span class="keyword">private</span> String host;    <span class="keyword">private</span> String clientId;    <span class="keyword">private</span> String clientSecret;    <span class="keyword">private</span> String pwdClientId;    <span class="keyword">private</span> String username;    <span class="keyword">private</span> String pwdClientSecret;    <span class="keyword">private</span> String password;    <span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> host;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHost</span><span class="params">(String host)</span> </span>&#123;        <span class="keyword">this</span>.host = host;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getClientId</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> clientId;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientId</span><span class="params">(String clientId)</span> </span>&#123;        <span class="keyword">this</span>.clientId = clientId;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getClientSecret</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> clientSecret;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientSecret</span><span class="params">(String clientSecret)</span> </span>&#123;        <span class="keyword">this</span>.clientSecret = clientSecret;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getPwdClientId</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> pwdClientId;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwdClientId</span><span class="params">(String pwdClientId)</span> </span>&#123;        <span class="keyword">this</span>.pwdClientId = pwdClientId;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> username;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;        <span class="keyword">this</span>.username = username;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getPwdClientSecret</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> pwdClientSecret;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwdClientSecret</span><span class="params">(String pwdClientSecret)</span> </span>&#123;        <span class="keyword">this</span>.pwdClientSecret = pwdClientSecret;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> password;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;        <span class="keyword">this</span>.password = password;    &#125;&#125;</code></pre><h2 id="xml的序列化"><a href="#xml的序列化" class="headerlink" title="xml的序列化"></a>xml的序列化</h2><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">saveDeviceXML</span><span class="params">(Collection&lt;Device&gt; devices)</span> </span>&#123;        <span class="keyword">try</span> &#123;            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();            Document document = builder.newDocument();            Element element = document.createElement(<span class="string">&quot;devices&quot;</span>);            devices.forEach(item -&gt; &#123;                <span class="keyword">if</span> (<span class="keyword">null</span>!=item.getName() &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(item.getName())) &#123;                    Element device = document.createElement(<span class="string">&quot;device&quot;</span>);                    Element name = document.createElement(<span class="string">&quot;name&quot;</span>);                    Element deviceNo = document.createElement(<span class="string">&quot;deviceNo&quot;</span>);                    Element address = document.createElement(<span class="string">&quot;address&quot;</span>);                    Element enter = document.createElement(<span class="string">&quot;enter&quot;</span>);                    Element type = document.createElement(<span class="string">&quot;type&quot;</span>);                    name.setTextContent(item.getName());                    deviceNo.setTextContent(item.getDeviceNo());                    address.setTextContent(item.getAddress());                    enter.setTextContent(String.valueOf(item.getEnter()));                    type.setTextContent(String.valueOf(item.getType()));                    device.appendChild(name);                    device.appendChild(deviceNo);                    device.appendChild(address);                    device.appendChild(enter);                    device.appendChild(type);                    element.appendChild(device);                &#125;            &#125;);            document.appendChild(element);            TransformerFactory factory = TransformerFactory.newInstance();            Transformer transformer = factory.newTransformer();            document.setXmlStandalone(<span class="keyword">true</span>);            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, <span class="string">&quot;yes&quot;</span>);            String fileName = <span class="string">&quot;device.xml&quot;</span>;            File file = <span class="keyword">new</span> File(fileName);            FileOutputStream outputStream = <span class="keyword">null</span>;            <span class="keyword">if</span> (!file.exists()) &#123;                ClassPathResource pathResource = <span class="keyword">new</span> ClassPathResource(fileName);                outputStream = <span class="keyword">new</span> FileOutputStream(pathResource.getFile());            &#125; <span class="keyword">else</span> &#123;                outputStream = <span class="keyword">new</span> FileOutputStream(file);            &#125;            transformer.transform(<span class="keyword">new</span> DOMSource(document), <span class="keyword">new</span> StreamResult(outputStream));            outputStream.close();        &#125; <span class="keyword">catch</span> (ParserConfigurationException | TransformerException | IOException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);        &#125;    &#125;</code></pre><h3 id="properties序列化"><a href="#properties序列化" class="headerlink" title="properties序列化"></a>properties序列化</h3><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">saveIccProperties</span><span class="params">(IccConfig iccConfig)</span> </span>&#123;        <span class="keyword">try</span> &#123;            Properties properties = <span class="keyword">new</span> Properties();            properties.setProperty(<span class="string">&quot;host&quot;</span>, iccConfig.getClientId());            properties.setProperty(<span class="string">&quot;username&quot;</span>, iccConfig.getClientSecret());            properties.setProperty(<span class="string">&quot;password&quot;</span>, iccConfig.getHost());            properties.setProperty(<span class="string">&quot;clientId&quot;</span>, iccConfig.getUsername());            properties.setProperty(<span class="string">&quot;clientSecret&quot;</span>, iccConfig.getPassword());            properties.setProperty(<span class="string">&quot;pwdClientId&quot;</span>, iccConfig.getPwdClientId());            properties.setProperty(<span class="string">&quot;pwdClientSecret&quot;</span>, iccConfig.getPwdClientSecret());            String fileName = <span class="string">&quot;icc.properties&quot;</span>;            File file = <span class="keyword">new</span> File(fileName);            OutputStream outputStream = <span class="keyword">null</span>;            <span class="keyword">if</span> (!file.exists()) &#123;                ClassPathResource pathResource = <span class="keyword">new</span> ClassPathResource(fileName);                outputStream = <span class="keyword">new</span> FileOutputStream(pathResource.getFile());            &#125; <span class="keyword">else</span> &#123;                outputStream = Files.newOutputStream(file.toPath());            &#125;            properties.store(outputStream, <span class="keyword">null</span>);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">Springboot读写xml和properties的文件</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>前端实现消息声音提醒功能</title>
    <link href="https://mirsery.github.io/2022/06/29/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%A3%B0%E9%9F%B3%E6%8F%90%E9%86%92%E5%8A%9F%E8%83%BD/"/>
    <id>https://mirsery.github.io/2022/06/29/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%A3%B0%E9%9F%B3%E6%8F%90%E9%86%92%E5%8A%9F%E8%83%BD/</id>
    <published>2022-06-29T04:35:04.000Z</published>
    <updated>2022-06-29T04:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#-----">浏览器设置</a></li><li><a href="#----">代码部分</a></li></ul><!-- tocstop --><p>众所周知，由于浏览器的限制，页面并不能直接自动播放声音，需要开启权限。我们在B/S架构中为了实现声音的自动播放需要打开浏览器的限制。</p><h2 id="浏览器设置"><a href="#浏览器设置" class="headerlink" title="浏览器设置"></a>浏览器设置</h2><p>打开<strong>chrome</strong>浏览器，在地址栏输入如下地址:</p><pre><code class="highlight plaintext">chrome://flags/#autoplay-policy</code></pre><p>在下面选项中找到如下配置项:</p><pre><code class="highlight plaintext">Global media controls control Cast start/stop</code></pre><p>修改为<strong>Enable</strong></p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><pre><code class="highlight html"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">preload</span>=<span class="string">&quot;auto|metadata|none&quot;</span> <span class="attr">hidden</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;messageAudio&#x27;</span>&gt;</span>        <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./audio.mp3&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span><span class="javascript"><span class="comment">/*</span></span><span class="comment"><span class="javascript">    </span></span><span class="comment"><span class="javascript">    preload：音频被加载的方式</span></span><span class="comment"><span class="javascript">    hidden：是否隐藏</span></span><span class="comment"><span class="javascript">    controls：展示播放暂停按钮</span></span><span class="comment"><span class="javascript">    </span></span><span class="comment"><span class="javascript">    创建好后通过js实现播放、暂停、停止功能</span></span><span class="comment"><span class="javascript">*/</span></span><span class="javascript">    <span class="keyword">let</span> messageAudio = <span class="built_in">document</span>.getElementById(<span class="string">&quot;messageAudio&quot;</span>); </span><span class="javascript"></span><span class="javascript">    messageAudio.play(); <span class="comment">// 播放</span></span><span class="javascript"></span><span class="javascript">    messageAudio.pause(); messageAudio.currentTime = <span class="number">0</span>; <span class="comment">// 停止</span></span><span class="javascript"></span><span class="javascript">    messageAudio.pause(); <span class="comment">// 暂停</span></span><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>]]></content>
    
    
    <summary type="html">’自动加载音频的播放...‘</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://mirsery.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>序列化和返序列化的应用</title>
    <link href="https://mirsery.github.io/2022/06/27/java/2022/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E8%BF%94%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://mirsery.github.io/2022/06/27/java/2022/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E8%BF%94%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2022-06-27T08:47:34.000Z</published>
    <updated>2022-06-27T08:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#jdk-----------">jdk自带的序列化机制的使用</a></li></ul><!-- tocstop --><h2 id="jdk自带的序列化机制的使用"><a href="#jdk自带的序列化机制的使用" class="headerlink" title="jdk自带的序列化机制的使用"></a>jdk自带的序列化机制的使用</h2><p>实体类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;    <span class="keyword">private</span> String name;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;        System.out.println(<span class="string">&quot;create car&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot; is run !&quot;</span>);    &#125;&#125;</code></pre><p>方法类</p><pre><code class="highlight java"><span class="keyword">import</span> java.io.FileInputStream;<span class="keyword">import</span> java.io.FileOutputStream;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.io.ObjectInput;<span class="keyword">import</span> java.io.ObjectInputStream;<span class="keyword">import</span> java.io.ObjectOutput;<span class="keyword">import</span> java.io.ObjectOutputStream;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.List;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySerialize</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;        List&lt;Car&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();        Car car1 = <span class="keyword">new</span> Car(<span class="string">&quot;bench&quot;</span>);        Car car2 = <span class="keyword">new</span> Car(<span class="string">&quot;BMW&quot;</span>);        Car car3 = <span class="keyword">new</span> Car(<span class="string">&quot;Audi&quot;</span>);        list.add(car1);        list.add(car2);        list.add(car3);        <span class="comment">/**</span><span class="comment">         * 序列化</span><span class="comment">         * **/</span>        ObjectOutput objectOutput = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;cars&quot;</span>));        objectOutput.writeObject(list.toArray());        objectOutput.close();        <span class="comment">/**</span><span class="comment">         * 返序列化</span><span class="comment">         * **/</span>        ObjectInput objectInput = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;cars&quot;</span>));        Object[] car = (Object[]) objectInput.readObject();        ((Car)car[<span class="number">0</span>]).run();    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">jdk自带的序列化和返序列化</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://mirsery.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Springboot应用的Hook配置</title>
    <link href="https://mirsery.github.io/2022/06/27/java/2022/Springboot%E5%BA%94%E7%94%A8%E7%9A%84Hook%E9%85%8D%E7%BD%AE/"/>
    <id>https://mirsery.github.io/2022/06/27/java/2022/Springboot%E5%BA%94%E7%94%A8%E7%9A%84Hook%E9%85%8D%E7%BD%AE/</id>
    <published>2022-06-27T08:08:31.000Z</published>
    <updated>2022-06-27T08:08:31.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#applicationrunner">ApplicationRunner</a></li><li><a href="#commandlinerunner">CommandLineRunner</a></li><li><a href="#-predestroy">@PreDestroy</a></li></ul><!-- tocstop --><h2 id="ApplicationRunner"><a href="#ApplicationRunner" class="headerlink" title="ApplicationRunner"></a>ApplicationRunner</h2><p>实现<strong>ApplicationRunner</strong>接口，并重写run函数，可以实现<strong>springboot</strong>项目启动完成之后的回调</p><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;       <span class="comment">//something to do </span>    &#125;&#125;</code></pre><h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h2><p>实现<strong>CommandLineRunner</strong>接口，并重写run函数，可以实现<strong>springboot</strong>项目启动完成之后的回调</p><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;    &#125;&#125;</code></pre><h2 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h2><p>采用<code>@PreDestroy</code>注释可以实现springboot项目停止之后的钩子回调，运用实例如下所示:</p><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPreDestroy</span> </span>&#123;    <span class="meta">@PreDestroy</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPreDestroy</span><span class="params">()</span> </span>&#123;                &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">Springboot框架的Hook应用</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>亚马逊电子书移除DeDRM</title>
    <link href="https://mirsery.github.io/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/"/>
    <id>https://mirsery.github.io/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/</id>
    <published>2022-06-02T05:47:31.000Z</published>
    <updated>2022-06-02T05:47:31.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--calibre---">安装calibre 软件</a></li><li><a href="#--dedrm-tools--">安装DeDRM_tools插件</a></li><li><a href="#-----">转换电子书</a></li></ul><!-- tocstop --><blockquote><p>前提纪要<br>采用此方法移除Dedrm需要以下的几个前提条件:</p></blockquote><ol><li>一个合法的kindle设备序列号</li><li><a href="https://calibre-ebook.com/">calibre</a> 客户端（本文按照mac版本进行讲解)</li><li><a href="https://github.com/apprenticeharper/DeDRM_tools/releases">DeDRM_tools</a> DRM移除插件</li></ol><h2 id="安装calibre-软件"><a href="#安装calibre-软件" class="headerlink" title="安装calibre 软件"></a>安装calibre 软件</h2><p>这个比较简单，直接傻瓜式点击下载安装即可完成</p><h2 id="安装DeDRM-tools插件"><a href="#安装DeDRM-tools插件" class="headerlink" title="安装DeDRM_tools插件"></a>安装DeDRM_tools插件</h2><p>下载DeDRM_tools插件，并解压。</p><p>点击calibre &gt; Preferences 在首选项中选择插件，如下图:<br><img src="/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/C4D57509-9AFB-4E56-8269-3344686772CC.png"></p><p>选择从文件加载插件,选取刚刚已经解压的<strong>DeDRM_plugin</strong>插件进行安装，安装结束之后在搜索栏搜索该插件，并双击该条目，显示如下：</p><p><img src="/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/78D39828-FAB0-4CB8-9F81-3930725D20F2.png"></p><p>选择<strong>elnk kindle ebooks</strong>条目，新增一个合法的kindle设备序列号，并保存。</p><h2 id="转换电子书"><a href="#转换电子书" class="headerlink" title="转换电子书"></a>转换电子书</h2><p>亚马逊中购买电子书之后，选择<strong>通过电脑下载USB传输</strong>下载格式为<strong>azw3</strong>的电子书， 利用calibre进行电子书格式的转换可以自动移除相关的DRM。</p><p>注：自己移除的DRM电子书不能在网上私自发布仅供自己阅读，尊重版权。移除DRM实属Amazon的kindle客户端阅读起来台拉胯，iBooks中国不提供图书购买服务，不得已而为之，实属无奈。</p>]]></content>
    
    
    <summary type="html">‘移除亚马逊电子书DRM版权保护’</summary>
    
    
    
    <category term="电子书" scheme="https://mirsery.github.io/categories/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
    
    <category term="电子书" scheme="https://mirsery.github.io/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>自定义类加载器加载类</title>
    <link href="https://mirsery.github.io/2022/01/10/java/2022/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%B1%BB/"/>
    <id>https://mirsery.github.io/2022/01/10/java/2022/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%B1%BB/</id>
    <published>2022-01-10T13:44:05.000Z</published>
    <updated>2022-01-10T13:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#-----------">自定义加载器的编码实现</a></li></ul><!-- tocstop --><p>一般情况下在程序中开发人员使用自己编写的自定义加载器来与默认的加载器共同执行类加载任务的情况并不多见。实现一个自定义类加载器是非常简单的，只需要继承抽象类ClassLoader，并重写其findClass()方法即可。</p><h2 id="自定义加载器的编码实现"><a href="#自定义加载器的编码实现" class="headerlink" title="自定义加载器的编码实现"></a>自定义加载器的编码实现</h2><pre><code class="highlight java"><span class="comment">//自定义类加载器 myClassLoader</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;    <span class="keyword">private</span> String codePath;    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String codePath)</span> </span>&#123;        <span class="keyword">this</span>.codePath = codePath;    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;        <span class="keyword">byte</span>[] value = <span class="keyword">null</span>;        BufferedInputStream in = <span class="keyword">null</span>;        <span class="keyword">try</span> &#123;            in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(codePath+name+<span class="string">&quot;.class&quot;</span>));            value = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];            in.read(value);        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;<span class="keyword">finally</span> &#123;            <span class="keyword">try</span> &#123;                in.close();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="keyword">assert</span> value != <span class="keyword">null</span>;        <span class="keyword">return</span> defineClass(<span class="keyword">this</span>.getClass().getPackageName()+<span class="string">&quot;.&quot;</span>+name,value,<span class="number">0</span>,value.length);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;/xxx/xxx/&quot;</span>);        Class carClass  = myClassLoader.loadClass(<span class="string">&quot;Car&quot;</span>);        Object o = carClass.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class&#125;).newInstance(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>&#125;);        Method method = o.getClass().getMethod(<span class="string">&quot;run&quot;</span>);        method.invoke(o);        System.out.println(o.getClass().getClassLoader());                System.out.println(myClassLoader.getClass().getClassLoader());    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">想要在程序中实现一个自定义类加载器是非常简单的，只需要继承抽象类ClassLoader，并重写其findClass()方法即可。在此大家需要注意，尽管Java虚拟机规范将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器，但是从严格意义上来说，由Java开发人员编写的自定义类加载其实并不属于Java体系结构的组成部分，实际上它仅仅只是属于Java运行时程序的一部分而已...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="jvm" scheme="https://mirsery.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>双亲委派模型</title>
    <link href="https://mirsery.github.io/2022/01/10/java/2022/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>https://mirsery.github.io/2022/01/10/java/2022/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-01-10T06:27:39.000Z</published>
    <updated>2022-01-10T06:27:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----">背景知识</a></li><li><a href="#------">双亲委派模型</a></li><li><a href="#--------">破坏双亲委派模型</a></li></ul><!-- tocstop --><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>详细见<a href="../2019/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">类加载器</a> 章节</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的委派机制约定了类加载器的加载机制。按照双亲委派模型的规则，除了启动加载器之外，程序中每一个类加载器都应该有一个超类加载器，比如AppClassLoader的超类加载器就是ExtClassLoader，开发者编写的自定义类加载器的超类就是AppClassLoader.<br>那么当一个类加载器接收到一个类加载任务的时候，它并不会立即展开加载，而是将加载的任务委派给他的超类加载器去执行，每一层的类加载器都采用相同的方式，直至派给最顶层的启动类加载器为止。如果超类加载器无法加载委派给他的类时，便会将类的加载任务退回给他的下一级类加载器去执行加载。<br>使用双亲委派模型的优点就是能够有效地确保一个类的全局唯一性，当程序中出现多个全限定名相同的类时，类加载器在执行加载的时候，始终只会加载其中某一个类，如果通过defindClas()方法进行显示加载则JVM会抛出异常。</p><p>以下是JDK 中双亲委派的实现</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">     * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.  The</span><span class="comment">     * default implementation of this method searches for classes in the</span><span class="comment">     * following order:</span><span class="comment">     *</span><span class="comment">     * &lt;ol&gt;</span><span class="comment">     *</span><span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke &#123;<span class="doctag">@link</span> #findLoadedClass(String)&#125; to check if the class</span><span class="comment">     *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span><span class="comment">     *</span><span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #loadClass(String) loadClass&#125; method</span><span class="comment">     *   on the parent class loader.  If the parent is &#123;<span class="doctag">@code</span> null&#125; the class</span><span class="comment">     *   loader built into the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span><span class="comment">     *</span><span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #findClass(String)&#125; method to find the</span><span class="comment">     *   class.  &lt;/p&gt;&lt;/li&gt;</span><span class="comment">     *</span><span class="comment">     * &lt;/ol&gt;</span><span class="comment">     *</span><span class="comment">     * &lt;p&gt; If the class was found using the above steps, and the</span><span class="comment">     * &#123;<span class="doctag">@code</span> resolve&#125; flag is true, this method will then invoke the &#123;<span class="doctag">@link</span></span><span class="comment">     * #resolveClass(Class)&#125; method on the resulting &#123;<span class="doctag">@code</span> Class&#125; object.</span><span class="comment">     *</span><span class="comment">     * &lt;p&gt; Subclasses of &#123;<span class="doctag">@code</span> ClassLoader&#125; are encouraged to override &#123;<span class="doctag">@link</span></span><span class="comment">     * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span><span class="comment">     *</span><span class="comment">     * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span><span class="comment">     * &#123;<span class="doctag">@link</span> #getClassLoadingLock getClassLoadingLock&#125; method</span><span class="comment">     * during the entire class loading process.</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span>   name</span><span class="comment">     *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span>   resolve</span><span class="comment">     *          If &#123;<span class="doctag">@code</span> true&#125; then resolve the class</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@return</span>  The resulting &#123;<span class="doctag">@code</span> Class&#125; object</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@throws</span>  ClassNotFoundException</span><span class="comment">     *          If the class could not be found</span><span class="comment">*/</span><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)        <span class="keyword">throws</span> ClassNotFoundException    &#123;        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;            <span class="comment">// First, check if the class has already been loaded</span>            Class&lt;?&gt; c = findLoadedClass(name);            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;                <span class="keyword">long</span> t0 = System.nanoTime();                <span class="keyword">try</span> &#123;                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;                        c = parent.loadClass(name, <span class="keyword">false</span>);                    &#125; <span class="keyword">else</span> &#123;                        c = findBootstrapClassOrNull(name);                    &#125;                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;                    <span class="comment">// ClassNotFoundException thrown if class not found</span>                    <span class="comment">// from the non-null parent class loader</span>                &#125;                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;                    <span class="comment">// If still not found, then invoke findClass in order</span>                    <span class="comment">// to find the class.</span>                    <span class="keyword">long</span> t1 = System.nanoTime();                    c = findClass(name);                    <span class="comment">// this is the defining class loader; record the stats</span>                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                    PerfCounter.getFindClasses().increment();                &#125;            &#125;            <span class="keyword">if</span> (resolve) &#123;                resolveClass(c);            &#125;            <span class="keyword">return</span> c;        &#125;    &#125;</code></pre><p>在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派机制有一定的区别，当缺省的类加载器接收到到一个类的加载任务时，他首先会自行加载，当它加载失败时，才会将类的加载任务委派给他的超类加载器去执行，这也是servlet规范推荐的一种做法。</p><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>JDk种破坏双亲委派模型</p><ul><li><p>JDK1.0<br>java.lang.ClassLoader 提供了loadClass() 方法，继承ClassLoader类，重写loadClass()方法</p></li><li><p>SPI<br>一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，<br>它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。</p></li></ul><p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。<br>这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<br>有了线程上下文加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。</p><p>Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p><ul><li><p>OSGi<br>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。<br>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。<br>在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。<br>当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：<br>1）将java.＊开头的类委派给父类加载器加载。<br>2）否则，将委派列表名单内的类委派给父类加载器加载。<br>3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。<br>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。<br>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。<br>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。<br>7）否则，类加载器失败</p></li><li><p>JKD9模块系统<br>模块化加载源码片段</p><pre><code class="highlight java">Class&lt;?&gt; c = findLoadedClass(cn);      <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;         <span class="comment">// 找到当前类属于哪个模块</span>         LoadedModule loadedModule = findLoadedModule(cn);         <span class="keyword">if</span> (loadedModule != <span class="keyword">null</span>) &#123;            <span class="comment">//获取当前模块的类加载器</span>            BuiltinClassLoader loader = loadedModule.loader();            <span class="comment">//进行类加载</span>            c = findClassInModuleOrNull(loadedModule, cn);         &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 找不到模块信息才会进行双亲委派</span>         <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;           c = parent.loadClassOrNull(cn);         &#125;       &#125;</code></pre></li></ul><p>整个JDK都基于模块化进行构建，以前的rt.jar, tool.jar被拆分成数十个模块，编译的时候只编译实际用到的模块，同时各个类加载器各司其职，只加载自己负责的模块。</p><p>经过破坏后的双亲委派模型更加高效，减少了很多类加载器之间不必要的委派操作<br>JDK9的模块化可以减少Java程序打包的体积，同时拥有更好的隔离线与封装性<br>每个moudle拥有专属的类加载器，程序在并发性上也会更加出色。</p>]]></content>
    
    
    <summary type="html">类加载器是JVM执行类加载机制的前提。简单来说，类加载器的主要任务就是根据一个类的全限定名来读取此类的二进制字节流到JVM内部，然后转换为一个与目标类对应的java.lang.Class对象实例。类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来，但如今类加载器却在OSGi、字节码加解密领域大放异彩。这主要归功于Java虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在JVM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="jvm" scheme="https://mirsery.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Springboot常用注解</title>
    <link href="https://mirsery.github.io/2022/01/09/java/2022/springBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://mirsery.github.io/2022/01/09/java/2022/springBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-01-09T15:00:03.000Z</published>
    <updated>2022-01-09T15:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1springboot-spring">1.SpringBoot/spring</a></li><li><a href="#2jpa">2.Jpa</a></li><li><a href="#3------">3.全局异常处理</a></li><li><a href="#4springcloud">4.springcloud</a></li></ul><!-- tocstop --><h2 id="1-SpringBoot-spring"><a href="#1-SpringBoot-spring" class="headerlink" title="1.SpringBoot/spring"></a>1.SpringBoot/spring</h2><ul><li>@SpringBootApplication:</li></ul><p>包含@Configuration、@EnableAutoConfiguration、@ComponentScan通常用在主类上；</p><ul><li>@Repository:</li></ul><p>用于标注数据访问组件，即DAO组件；</p><ul><li>@Service:</li></ul><p>用于标注业务层组件；</p><ul><li>@RestController:</li></ul><p>用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody；</p><ul><li>@Controller:</li></ul><p>用于标注是控制层组件，需要返回页面时请用@Controller而不是@RestController；</p><ul><li>@Component:</li></ul><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注；</p><ul><li>@ResponseBody:</li></ul><p>表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，<br>加上 <strong>@responsebody</strong> 后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中；比如异步获取json数据，加上 <strong>@responsebody</strong> 后，会直接返回json数据；</p><ul><li>@RequestBody:</li></ul><p>参数前加上这个注解之后，认为该参数必填。表示接受json字符串转为对象 List等；</p><ul><li>@ComponentScan:</li></ul><p>组件扫描。个人理解相当于，如果扫描到有 <strong>@Component</strong>  <strong>@Controller</strong> <strong>@Service</strong>等这些注解的类，则把这些类注册为bean*；</p><ul><li>@Configuration:</li></ul><p>指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上；</p><ul><li>@Bean:</li></ul><p>相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理；</p><ul><li>@EnableAutoConfiguration:</li></ul><p>让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上；</p><ul><li>@AutoWired:</li></ul><p>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作；</p><p>当加上（required=false）时，就算找不到bean也不报错；</p><ul><li>@Qualifier:</li></ul><p>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用；</p><ul><li>@Resource(name=”name”,type=”type”)：</li></ul><p>没有括号内内容的话，默认byName。与@Autowired干类似的事；</p><ul><li>@RequestMapping:    </li></ul><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径；</p><p>该注解有六个属性: </p><p>params:指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。  </p><p>value:指定请求的实际地址，指定的地址可以是URI Template 模式  </p><p>method:指定请求的method类型， GET、POST、PUT、DELETE等  </p><p>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;  </p><p>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。</p><p>@GetMapping、@PostMapping等:</p><p>相当于@RequestMapping（value=”/”，method=RequestMethod.Get\Post\Put\Delete等） 。是个组合注解；</p><ul><li>@RequestParam:</li></ul><p>用在方法的参数前面。相当于 request.getParameter()；</p><ul><li>@PathVariable:</li></ul><p>路径变量。如 RequestMapping(“user/get/mac/{macAddress}”) ；</p><p>public String getByMacAddress(<br>@PathVariable(“macAddress”) String macAddress){<br>//do something;<br>}</p><p>参数与大括号里的名字相同的话，注解后括号里的内容可以不填。</p><h2 id="2-Jpa"><a href="#2-Jpa" class="headerlink" title="2.Jpa"></a>2.Jpa</h2><ul><li>@Entity @Table(name=”“):</li></ul><p>表明这是一个实体类。一般用于jpa ，这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略；</p><ul><li>@MappedSuperClass:</li></ul><p>用在确定是父类的entity上。父类的属性子类可以继承；</p><ul><li>@NoRepositoryBean:</li></ul><p>一般用作父类的repository，有这个注解，spring不会去实例化该repository；</p><ul><li>@Column: </li></ul><p>如果字段名与列名相同，则可以省略；</p><ul><li>@Id:</li></ul><p>表示该属性为主键；</p><ul><li>@GeneratedValue(strategy=GenerationType.SEQUENCE,generator = “repair_seq”):</li></ul><p>表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq；</p><ul><li>@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1):</li></ul><p>name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致；</p><ul><li>@Transient:</li></ul><p>表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性. </p><p>如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic；</p><ul><li>@Basic(fetch=FetchType.LAZY):</li></ul><p>标记可以指定实体属性的加载方式；</p><ul><li>@JsonIgnore:</li></ul><p>作用是json序列化时将java bean中的一些属性忽略掉,序列化和反序列化都受影响；</p><ul><li>@JoinColumn(name=”loginId”):</li></ul><p>一对一：本表中指向另一个表的外键。</p><p>一对多：另一个表指向本表的外键。</p><ul><li><p>@OneToOne</p></li><li><p>@OneToMany</p></li><li><p>@ManyToOne:</p></li></ul><p>对应Hibernate配置文件中的一对一，一对多，多对一。</p><h2 id="3-全局异常处理"><a href="#3-全局异常处理" class="headerlink" title="3.全局异常处理"></a>3.全局异常处理</h2><ul><li>@ControllerAdvice:</li></ul><p>包含@Component。可以被扫描到。统一处理异常；</p><ul><li>@ExceptionHandler(Exception.class):</li></ul><p>用在方法上面表示遇到这个异常就执行以下方法。</p><h2 id="4-springcloud"><a href="#4-springcloud" class="headerlink" title="4.springcloud"></a>4.springcloud</h2><ul><li>@EnableEurekaServer:</li></ul><p>用在springboot启动类上，表示这是一个eureka服务注册中心；</p><ul><li>@EnableDiscoveryClient:</li></ul><p>用在springboot启动类上，表示这是一个服务，可以被注册中心找到；</p><ul><li>@LoadBalanced:</li></ul><p>开启负载均衡能力；</p><ul><li>@EnableCircuitBreaker:</li></ul><p>用在启动类上，开启断路器功能；</p><ul><li>@HystrixCommand(fallbackMethod=”backMethod”):</li></ul><p>用在方法上，fallbackMethod指定断路回调方法；</p><ul><li>@EnableConfigServer:</li></ul><p>用在启动类上，表示这是一个配置中心，开启Config Server；</p><ul><li>@EnableZuulProxy:</li></ul><p>开启zuul路由，用在启动类上；</p><ul><li>@SpringCloudApplication:</li></ul><blockquote><p>包含@SpringBootApplication @EnableDiscovertyClient @EnableCircuitBreaker</p></blockquote><p>分别是SpringBoot注解、注册服务中心Eureka注解、断路器注解。对于SpringCloud来说，这是每一微服务必须应有的三个注解，所以才推出了@SpringCloudApplication这一注解集合。</p>]]></content>
    
    
    <summary type="html">Springboot中常用的必须掌握的基础注解合集</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="spring" scheme="https://mirsery.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>java中创建对象的几种方法</title>
    <link href="https://mirsery.github.io/2022/01/09/java/2022/java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://mirsery.github.io/2022/01/09/java/2022/java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2022-01-09T13:38:03.000Z</published>
    <updated>2022-01-09T13:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----------">测试代码，看运行结果</a></li><li><a href="#clone">Clone</a></li></ul><!-- tocstop --><p>常见的对象常见方法有4种：</p><ol><li>使用<strong>new</strong>关键字</li><li>使用<strong>clone</strong>方法</li><li>反射机制</li><li>反序列化</li></ol><p>其中采用1，3新建对象时会调用构造函数，2和4并不会调用构造函数</p><h2 id="测试代码，看运行结果"><a href="#测试代码，看运行结果" class="headerlink" title="测试代码，看运行结果"></a>测试代码，看运行结果</h2><ul><li><p>简单的bean类 Car</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;    <span class="keyword">private</span> String name;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;        <span class="keyword">return</span> <span class="keyword">super</span>.clone();    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;        System.out.println(<span class="string">&quot;create car&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot; is run !&quot;</span>);    &#125;&#125;</code></pre></li><li><p>测试类的Main方法</p></li></ul><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throw Exception </span>&#123;    <span class="comment">//new 关键字创建对象</span>    Car car1 = <span class="keyword">new</span> Car(<span class="string">&quot;mike1&quot;</span>);    car1.run();    System.out.println(<span class="string">&quot;=================&quot;</span>);    <span class="comment">//序列化</span>    ObjectOutput objectOutput = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Car&quot;</span>));    objectOutput.writeObject(car1);    objectOutput.close();    <span class="comment">//</span>    <span class="comment">//clone 创建对象</span>    Car car2 = (Car) car1.clone();    car2.setName(<span class="string">&quot;mike2&quot;</span>);    car2.run();    System.out.println(<span class="string">&quot;=================&quot;</span>);    <span class="comment">//反射创建对象</span>    Class carClass = Class.forName(Car.class.getName());    Object obj = carClass.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class&#125;).newInstance(<span class="string">&quot;mike3&quot;</span>);    Method method = obj.getClass().getMethod(<span class="string">&quot;run&quot;</span>);    method.invoke(obj);    <span class="comment">// Car car3 = (Car) carClass.getDeclaredConstructor(new Class[]&#123;String.class&#125;).newInstance(&quot;mike3&quot;);</span>    <span class="comment">// car3.run();</span>    System.out.println(<span class="string">&quot;=================&quot;</span>);    <span class="comment">//反序列化创建对象</span>    ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;Car&quot;</span>));    Car car4 = (Car) inputStream.readObject();    car4.setName(<span class="string">&quot;mike4&quot;</span>);    car4.run();&#125;</code></pre><p>下面是测试代码输出结果</p><pre><code class="highlight plaintext">create carmike1 is run !=================mike2 is run !=================create carmike3 is run !=================mike4 is run !</code></pre><p>从结果中可以得出最直接的结论，Clone和反序列化都没有执行类的构造函数。</p><h2 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h2><p>clone拷贝对象返回的是一个新的对象，而不是一个对象的引用地址；拷贝对象已经包含原来对象的信息，而不是对象的初始信息，即每次拷贝动作不是针对一个全新对象的创建。</p><p>利用clone，在内存中进行数据块的拷贝，复制已有的对象，也是生成对象的一种方式。前提是类实现Cloneable接口，Cloneable接口没有任何方法，是一个空接口，也可以称这样的接口为标志接口，只有实现了该接口，才会支持clone操作。有的人也许会问了，java中的对象都有一个默认的父类Object。<br>Object中有一个clone方法，为什么还必须要实现Cloneable接口呢，这就是cloneable接口这个标志接口的意义，只有实现了这个接口才能实现复制操作，因为jvm在复制对象的时候，会检查对象的类是否实现了Cloneable这个接口，如果没有实现，则会报CloneNotSupportedException异常。类似这样的接口还有Serializable接口、RandomAccess接口等。<br>还有值得一提的是在执行clone操作的时候，不会调用构造函数。</p>]]></content>
    
    
    <summary type="html">常见的对象常见方法有4种：使用new关键字/使用clone方法/反射机制/反序列化</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="jvm" scheme="https://mirsery.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>vue模板的使用</title>
    <link href="https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-07T04:37:38.000Z</published>
    <updated>2022-01-07T04:37:38.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#vue--api--">vue社区api描述</a></li><li><a href="#--------">组件的使用和创建</a></li></ul><!-- tocstop --><p>在前端项目中经常会遇到需要动态渲染页面的功能，一般情况下我们可以采用原生的js进行手动的插入和编写。在vue项目中可以借用vue提供的方法进行模版渲染。<br>在vue3中可以采用component组件进行动态渲染，vue2中则可以采用extend来实现。本文基于vue2来展示动态渲染示例。</p><h2 id="vue社区api描述"><a href="#vue社区api描述" class="headerlink" title="vue社区api描述"></a>vue社区api描述</h2><p>Vue.extend( options )</p><ul><li>参数<ul><li>{Object} options</li></ul></li><li>用法<br> 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</li></ul><p><strong>data</strong> 选项是特例，需要注意 - 在 <strong>Vue.extend()</strong> 中它必须是函数</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mount-point&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><pre><code class="highlight js"><span class="comment">// 创建构造器</span><span class="keyword">var</span> Profile = Vue.extend(&#123;  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&#x27;</span>,  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> &#123;      <span class="attr">firstName</span>: <span class="string">&#x27;Walter&#x27;</span>,      <span class="attr">lastName</span>: <span class="string">&#x27;White&#x27;</span>,      <span class="attr">alias</span>: <span class="string">&#x27;Heisenberg&#x27;</span>    &#125;  &#125;&#125;)<span class="comment">// 创建 Profile 实例，并挂载到一个元素上。</span><span class="keyword">new</span> Profile().$mount(<span class="string">&#x27;#mount-point&#x27;</span>)</code></pre><p>结果如下：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Walter White aka Heisenberg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre><h2 id="组件的使用和创建"><a href="#组件的使用和创建" class="headerlink" title="组件的使用和创建"></a>组件的使用和创建</h2><ul><li>基本示例</li></ul><pre><code class="highlight js"><span class="comment">// 定义一个名为 button-counter 的新组件</span>Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> &#123;      <span class="attr">count</span>: <span class="number">0</span>    &#125;  &#125;,  <span class="attr">template</span>: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span>&#125;)</code></pre><p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 **<button-counter>**。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><pre><code class="highlight js"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">&#x27;#components-demo&#x27;</span> &#125;)</code></pre><p>因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。</p>]]></content>
    
    
    <summary type="html">vuejs中使用模版渲染的示例</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://mirsery.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>新增配置webstorm和vscode支持vue别名的识别</title>
    <link href="https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AEwebstorm%E5%92%8Cvscode%E6%94%AF%E6%8C%81vue%E5%88%AB%E5%90%8D%E7%9A%84%E8%AF%86%E5%88%AB/"/>
    <id>https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AEwebstorm%E5%92%8Cvscode%E6%94%AF%E6%8C%81vue%E5%88%AB%E5%90%8D%E7%9A%84%E8%AF%86%E5%88%AB/</id>
    <published>2022-01-07T01:08:33.000Z</published>
    <updated>2022-01-07T01:08:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#vue3------">vue3项目设置别名</a></li><li><a href="#-webstorm------">为webstorm配置别名识别</a></li><li><a href="#-vscode------">为vscode配置别名识别</a></li></ul><!-- tocstop --><p>vue3项目中，默认别名”@”为”src”路径。在开发的过程中我们的集成开发环境并不能很好的识别这个别名路径，导致我们不能在开发环境中实现代码依赖的跳转，影响我们的开发体验以及开发速率.</p><h2 id="vue3项目设置别名"><a href="#vue3项目设置别名" class="headerlink" title="vue3项目设置别名"></a>vue3项目设置别名</h2><p>vue项目设置别名可以在vue.config.js中进行配置</p><pre><code class="highlight js"><span class="built_in">module</span>.exports = &#123;    <span class="attr">configureWebpack</span>: &#123;        <span class="attr">resolve</span>: &#123;            <span class="attr">alias</span>: &#123;                <span class="string">&#x27;@&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>),            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="为webstorm配置别名识别"><a href="#为webstorm配置别名识别" class="headerlink" title="为webstorm配置别名识别"></a>为webstorm配置别名识别</h2><p>在项目根目录创建<strong>websotrm.config.js</strong>文件，内容大致如下所示:</p><pre><code class="highlight js"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)<span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;    <span class="keyword">return</span> path.join(__dirname, <span class="string">&#x27;.&#x27;</span>, dir)&#125;<span class="built_in">module</span>.exports = &#123;    <span class="attr">context</span>:path.resolve(__dirname,<span class="string">&#x27;./&#x27;</span>),    <span class="attr">resolve</span>: &#123;        <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],        <span class="attr">alias</span>: &#123;            <span class="string">&#x27;@&#x27;</span>: resolve(<span class="string">&#x27;src&#x27;</span>)        &#125;    &#125;&#125;</code></pre><p>在webstorm中，选择Preferences &gt; Languages &amp; Feameworks &gt; JavaScript &gt; WebPack ,选择 resolution 的mode，选择Automatically即可。</p><h2 id="为vscode配置别名识别"><a href="#为vscode配置别名识别" class="headerlink" title="为vscode配置别名识别"></a>为vscode配置别名识别</h2><p>在项目根目录创建<strong>jsconfig.json</strong>文件，内容大致如下所示:</p><pre><code class="highlight json">&#123;  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>,    <span class="attr">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,    <span class="attr">&quot;paths&quot;</span>: &#123;      <span class="attr">&quot;@/*&quot;</span>: [        <span class="string">&quot;./src/*&quot;</span>      ]    &#125;  &#125;,  <span class="attr">&quot;exclude&quot;</span>: [    <span class="string">&quot;node_modules&quot;</span>,    <span class="string">&quot;dist&quot;</span>  ]&#125;</code></pre><p>关闭vscode，重新打开项目，vscode即可实现对别名的识别。</p>]]></content>
    
    
    <summary type="html">vue项目中增加配置文件，使得开发环境可以识别自定义的vue别名能够实现代码跳转</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://mirsery.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>前端包管理私服搭建</title>
    <link href="https://mirsery.github.io/2021/12/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/"/>
    <id>https://mirsery.github.io/2021/12/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/</id>
    <published>2021-12-17T08:01:56.000Z</published>
    <updated>2021-12-17T08:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--dokcer----verdaccio">使用dokcer容器运行verdaccio</a></li><li><a href="#verdaccio--">verdaccio配置</a></li><li><a href="#----">创建用户</a></li></ul><!-- tocstop --><p>verdaccio 是一个简单的，零配置本地私有npm软件包代理注册表。verdaccio开箱即用，拥有自己的小型数据库，能够代理其他注册表（例如npmjs.org)，缓存下载的模块。</p><p><a href="https://github.com/verdaccio/verdaccio">verdaccio项目地址</a></p><h2 id="使用dokcer容器运行verdaccio"><a href="#使用dokcer容器运行verdaccio" class="headerlink" title="使用dokcer容器运行verdaccio"></a>使用dokcer容器运行verdaccio</h2><p><a href="https://hub.docker.com/r/verdaccio/verdaccio">verdaccio docker 仓库地址 </a></p><pre><code class="highlight shell">docker run --restart=always --name verdaccio --privileged=true -v /&#123;location&#125;:/verdaccio -p 4873:4873 -d verdaccio/verdaccio</code></pre><h2 id="verdaccio配置"><a href="#verdaccio配置" class="headerlink" title="verdaccio配置"></a>verdaccio配置</h2><blockquote><p>容器内 /verdaccio/conf  配置文件</p></blockquote><pre><code class="highlight yaml"><span class="comment">#</span><span class="comment"># This is the config file used for the docker images.</span><span class="comment"># It allows all users to do anything, so don&#x27;t use it on production systems.</span><span class="comment">#</span><span class="comment"># Do not configure host and port under `listen` in this file</span><span class="comment"># as it will be ignored when using docker.</span><span class="comment"># see https://verdaccio.org/docs/en/docker#docker-and-custom-port-configuration</span><span class="comment">#</span><span class="comment"># Look here for more config file examples:</span><span class="comment"># https://github.com/verdaccio/verdaccio/tree/master/conf</span><span class="comment">#</span><span class="comment"># path to a directory with all packages</span><span class="attr">storage:</span> <span class="string">/verdaccio/storage/data</span><span class="comment"># path to a directory with plugins to include</span><span class="attr">plugins:</span> <span class="string">/verdaccio/plugins</span><span class="attr">web:</span>  <span class="comment"># WebUI is enabled as default, if you want disable it, just uncomment this line</span>  <span class="comment">#enable: false</span>  <span class="attr">title:</span> <span class="string">Verdaccio</span>  <span class="comment"># comment out to disable gravatar support</span>  <span class="comment"># gravatar: false</span>  <span class="comment"># by default packages are ordercer ascendant (asc|desc)</span>  <span class="comment"># sort_packages: asc</span>  <span class="comment"># darkMode: true</span>  <span class="comment"># logo: http://somedomain/somelogo.png</span>  <span class="comment"># favicon: http://somedomain/favicon.ico | /path/favicon.ico</span><span class="comment"># translate your registry, api i18n not available yet</span><span class="comment"># i18n:</span><span class="comment"># list of the available translations https://github.com/verdaccio/ui/tree/master/i18n/translations</span><span class="comment">#   web: en-US</span><span class="attr">auth:</span>  <span class="attr">htpasswd:</span>    <span class="attr">file:</span> <span class="string">/verdaccio/storage/htpasswd</span>    <span class="comment"># Maximum amount of users allowed to register, defaults to &quot;+infinity&quot;.</span>    <span class="comment"># You can set this to -1 to disable registration.</span>    <span class="comment"># max_users: 1000</span><span class="comment"># a list of other known repositories we can talk to</span><span class="attr">uplinks:</span>  <span class="attr">taobao:</span>    <span class="attr">url:</span> <span class="string">https://registry.npm.taobao.org/</span>  <span class="attr">npmjs:</span>    <span class="attr">url:</span> <span class="string">https://registry.npmjs.org/</span><span class="attr">packages:</span>  <span class="string">&#x27;@*/*&#x27;</span><span class="string">:</span>    <span class="comment"># scoped packages</span>    <span class="attr">access:</span> <span class="string">$all</span>    <span class="attr">publish:</span> <span class="string">$authenticated</span>    <span class="attr">unpublish:</span> <span class="string">$authenticated</span>    <span class="attr">proxy:</span> <span class="string">taobao</span>  <span class="string">&#x27;**&#x27;</span><span class="string">:</span>    <span class="comment"># allow all users (including non-authenticated users) to read and</span>    <span class="comment"># publish all packages</span>    <span class="comment">#</span>    <span class="comment"># you can specify usernames/groupnames (depending on your auth plugin)</span>    <span class="comment"># and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;</span>    <span class="attr">access:</span> <span class="string">$all</span>    <span class="comment"># allow all known users to publish/publish packages</span>    <span class="comment"># (anyone can register by default, remember?)</span>    <span class="attr">publish:</span> <span class="string">$authenticated</span>    <span class="attr">unpublish:</span> <span class="string">$authenticated</span>    <span class="comment"># if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry</span>    <span class="attr">proxy:</span> <span class="string">taobao</span><span class="comment"># You can specify HTTP/1.1 server keep alive timeout in seconds for incoming connections.</span><span class="comment"># A value of 0 makes the http server behave similarly to Node.js versions prior to 8.0.0, which did not have a keep-alive timeout.</span><span class="comment"># WORKAROUND: Through given configuration you can workaround following issue https://github.com/verdaccio/verdaccio/issues/301. Set to 0 in case 60 is not enough.</span><span class="attr">server:</span>  <span class="attr">keepAliveTimeout:</span> <span class="number">60</span><span class="attr">middlewares:</span>  <span class="attr">audit:</span>    <span class="attr">enabled:</span> <span class="literal">true</span><span class="comment"># log settings</span><span class="attr">logs:</span> &#123; <span class="attr">type:</span> <span class="string">stdout</span>, <span class="attr">format:</span> <span class="string">pretty</span>, <span class="attr">level:</span> <span class="string">http</span> &#125;<span class="comment">#experiments:</span><span class="comment">#  # support for npm token command</span><span class="comment">#  token: false</span><span class="comment">#  # enable tarball URL redirect for hosting tarball with a different server, the tarball_url_redirect can be a template string</span><span class="comment">#  tarball_url_redirect: &#x27;https://mycdn.com/verdaccio/$&#123;packageName&#125;/$&#123;filename&#125;&#x27;</span><span class="comment">#  # the tarball_url_redirect can be a function, takes packageName and filename and returns the url, when working with a js configuration file</span><span class="comment">#  tarball_url_redirect(packageName, filename) &#123;</span><span class="comment">#    const signedUrl = // generate a signed url</span><span class="comment">#    return signedUrl;</span><span class="comment">#  &#125;</span><span class="comment"># This affect the web and api (not developed yet)</span><span class="comment">#i18n:</span><span class="comment">#web: en-US</span></code></pre><p>上面是一些默认配置，我们可以简单的进行一些个性化的修改。</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>在容器内执行如下命令:</p><pre><code class="highlight shell">npm adduser --registry http://localhost:4873 # 该地址为登录地址</code></pre><p>接着输入用户名和密码以及邮箱完成注册，完成注册之后可以登录web页面查看信息。</p>]]></content>
    
    
    <summary type="html">利用verdaccio搭建私有npm源</summary>
    
    
    
    
  </entry>
  
</feed>

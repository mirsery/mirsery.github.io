<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mirsery</title>
  
  <subtitle>兴趣使然博客</subtitle>
  <link href="https://mirsery.github.io/atom.xml" rel="self"/>
  
  <link href="https://mirsery.github.io/"/>
  <updated>2022-08-31T04:59:08.000Z</updated>
  <id>https://mirsery.github.io/</id>
  
  <author>
    <name>mirsery</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>配置oh-my-posh</title>
    <link href="https://mirsery.github.io/2022/08/31/talk/2022/%E9%85%8D%E7%BD%AEoh-my-posh/"/>
    <id>https://mirsery.github.io/2022/08/31/talk/2022/%E9%85%8D%E7%BD%AEoh-my-posh/</id>
    <published>2022-08-31T04:59:08.000Z</published>
    <updated>2022-08-31T04:59:08.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----oh-my-posh">下载安装oh-my-posh</a></li><li><a href="#---------">下载并预览主题文件</a></li><li><a href="#--">主题</a><ul><li><a href="#--------">新建主题保存目录</a></li><li><a href="#------">修改应用主题</a></li></ul></li></ul><!-- tocstop --><h2 id="下载安装oh-my-posh"><a href="#下载安装oh-my-posh" class="headerlink" title="下载安装oh-my-posh"></a>下载安装oh-my-posh</h2><ul><li>window平台</li></ul><pre><code class="highlight shell">scoop install oh-my-posh</code></pre><ul><li>macos</li></ul><pre><code class="highlight shell">brew install oh-my-posh</code></pre><h2 id="下载并预览主题文件"><a href="#下载并预览主题文件" class="headerlink" title="下载并预览主题文件"></a>下载并预览主题文件</h2><p><a href="https://ohmyposh.dev/docs/themes">主题预览地址https://ohmyposh.dev/docs/themes</a> ，点击即可预览相关的主题文件。</p><p><a href="https://github.com/JanDeDobbeleer/oh-my-posh/tree/main/themes">主题下载地址https://github.com/JanDeDobbeleer/oh-my-posh/tree/main/themes</a>点击可以下载对应预览页面的主题文件</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><h3 id="新建主题保存目录"><a href="#新建主题保存目录" class="headerlink" title="新建主题保存目录"></a>新建主题保存目录</h3><ul><li><p>window平台<br>创建文件</p><pre><code class="highlight shell">oh-my-posh init pwsh | Invoke-Expression</code></pre><p>在terminal中执行如下指令:</p><pre><code class="highlight shell">notepad $profile</code></pre><p>在文件中添加如下代码:</p><pre><code class="highlight plaintext">oh-my-posh --init --shell pwsh --config 主题路径 | Invoke-ExpressionSet-PoshPrompt -Theme 主题名</code></pre></li><li><p>linux和mac os平台</p><ul><li>bash<br>  Bash 的配置文件一般是<del>/.bashrc 或者</del>/.profile  <pre><code class="highlight shell">eval &quot;$(oh-my-posh --init --shell bash --config 主题路径)&quot;</code></pre></li><li>zsh<br>  Zsh 的配置文件为~/.zshrc  <pre><code class="highlight shell">eval &quot;$(oh-my-posh --init --shell zsh --config 主题路径)&quot;</code></pre></li></ul></li></ul><h3 id="修改应用主题"><a href="#修改应用主题" class="headerlink" title="修改应用主题"></a>修改应用主题</h3><p>windows下面可以执行<strong>Get-PoshThemes</strong>查看主题保存的路径，并根据提示可以修改应用相关的主题</p><pre><code class="highlight shell">oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH/jandedobbeleer.omp.json&quot; | Invoke-Expression</code></pre><p>其他的操作系统参考上一小节</p>]]></content>
    
    
    <summary type="html">全平台通用神器oh-my-posh 美化终端..</summary>
    
    
    
    <category term="装机必备" scheme="https://mirsery.github.io/categories/%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"/>
    
    
    <category term="shell" scheme="https://mirsery.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>win11使用git的小问题</title>
    <link href="https://mirsery.github.io/2022/08/31/git/win11%E4%BD%BF%E7%94%A8git%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://mirsery.github.io/2022/08/31/git/win11%E4%BD%BF%E7%94%A8git%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-31T02:49:40.000Z</published>
    <updated>2022-08-31T02:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----">解决问题</a></li></ul><!-- tocstop --><p>参考资料<a href="https://brendanforster.com/notes/fixing-invalid-git-paths-on-windows/">invalid-git-paths-on-windows/</a></p><p>近期换了笔记本，win11的操作系统。在使用git的时候突然发现了一个问题，在下载项目的时候报了一个比较奇怪的错误，错误内容如下所示：</p><pre><code class="highlight plaintext">error: invalid path &#x27;....*******......&#x27;</code></pre><p>类似这种路径不合法的错误，一开始我在远程仓库修改文件的名称，但是于事无补。</p><p>其他的电脑访问这个仓库没有任何异常。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>一开始我以为是git版本的问题，随即就更新了git的版本</p><pre><code class="highlight shell">scoop update git</code></pre><p>但是更新完成之后错误依然在。查了下资料发现是由于ntfs格式的保护原因，关闭ntfs的保护即可解决问题</p><pre><code class="highlight shell">git global config core.protectNTFS false</code></pre>]]></content>
    
    
    <summary type="html">mac电脑切换win11 git 遇到的一些奇怪的问题...</summary>
    
    
    
    <category term="随笔" scheme="https://mirsery.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="git" scheme="https://mirsery.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务的查看和清除</title>
    <link href="https://mirsery.github.io/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%B8%85%E9%99%A4/"/>
    <id>https://mirsery.github.io/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%B8%85%E9%99%A4/</id>
    <published>2022-07-16T09:03:53.000Z</published>
    <updated>2022-07-16T09:03:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--------">查看当前打开的表</a></li><li><a href="#-------------">查看当前的线程数和表的关系</a></li><li><a href="#---------">查看正在执行的事务</a></li><li><a href="#----">结束连接</a></li><li><a href="#--------">查看正在锁的事务</a></li><li><a href="#----------">查看正在等待锁的事务</a></li><li><a href="#-----------">查看当前运行的现成列表</a></li></ul><!-- tocstop --><h2 id="查看当前打开的表"><a href="#查看当前打开的表" class="headerlink" title="查看当前打开的表"></a>查看当前打开的表</h2><pre><code class="highlight sql"><span class="keyword">show</span> <span class="keyword">open</span> tables;</code></pre><h2 id="查看当前的线程数和表的关系"><a href="#查看当前的线程数和表的关系" class="headerlink" title="查看当前的线程数和表的关系"></a>查看当前的线程数和表的关系</h2><pre><code class="highlight sql"><span class="keyword">show</span> <span class="keyword">OPEN</span> TABLES  <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</code></pre><h2 id="查看正在执行的事务"><a href="#查看正在执行的事务" class="headerlink" title="查看正在执行的事务"></a>查看正在执行的事务</h2><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TRX;</code></pre><p>若<strong>trx_state为LOCK WAIT</strong>或者<strong>trx_rows_locked &gt; 0</strong>均表示有锁的等待</p><h2 id="结束连接"><a href="#结束连接" class="headerlink" title="结束连接"></a>结束连接</h2><pre><code class="highlight sql">kill <span class="operator">&lt;</span>PID<span class="operator">&gt;</span></code></pre><h2 id="查看正在锁的事务"><a href="#查看正在锁的事务" class="headerlink" title="查看正在锁的事务"></a>查看正在锁的事务</h2><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_LOCKS;</code></pre><h2 id="查看正在等待锁的事务"><a href="#查看正在等待锁的事务" class="headerlink" title="查看正在等待锁的事务"></a>查看正在等待锁的事务</h2><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</code></pre><h2 id="查看当前运行的现成列表"><a href="#查看当前运行的现成列表" class="headerlink" title="查看当前运行的现成列表"></a>查看当前运行的现成列表</h2><pre><code class="highlight sql"><span class="keyword">show</span> processlist;<span class="keyword">show</span> <span class="keyword">full</span> processlist;</code></pre>]]></content>
    
    
    <summary type="html">mysql的一些调试指令</summary>
    
    
    
    <category term="mysql" scheme="https://mirsery.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://mirsery.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>xml和properties的读写</title>
    <link href="https://mirsery.github.io/2022/07/14/java/2022/xml%E5%92%8Cproperties%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/"/>
    <id>https://mirsery.github.io/2022/07/14/java/2022/xml%E5%92%8Cproperties%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/</id>
    <published>2022-07-14T14:34:31.000Z</published>
    <updated>2022-07-14T14:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#------">环境路径问题</a></li><li><a href="#xml-----">xml文件的载入</a></li><li><a href="#properties----">properties文件载入</a></li><li><a href="#xml----">xml的序列化</a><ul><li><a href="#properties---">properties序列化</a></li></ul></li></ul><!-- tocstop --><h2 id="环境路径问题"><a href="#环境路径问题" class="headerlink" title="环境路径问题"></a>环境路径问题</h2><p>SpringBoot中我们可以利用<strong>ClassPathResource</strong>类，利用相对路径载入<strong>classPath</strong>路径下的文件配置。</p><h2 id="xml文件的载入"><a href="#xml文件的载入" class="headerlink" title="xml文件的载入"></a>xml文件的载入</h2><pre><code class="highlight java"><span class="comment">/*</span><span class="comment"> * 读入xml文件并序列化成javaBean</span><span class="comment"> */</span>    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> DeviceList <span class="title">getDevice</span><span class="params">()</span> <span class="keyword">throws</span> IOException, JAXBException </span>&#123;        String fileName = <span class="string">&quot;device.xml&quot;</span>;        File file = <span class="keyword">new</span> File(fileName);        InputStream inputStream = <span class="keyword">null</span>;        <span class="keyword">if</span> (!file.exists()) &#123;            inputStream = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;device.xml&quot;</span>).getInputStream();        &#125; <span class="keyword">else</span> &#123;            inputStream = Files.newInputStream(file.toPath());        &#125;        BufferedReader br = <span class="keyword">new</span> BufferedReader(                <span class="keyword">new</span> InputStreamReader(inputStream, StandardCharsets.UTF_8));        StringBuilder buffer = <span class="keyword">new</span> StringBuilder();        String line = <span class="string">&quot;&quot;</span>;        <span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>) &#123;            buffer.append(line);        &#125;        br.close();        Object xmlObject = <span class="keyword">null</span>;        Reader reader = <span class="keyword">null</span>;        JAXBContext context = JAXBContext.newInstance(DeviceList.class);        Unmarshaller unmarshaller = context.createUnmarshaller();        reader = <span class="keyword">new</span> StringReader(buffer.toString());        <span class="comment">//以文件流的方式传入这个string</span>        xmlObject = unmarshaller.unmarshal(reader);        reader.close();        DeviceList deviceList = (DeviceList) xmlObject;        <span class="keyword">return</span> deviceList;    &#125;</code></pre><pre><code class="highlight java"><span class="comment">//child节点类</span><span class="meta">@XmlRootElement(name = &quot;device&quot;)</span><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span> </span>&#123;    <span class="meta">@XmlElement(name = &quot;name&quot;)</span>    <span class="keyword">private</span> String name; <span class="comment">//channelCode</span>    <span class="meta">@XmlElement(name = &quot;deviceNo&quot;)</span>    <span class="keyword">private</span> String deviceNo;    <span class="meta">@XmlElement(name = &quot;address&quot;)</span>    <span class="keyword">private</span> String address;    <span class="meta">@XmlElement(name = &quot;enter&quot;, defaultValue = &quot;0&quot;)</span>    <span class="keyword">private</span> <span class="keyword">int</span> enter;    <span class="meta">@XmlElement(name = &quot;type&quot;, defaultValue = &quot;0&quot;)</span>    <span class="keyword">private</span> <span class="keyword">int</span> type;    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> name;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getDeviceNo</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> deviceNo;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeviceNo</span><span class="params">(String deviceNo)</span> </span>&#123;        <span class="keyword">this</span>.deviceNo = deviceNo;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> address;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;        <span class="keyword">this</span>.address = address;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEnter</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> enter;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnter</span><span class="params">(<span class="keyword">int</span> enter)</span> </span>&#123;        <span class="keyword">this</span>.enter = enter;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> type;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;        <span class="keyword">this</span>.type = type;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="meta">@XmlRootElement(name = &quot;devices&quot;)</span><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceList</span> </span>&#123;    <span class="meta">@XmlElement(name = &quot;device&quot;)</span>    <span class="keyword">private</span> List&lt;Device&gt; deviceList;    <span class="function"><span class="keyword">public</span> List&lt;Device&gt; <span class="title">getDeviceList</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> deviceList;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeviceList</span><span class="params">(List&lt;Device&gt; deviceList)</span> </span>&#123;        <span class="keyword">this</span>.deviceList = deviceList;    &#125;&#125;</code></pre><p>载入的device.xml文件</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">devices</span>&gt;</span>    <span class="tag">&lt;<span class="name">device</span>&gt;</span>        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hilee<span class="tag">&lt;/<span class="name">name</span>&gt;</span>        <span class="tag">&lt;<span class="name">deviceNo</span>&gt;</span>xjxjxjx<span class="tag">&lt;/<span class="name">deviceNo</span>&gt;</span>        <span class="tag">&lt;<span class="name">address</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">address</span>&gt;</span>        <span class="tag">&lt;<span class="name">enter</span>&gt;</span>0<span class="tag">&lt;/<span class="name">enter</span>&gt;</span>         <span class="tag">&lt;<span class="name">type</span>&gt;</span>0<span class="tag">&lt;/<span class="name">type</span>&gt;</span>    <span class="tag">&lt;/<span class="name">device</span>&gt;</span><span class="tag">&lt;/<span class="name">devices</span>&gt;</span></code></pre><h2 id="properties文件载入"><a href="#properties文件载入" class="headerlink" title="properties文件载入"></a>properties文件载入</h2><pre><code class="highlight java"><span class="meta">@Bean</span><span class="function"><span class="keyword">public</span> IccConfig <span class="title">getIccConfig</span><span class="params">()</span> </span>&#123;    <span class="keyword">try</span> &#123;        String fileName = <span class="string">&quot;icc.properties&quot;</span>;        Properties properties = <span class="keyword">new</span> Properties();        File file = <span class="keyword">new</span> File(fileName);        <span class="keyword">if</span> (file.exists()) &#123;            properties.load(Files.newInputStream(file.toPath()));        &#125; <span class="keyword">else</span> &#123;            properties.load(<span class="keyword">new</span> ClassPathResource(fileName).getInputStream());        &#125;        IccConfig icConfig = <span class="keyword">new</span> IccConfig();        icConfig.setHost(properties.getProperty(<span class="string">&quot;host&quot;</span>));        icConfig.setUsername(properties.getProperty(<span class="string">&quot;username&quot;</span>));        icConfig.setPassword(properties.getProperty(<span class="string">&quot;password&quot;</span>));        icConfig.setClientId(properties.getProperty(<span class="string">&quot;clientId&quot;</span>));        icConfig.setClientSecret(properties.getProperty(<span class="string">&quot;clientSecret&quot;</span>));        icConfig.setPwdClientId(properties.getProperty(<span class="string">&quot;pwdClientId&quot;</span>));        icConfig.setPwdClientSecret(properties.getProperty(<span class="string">&quot;pwdClientSecret&quot;</span>));        <span class="keyword">return</span> icConfig;    &#125; <span class="keyword">catch</span> (IOException e) &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IccConfig</span> </span>&#123;    <span class="keyword">private</span> String host;    <span class="keyword">private</span> String clientId;    <span class="keyword">private</span> String clientSecret;    <span class="keyword">private</span> String pwdClientId;    <span class="keyword">private</span> String username;    <span class="keyword">private</span> String pwdClientSecret;    <span class="keyword">private</span> String password;    <span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> host;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHost</span><span class="params">(String host)</span> </span>&#123;        <span class="keyword">this</span>.host = host;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getClientId</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> clientId;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientId</span><span class="params">(String clientId)</span> </span>&#123;        <span class="keyword">this</span>.clientId = clientId;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getClientSecret</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> clientSecret;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientSecret</span><span class="params">(String clientSecret)</span> </span>&#123;        <span class="keyword">this</span>.clientSecret = clientSecret;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getPwdClientId</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> pwdClientId;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwdClientId</span><span class="params">(String pwdClientId)</span> </span>&#123;        <span class="keyword">this</span>.pwdClientId = pwdClientId;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> username;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;        <span class="keyword">this</span>.username = username;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getPwdClientSecret</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> pwdClientSecret;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwdClientSecret</span><span class="params">(String pwdClientSecret)</span> </span>&#123;        <span class="keyword">this</span>.pwdClientSecret = pwdClientSecret;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> password;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;        <span class="keyword">this</span>.password = password;    &#125;&#125;</code></pre><h2 id="xml的序列化"><a href="#xml的序列化" class="headerlink" title="xml的序列化"></a>xml的序列化</h2><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">saveDeviceXML</span><span class="params">(Collection&lt;Device&gt; devices)</span> </span>&#123;        <span class="keyword">try</span> &#123;            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();            Document document = builder.newDocument();            Element element = document.createElement(<span class="string">&quot;devices&quot;</span>);            devices.forEach(item -&gt; &#123;                <span class="keyword">if</span> (<span class="keyword">null</span>!=item.getName() &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(item.getName())) &#123;                    Element device = document.createElement(<span class="string">&quot;device&quot;</span>);                    Element name = document.createElement(<span class="string">&quot;name&quot;</span>);                    Element deviceNo = document.createElement(<span class="string">&quot;deviceNo&quot;</span>);                    Element address = document.createElement(<span class="string">&quot;address&quot;</span>);                    Element enter = document.createElement(<span class="string">&quot;enter&quot;</span>);                    Element type = document.createElement(<span class="string">&quot;type&quot;</span>);                    name.setTextContent(item.getName());                    deviceNo.setTextContent(item.getDeviceNo());                    address.setTextContent(item.getAddress());                    enter.setTextContent(String.valueOf(item.getEnter()));                    type.setTextContent(String.valueOf(item.getType()));                    device.appendChild(name);                    device.appendChild(deviceNo);                    device.appendChild(address);                    device.appendChild(enter);                    device.appendChild(type);                    element.appendChild(device);                &#125;            &#125;);            document.appendChild(element);            TransformerFactory factory = TransformerFactory.newInstance();            Transformer transformer = factory.newTransformer();            document.setXmlStandalone(<span class="keyword">true</span>);            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, <span class="string">&quot;yes&quot;</span>);            String fileName = <span class="string">&quot;device.xml&quot;</span>;            File file = <span class="keyword">new</span> File(fileName);            FileOutputStream outputStream = <span class="keyword">null</span>;            <span class="keyword">if</span> (!file.exists()) &#123;                ClassPathResource pathResource = <span class="keyword">new</span> ClassPathResource(fileName);                outputStream = <span class="keyword">new</span> FileOutputStream(pathResource.getFile());            &#125; <span class="keyword">else</span> &#123;                outputStream = <span class="keyword">new</span> FileOutputStream(file);            &#125;            transformer.transform(<span class="keyword">new</span> DOMSource(document), <span class="keyword">new</span> StreamResult(outputStream));            outputStream.close();        &#125; <span class="keyword">catch</span> (ParserConfigurationException | TransformerException | IOException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);        &#125;    &#125;</code></pre><h3 id="properties序列化"><a href="#properties序列化" class="headerlink" title="properties序列化"></a>properties序列化</h3><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">saveIccProperties</span><span class="params">(IccConfig iccConfig)</span> </span>&#123;        <span class="keyword">try</span> &#123;            Properties properties = <span class="keyword">new</span> Properties();            properties.setProperty(<span class="string">&quot;host&quot;</span>, iccConfig.getClientId());            properties.setProperty(<span class="string">&quot;username&quot;</span>, iccConfig.getClientSecret());            properties.setProperty(<span class="string">&quot;password&quot;</span>, iccConfig.getHost());            properties.setProperty(<span class="string">&quot;clientId&quot;</span>, iccConfig.getUsername());            properties.setProperty(<span class="string">&quot;clientSecret&quot;</span>, iccConfig.getPassword());            properties.setProperty(<span class="string">&quot;pwdClientId&quot;</span>, iccConfig.getPwdClientId());            properties.setProperty(<span class="string">&quot;pwdClientSecret&quot;</span>, iccConfig.getPwdClientSecret());            String fileName = <span class="string">&quot;icc.properties&quot;</span>;            File file = <span class="keyword">new</span> File(fileName);            OutputStream outputStream = <span class="keyword">null</span>;            <span class="keyword">if</span> (!file.exists()) &#123;                ClassPathResource pathResource = <span class="keyword">new</span> ClassPathResource(fileName);                outputStream = <span class="keyword">new</span> FileOutputStream(pathResource.getFile());            &#125; <span class="keyword">else</span> &#123;                outputStream = Files.newOutputStream(file.toPath());            &#125;            properties.store(outputStream, <span class="keyword">null</span>);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">Springboot读写xml和properties的文件</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>前端实现消息声音提醒功能</title>
    <link href="https://mirsery.github.io/2022/06/29/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%A3%B0%E9%9F%B3%E6%8F%90%E9%86%92%E5%8A%9F%E8%83%BD/"/>
    <id>https://mirsery.github.io/2022/06/29/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%A3%B0%E9%9F%B3%E6%8F%90%E9%86%92%E5%8A%9F%E8%83%BD/</id>
    <published>2022-06-29T04:35:04.000Z</published>
    <updated>2022-06-29T04:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#-----">浏览器设置</a></li><li><a href="#----">代码部分</a></li></ul><!-- tocstop --><p>众所周知，由于浏览器的限制，页面并不能直接自动播放声音，需要开启权限。我们在B/S架构中为了实现声音的自动播放需要打开浏览器的限制。</p><h2 id="浏览器设置"><a href="#浏览器设置" class="headerlink" title="浏览器设置"></a>浏览器设置</h2><p>打开<strong>chrome</strong>浏览器，在地址栏输入如下地址:</p><pre><code class="highlight plaintext">chrome://flags/#autoplay-policy</code></pre><p>在下面选项中找到如下配置项:</p><pre><code class="highlight plaintext">Global media controls control Cast start/stop</code></pre><p>修改为<strong>Enable</strong></p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><pre><code class="highlight html"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">preload</span>=<span class="string">&quot;auto|metadata|none&quot;</span> <span class="attr">hidden</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;messageAudio&#x27;</span>&gt;</span>        <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./audio.mp3&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span><span class="javascript"><span class="comment">/*</span></span><span class="comment"><span class="javascript">    </span></span><span class="comment"><span class="javascript">    preload：音频被加载的方式</span></span><span class="comment"><span class="javascript">    hidden：是否隐藏</span></span><span class="comment"><span class="javascript">    controls：展示播放暂停按钮</span></span><span class="comment"><span class="javascript">    </span></span><span class="comment"><span class="javascript">    创建好后通过js实现播放、暂停、停止功能</span></span><span class="comment"><span class="javascript">*/</span></span><span class="javascript">    <span class="keyword">let</span> messageAudio = <span class="built_in">document</span>.getElementById(<span class="string">&quot;messageAudio&quot;</span>); </span><span class="javascript"></span><span class="javascript">    messageAudio.play(); <span class="comment">// 播放</span></span><span class="javascript"></span><span class="javascript">    messageAudio.pause(); messageAudio.currentTime = <span class="number">0</span>; <span class="comment">// 停止</span></span><span class="javascript"></span><span class="javascript">    messageAudio.pause(); <span class="comment">// 暂停</span></span><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>]]></content>
    
    
    <summary type="html">’自动加载音频的播放...‘</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://mirsery.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>序列化和返序列化的应用</title>
    <link href="https://mirsery.github.io/2022/06/27/java/2022/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E8%BF%94%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://mirsery.github.io/2022/06/27/java/2022/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E8%BF%94%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2022-06-27T08:47:34.000Z</published>
    <updated>2022-06-27T08:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#jdk-----------">jdk自带的序列化机制的使用</a></li></ul><!-- tocstop --><h2 id="jdk自带的序列化机制的使用"><a href="#jdk自带的序列化机制的使用" class="headerlink" title="jdk自带的序列化机制的使用"></a>jdk自带的序列化机制的使用</h2><p>实体类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;    <span class="keyword">private</span> String name;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;        System.out.println(<span class="string">&quot;create car&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot; is run !&quot;</span>);    &#125;&#125;</code></pre><p>方法类</p><pre><code class="highlight java"><span class="keyword">import</span> java.io.FileInputStream;<span class="keyword">import</span> java.io.FileOutputStream;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.io.ObjectInput;<span class="keyword">import</span> java.io.ObjectInputStream;<span class="keyword">import</span> java.io.ObjectOutput;<span class="keyword">import</span> java.io.ObjectOutputStream;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.List;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySerialize</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;        List&lt;Car&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();        Car car1 = <span class="keyword">new</span> Car(<span class="string">&quot;bench&quot;</span>);        Car car2 = <span class="keyword">new</span> Car(<span class="string">&quot;BMW&quot;</span>);        Car car3 = <span class="keyword">new</span> Car(<span class="string">&quot;Audi&quot;</span>);        list.add(car1);        list.add(car2);        list.add(car3);        <span class="comment">/**</span><span class="comment">         * 序列化</span><span class="comment">         * **/</span>        ObjectOutput objectOutput = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;cars&quot;</span>));        objectOutput.writeObject(list.toArray());        objectOutput.close();        <span class="comment">/**</span><span class="comment">         * 返序列化</span><span class="comment">         * **/</span>        ObjectInput objectInput = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;cars&quot;</span>));        Object[] car = (Object[]) objectInput.readObject();        ((Car)car[<span class="number">0</span>]).run();    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">jdk自带的序列化和返序列化</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://mirsery.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Springboot应用的Hook配置</title>
    <link href="https://mirsery.github.io/2022/06/27/java/2022/Springboot%E5%BA%94%E7%94%A8%E7%9A%84Hook%E9%85%8D%E7%BD%AE/"/>
    <id>https://mirsery.github.io/2022/06/27/java/2022/Springboot%E5%BA%94%E7%94%A8%E7%9A%84Hook%E9%85%8D%E7%BD%AE/</id>
    <published>2022-06-27T08:08:31.000Z</published>
    <updated>2022-06-27T08:08:31.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#applicationrunner">ApplicationRunner</a></li><li><a href="#commandlinerunner">CommandLineRunner</a></li><li><a href="#-predestroy">@PreDestroy</a></li></ul><!-- tocstop --><h2 id="ApplicationRunner"><a href="#ApplicationRunner" class="headerlink" title="ApplicationRunner"></a>ApplicationRunner</h2><p>实现<strong>ApplicationRunner</strong>接口，并重写run函数，可以实现<strong>springboot</strong>项目启动完成之后的回调</p><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;       <span class="comment">//something to do </span>    &#125;&#125;</code></pre><h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h2><p>实现<strong>CommandLineRunner</strong>接口，并重写run函数，可以实现<strong>springboot</strong>项目启动完成之后的回调</p><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;    &#125;&#125;</code></pre><h2 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h2><p>采用<code>@PreDestroy</code>注释可以实现springboot项目停止之后的钩子回调，运用实例如下所示:</p><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPreDestroy</span> </span>&#123;    <span class="meta">@PreDestroy</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPreDestroy</span><span class="params">()</span> </span>&#123;                &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">Springboot框架的Hook应用</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>亚马逊电子书移除DeDRM</title>
    <link href="https://mirsery.github.io/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/"/>
    <id>https://mirsery.github.io/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/</id>
    <published>2022-06-02T05:47:31.000Z</published>
    <updated>2022-06-02T05:47:31.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--calibre---">安装calibre 软件</a></li><li><a href="#--dedrm-tools--">安装DeDRM_tools插件</a></li><li><a href="#-----">转换电子书</a></li></ul><!-- tocstop --><blockquote><p>前提纪要<br>采用此方法移除Dedrm需要以下的几个前提条件:</p></blockquote><ol><li>一个合法的kindle设备序列号</li><li><a href="https://calibre-ebook.com/">calibre</a> 客户端（本文按照mac版本进行讲解)</li><li><a href="https://github.com/apprenticeharper/DeDRM_tools/releases">DeDRM_tools</a> DRM移除插件</li></ol><h2 id="安装calibre-软件"><a href="#安装calibre-软件" class="headerlink" title="安装calibre 软件"></a>安装calibre 软件</h2><p>这个比较简单，直接傻瓜式点击下载安装即可完成</p><h2 id="安装DeDRM-tools插件"><a href="#安装DeDRM-tools插件" class="headerlink" title="安装DeDRM_tools插件"></a>安装DeDRM_tools插件</h2><p>下载DeDRM_tools插件，并解压。</p><p>点击calibre &gt; Preferences 在首选项中选择插件，如下图:<br><img src="/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/C4D57509-9AFB-4E56-8269-3344686772CC.png"></p><p>选择从文件加载插件,选取刚刚已经解压的<strong>DeDRM_plugin</strong>插件进行安装，安装结束之后在搜索栏搜索该插件，并双击该条目，显示如下：</p><p><img src="/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/78D39828-FAB0-4CB8-9F81-3930725D20F2.png"></p><p>选择<strong>elnk kindle ebooks</strong>条目，新增一个合法的kindle设备序列号，并保存。</p><h2 id="转换电子书"><a href="#转换电子书" class="headerlink" title="转换电子书"></a>转换电子书</h2><p>亚马逊中购买电子书之后，选择<strong>通过电脑下载USB传输</strong>下载格式为<strong>azw3</strong>的电子书， 利用calibre进行电子书格式的转换可以自动移除相关的DRM。</p><p>注：自己移除的DRM电子书不能在网上私自发布仅供自己阅读，尊重版权。移除DRM实属Amazon的kindle客户端阅读起来台拉胯，iBooks中国不提供图书购买服务，不得已而为之，实属无奈。</p>]]></content>
    
    
    <summary type="html">‘移除亚马逊电子书DRM版权保护’</summary>
    
    
    
    <category term="电子书" scheme="https://mirsery.github.io/categories/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
    <category term="kindle" scheme="https://mirsery.github.io/categories/%E7%94%B5%E5%AD%90%E4%B9%A6/kindle/"/>
    
    
    <category term="电子书" scheme="https://mirsery.github.io/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>自定义类加载器加载类</title>
    <link href="https://mirsery.github.io/2022/01/10/java/2022/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%B1%BB/"/>
    <id>https://mirsery.github.io/2022/01/10/java/2022/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%B1%BB/</id>
    <published>2022-01-10T13:44:05.000Z</published>
    <updated>2022-01-10T13:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#-----------">自定义加载器的编码实现</a></li></ul><!-- tocstop --><p>一般情况下在程序中开发人员使用自己编写的自定义加载器来与默认的加载器共同执行类加载任务的情况并不多见。实现一个自定义类加载器是非常简单的，只需要继承抽象类ClassLoader，并重写其findClass()方法即可。</p><h2 id="自定义加载器的编码实现"><a href="#自定义加载器的编码实现" class="headerlink" title="自定义加载器的编码实现"></a>自定义加载器的编码实现</h2><pre><code class="highlight java"><span class="comment">//自定义类加载器 myClassLoader</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;    <span class="keyword">private</span> String codePath;    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String codePath)</span> </span>&#123;        <span class="keyword">this</span>.codePath = codePath;    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;        <span class="keyword">byte</span>[] value = <span class="keyword">null</span>;        BufferedInputStream in = <span class="keyword">null</span>;        <span class="keyword">try</span> &#123;            in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(codePath+name+<span class="string">&quot;.class&quot;</span>));            value = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];            in.read(value);        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;<span class="keyword">finally</span> &#123;            <span class="keyword">try</span> &#123;                in.close();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="keyword">assert</span> value != <span class="keyword">null</span>;        <span class="keyword">return</span> defineClass(<span class="keyword">this</span>.getClass().getPackageName()+<span class="string">&quot;.&quot;</span>+name,value,<span class="number">0</span>,value.length);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;/xxx/xxx/&quot;</span>);        Class carClass  = myClassLoader.loadClass(<span class="string">&quot;Car&quot;</span>);        Object o = carClass.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class&#125;).newInstance(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>&#125;);        Method method = o.getClass().getMethod(<span class="string">&quot;run&quot;</span>);        method.invoke(o);        System.out.println(o.getClass().getClassLoader());                System.out.println(myClassLoader.getClass().getClassLoader());    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">想要在程序中实现一个自定义类加载器是非常简单的，只需要继承抽象类ClassLoader，并重写其findClass()方法即可。在此大家需要注意，尽管Java虚拟机规范将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器，但是从严格意义上来说，由Java开发人员编写的自定义类加载其实并不属于Java体系结构的组成部分，实际上它仅仅只是属于Java运行时程序的一部分而已...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="jvm" scheme="https://mirsery.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>双亲委派模型</title>
    <link href="https://mirsery.github.io/2022/01/10/java/2022/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>https://mirsery.github.io/2022/01/10/java/2022/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-01-10T06:27:39.000Z</published>
    <updated>2022-01-10T06:27:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----">背景知识</a></li><li><a href="#------">双亲委派模型</a></li><li><a href="#--------">破坏双亲委派模型</a></li></ul><!-- tocstop --><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>详细见<a href="../2019/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">类加载器</a> 章节</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的委派机制约定了类加载器的加载机制。按照双亲委派模型的规则，除了启动加载器之外，程序中每一个类加载器都应该有一个超类加载器，比如AppClassLoader的超类加载器就是ExtClassLoader，开发者编写的自定义类加载器的超类就是AppClassLoader.<br>那么当一个类加载器接收到一个类加载任务的时候，它并不会立即展开加载，而是将加载的任务委派给他的超类加载器去执行，每一层的类加载器都采用相同的方式，直至派给最顶层的启动类加载器为止。如果超类加载器无法加载委派给他的类时，便会将类的加载任务退回给他的下一级类加载器去执行加载。<br>使用双亲委派模型的优点就是能够有效地确保一个类的全局唯一性，当程序中出现多个全限定名相同的类时，类加载器在执行加载的时候，始终只会加载其中某一个类，如果通过defindClas()方法进行显示加载则JVM会抛出异常。</p><p>以下是JDK 中双亲委派的实现</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">     * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.  The</span><span class="comment">     * default implementation of this method searches for classes in the</span><span class="comment">     * following order:</span><span class="comment">     *</span><span class="comment">     * &lt;ol&gt;</span><span class="comment">     *</span><span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke &#123;<span class="doctag">@link</span> #findLoadedClass(String)&#125; to check if the class</span><span class="comment">     *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span><span class="comment">     *</span><span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #loadClass(String) loadClass&#125; method</span><span class="comment">     *   on the parent class loader.  If the parent is &#123;<span class="doctag">@code</span> null&#125; the class</span><span class="comment">     *   loader built into the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span><span class="comment">     *</span><span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #findClass(String)&#125; method to find the</span><span class="comment">     *   class.  &lt;/p&gt;&lt;/li&gt;</span><span class="comment">     *</span><span class="comment">     * &lt;/ol&gt;</span><span class="comment">     *</span><span class="comment">     * &lt;p&gt; If the class was found using the above steps, and the</span><span class="comment">     * &#123;<span class="doctag">@code</span> resolve&#125; flag is true, this method will then invoke the &#123;<span class="doctag">@link</span></span><span class="comment">     * #resolveClass(Class)&#125; method on the resulting &#123;<span class="doctag">@code</span> Class&#125; object.</span><span class="comment">     *</span><span class="comment">     * &lt;p&gt; Subclasses of &#123;<span class="doctag">@code</span> ClassLoader&#125; are encouraged to override &#123;<span class="doctag">@link</span></span><span class="comment">     * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span><span class="comment">     *</span><span class="comment">     * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span><span class="comment">     * &#123;<span class="doctag">@link</span> #getClassLoadingLock getClassLoadingLock&#125; method</span><span class="comment">     * during the entire class loading process.</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span>   name</span><span class="comment">     *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span>   resolve</span><span class="comment">     *          If &#123;<span class="doctag">@code</span> true&#125; then resolve the class</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@return</span>  The resulting &#123;<span class="doctag">@code</span> Class&#125; object</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@throws</span>  ClassNotFoundException</span><span class="comment">     *          If the class could not be found</span><span class="comment">*/</span><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)        <span class="keyword">throws</span> ClassNotFoundException    &#123;        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;            <span class="comment">// First, check if the class has already been loaded</span>            Class&lt;?&gt; c = findLoadedClass(name);            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;                <span class="keyword">long</span> t0 = System.nanoTime();                <span class="keyword">try</span> &#123;                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;                        c = parent.loadClass(name, <span class="keyword">false</span>);                    &#125; <span class="keyword">else</span> &#123;                        c = findBootstrapClassOrNull(name);                    &#125;                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;                    <span class="comment">// ClassNotFoundException thrown if class not found</span>                    <span class="comment">// from the non-null parent class loader</span>                &#125;                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;                    <span class="comment">// If still not found, then invoke findClass in order</span>                    <span class="comment">// to find the class.</span>                    <span class="keyword">long</span> t1 = System.nanoTime();                    c = findClass(name);                    <span class="comment">// this is the defining class loader; record the stats</span>                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                    PerfCounter.getFindClasses().increment();                &#125;            &#125;            <span class="keyword">if</span> (resolve) &#123;                resolveClass(c);            &#125;            <span class="keyword">return</span> c;        &#125;    &#125;</code></pre><p>在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派机制有一定的区别，当缺省的类加载器接收到到一个类的加载任务时，他首先会自行加载，当它加载失败时，才会将类的加载任务委派给他的超类加载器去执行，这也是servlet规范推荐的一种做法。</p><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>JDk种破坏双亲委派模型</p><ul><li><p>JDK1.0<br>java.lang.ClassLoader 提供了loadClass() 方法，继承ClassLoader类，重写loadClass()方法</p></li><li><p>SPI<br>一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，<br>它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。</p></li></ul><p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。<br>这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<br>有了线程上下文加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。</p><p>Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p><ul><li><p>OSGi<br>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。<br>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。<br>在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。<br>当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：<br>1）将java.＊开头的类委派给父类加载器加载。<br>2）否则，将委派列表名单内的类委派给父类加载器加载。<br>3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。<br>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。<br>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。<br>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。<br>7）否则，类加载器失败</p></li><li><p>JKD9模块系统<br>模块化加载源码片段</p><pre><code class="highlight java">Class&lt;?&gt; c = findLoadedClass(cn);      <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;         <span class="comment">// 找到当前类属于哪个模块</span>         LoadedModule loadedModule = findLoadedModule(cn);         <span class="keyword">if</span> (loadedModule != <span class="keyword">null</span>) &#123;            <span class="comment">//获取当前模块的类加载器</span>            BuiltinClassLoader loader = loadedModule.loader();            <span class="comment">//进行类加载</span>            c = findClassInModuleOrNull(loadedModule, cn);         &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 找不到模块信息才会进行双亲委派</span>         <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;           c = parent.loadClassOrNull(cn);         &#125;       &#125;</code></pre></li></ul><p>整个JDK都基于模块化进行构建，以前的rt.jar, tool.jar被拆分成数十个模块，编译的时候只编译实际用到的模块，同时各个类加载器各司其职，只加载自己负责的模块。</p><p>经过破坏后的双亲委派模型更加高效，减少了很多类加载器之间不必要的委派操作<br>JDK9的模块化可以减少Java程序打包的体积，同时拥有更好的隔离线与封装性<br>每个moudle拥有专属的类加载器，程序在并发性上也会更加出色。</p>]]></content>
    
    
    <summary type="html">类加载器是JVM执行类加载机制的前提。简单来说，类加载器的主要任务就是根据一个类的全限定名来读取此类的二进制字节流到JVM内部，然后转换为一个与目标类对应的java.lang.Class对象实例。类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来，但如今类加载器却在OSGi、字节码加解密领域大放异彩。这主要归功于Java虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在JVM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="jvm" scheme="https://mirsery.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Springboot常用注解</title>
    <link href="https://mirsery.github.io/2022/01/09/java/2022/springBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://mirsery.github.io/2022/01/09/java/2022/springBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-01-09T15:00:03.000Z</published>
    <updated>2022-01-09T15:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1springboot-spring">1.SpringBoot/spring</a></li><li><a href="#2jpa">2.Jpa</a></li><li><a href="#3------">3.全局异常处理</a></li><li><a href="#4springcloud">4.springcloud</a></li></ul><!-- tocstop --><h2 id="1-SpringBoot-spring"><a href="#1-SpringBoot-spring" class="headerlink" title="1.SpringBoot/spring"></a>1.SpringBoot/spring</h2><ul><li>@SpringBootApplication:</li></ul><p>包含@Configuration、@EnableAutoConfiguration、@ComponentScan通常用在主类上；</p><ul><li>@Repository:</li></ul><p>用于标注数据访问组件，即DAO组件；</p><ul><li>@Service:</li></ul><p>用于标注业务层组件；</p><ul><li>@RestController:</li></ul><p>用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody；</p><ul><li>@Controller:</li></ul><p>用于标注是控制层组件，需要返回页面时请用@Controller而不是@RestController；</p><ul><li>@Component:</li></ul><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注；</p><ul><li>@ResponseBody:</li></ul><p>表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，<br>加上 <strong>@responsebody</strong> 后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中；比如异步获取json数据，加上 <strong>@responsebody</strong> 后，会直接返回json数据；</p><ul><li>@RequestBody:</li></ul><p>参数前加上这个注解之后，认为该参数必填。表示接受json字符串转为对象 List等；</p><ul><li>@ComponentScan:</li></ul><p>组件扫描。个人理解相当于，如果扫描到有 <strong>@Component</strong>  <strong>@Controller</strong> <strong>@Service</strong>等这些注解的类，则把这些类注册为bean*；</p><ul><li>@Configuration:</li></ul><p>指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上；</p><ul><li>@Bean:</li></ul><p>相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理；</p><ul><li>@EnableAutoConfiguration:</li></ul><p>让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上；</p><ul><li>@AutoWired:</li></ul><p>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作；</p><p>当加上（required=false）时，就算找不到bean也不报错；</p><ul><li>@Qualifier:</li></ul><p>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用；</p><ul><li>@Resource(name=”name”,type=”type”)：</li></ul><p>没有括号内内容的话，默认byName。与@Autowired干类似的事；</p><ul><li>@RequestMapping:    </li></ul><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径；</p><p>该注解有六个属性: </p><p>params:指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。  </p><p>value:指定请求的实际地址，指定的地址可以是URI Template 模式  </p><p>method:指定请求的method类型， GET、POST、PUT、DELETE等  </p><p>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;  </p><p>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。</p><p>@GetMapping、@PostMapping等:</p><p>相当于@RequestMapping（value=”/”，method=RequestMethod.Get\Post\Put\Delete等） 。是个组合注解；</p><ul><li>@RequestParam:</li></ul><p>用在方法的参数前面。相当于 request.getParameter()；</p><ul><li>@PathVariable:</li></ul><p>路径变量。如 RequestMapping(“user/get/mac/{macAddress}”) ；</p><p>public String getByMacAddress(<br>@PathVariable(“macAddress”) String macAddress){<br>//do something;<br>}</p><p>参数与大括号里的名字相同的话，注解后括号里的内容可以不填。</p><h2 id="2-Jpa"><a href="#2-Jpa" class="headerlink" title="2.Jpa"></a>2.Jpa</h2><ul><li>@Entity @Table(name=”“):</li></ul><p>表明这是一个实体类。一般用于jpa ，这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略；</p><ul><li>@MappedSuperClass:</li></ul><p>用在确定是父类的entity上。父类的属性子类可以继承；</p><ul><li>@NoRepositoryBean:</li></ul><p>一般用作父类的repository，有这个注解，spring不会去实例化该repository；</p><ul><li>@Column: </li></ul><p>如果字段名与列名相同，则可以省略；</p><ul><li>@Id:</li></ul><p>表示该属性为主键；</p><ul><li>@GeneratedValue(strategy=GenerationType.SEQUENCE,generator = “repair_seq”):</li></ul><p>表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq；</p><ul><li>@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1):</li></ul><p>name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致；</p><ul><li>@Transient:</li></ul><p>表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性. </p><p>如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic；</p><ul><li>@Basic(fetch=FetchType.LAZY):</li></ul><p>标记可以指定实体属性的加载方式；</p><ul><li>@JsonIgnore:</li></ul><p>作用是json序列化时将java bean中的一些属性忽略掉,序列化和反序列化都受影响；</p><ul><li>@JoinColumn(name=”loginId”):</li></ul><p>一对一：本表中指向另一个表的外键。</p><p>一对多：另一个表指向本表的外键。</p><ul><li><p>@OneToOne</p></li><li><p>@OneToMany</p></li><li><p>@ManyToOne:</p></li></ul><p>对应Hibernate配置文件中的一对一，一对多，多对一。</p><h2 id="3-全局异常处理"><a href="#3-全局异常处理" class="headerlink" title="3.全局异常处理"></a>3.全局异常处理</h2><ul><li>@ControllerAdvice:</li></ul><p>包含@Component。可以被扫描到。统一处理异常；</p><ul><li>@ExceptionHandler(Exception.class):</li></ul><p>用在方法上面表示遇到这个异常就执行以下方法。</p><h2 id="4-springcloud"><a href="#4-springcloud" class="headerlink" title="4.springcloud"></a>4.springcloud</h2><ul><li>@EnableEurekaServer:</li></ul><p>用在springboot启动类上，表示这是一个eureka服务注册中心；</p><ul><li>@EnableDiscoveryClient:</li></ul><p>用在springboot启动类上，表示这是一个服务，可以被注册中心找到；</p><ul><li>@LoadBalanced:</li></ul><p>开启负载均衡能力；</p><ul><li>@EnableCircuitBreaker:</li></ul><p>用在启动类上，开启断路器功能；</p><ul><li>@HystrixCommand(fallbackMethod=”backMethod”):</li></ul><p>用在方法上，fallbackMethod指定断路回调方法；</p><ul><li>@EnableConfigServer:</li></ul><p>用在启动类上，表示这是一个配置中心，开启Config Server；</p><ul><li>@EnableZuulProxy:</li></ul><p>开启zuul路由，用在启动类上；</p><ul><li>@SpringCloudApplication:</li></ul><blockquote><p>包含@SpringBootApplication @EnableDiscovertyClient @EnableCircuitBreaker</p></blockquote><p>分别是SpringBoot注解、注册服务中心Eureka注解、断路器注解。对于SpringCloud来说，这是每一微服务必须应有的三个注解，所以才推出了@SpringCloudApplication这一注解集合。</p>]]></content>
    
    
    <summary type="html">Springboot中常用的必须掌握的基础注解合集</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="spring" scheme="https://mirsery.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>java中创建对象的几种方法</title>
    <link href="https://mirsery.github.io/2022/01/09/java/2022/java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://mirsery.github.io/2022/01/09/java/2022/java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2022-01-09T13:38:03.000Z</published>
    <updated>2022-01-09T13:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----------">测试代码，看运行结果</a></li><li><a href="#clone">Clone</a></li></ul><!-- tocstop --><p>常见的对象常见方法有4种：</p><ol><li>使用<strong>new</strong>关键字</li><li>使用<strong>clone</strong>方法</li><li>反射机制</li><li>反序列化</li></ol><p>其中采用1，3新建对象时会调用构造函数，2和4并不会调用构造函数</p><h2 id="测试代码，看运行结果"><a href="#测试代码，看运行结果" class="headerlink" title="测试代码，看运行结果"></a>测试代码，看运行结果</h2><ul><li><p>简单的bean类 Car</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;    <span class="keyword">private</span> String name;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;        <span class="keyword">return</span> <span class="keyword">super</span>.clone();    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;        System.out.println(<span class="string">&quot;create car&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot; is run !&quot;</span>);    &#125;&#125;</code></pre></li><li><p>测试类的Main方法</p></li></ul><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throw Exception </span>&#123;    <span class="comment">//new 关键字创建对象</span>    Car car1 = <span class="keyword">new</span> Car(<span class="string">&quot;mike1&quot;</span>);    car1.run();    System.out.println(<span class="string">&quot;=================&quot;</span>);    <span class="comment">//序列化</span>    ObjectOutput objectOutput = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Car&quot;</span>));    objectOutput.writeObject(car1);    objectOutput.close();    <span class="comment">//</span>    <span class="comment">//clone 创建对象</span>    Car car2 = (Car) car1.clone();    car2.setName(<span class="string">&quot;mike2&quot;</span>);    car2.run();    System.out.println(<span class="string">&quot;=================&quot;</span>);    <span class="comment">//反射创建对象</span>    Class carClass = Class.forName(Car.class.getName());    Object obj = carClass.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class&#125;).newInstance(<span class="string">&quot;mike3&quot;</span>);    Method method = obj.getClass().getMethod(<span class="string">&quot;run&quot;</span>);    method.invoke(obj);    <span class="comment">// Car car3 = (Car) carClass.getDeclaredConstructor(new Class[]&#123;String.class&#125;).newInstance(&quot;mike3&quot;);</span>    <span class="comment">// car3.run();</span>    System.out.println(<span class="string">&quot;=================&quot;</span>);    <span class="comment">//反序列化创建对象</span>    ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;Car&quot;</span>));    Car car4 = (Car) inputStream.readObject();    car4.setName(<span class="string">&quot;mike4&quot;</span>);    car4.run();&#125;</code></pre><p>下面是测试代码输出结果</p><pre><code class="highlight plaintext">create carmike1 is run !=================mike2 is run !=================create carmike3 is run !=================mike4 is run !</code></pre><p>从结果中可以得出最直接的结论，Clone和反序列化都没有执行类的构造函数。</p><h2 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h2><p>clone拷贝对象返回的是一个新的对象，而不是一个对象的引用地址；拷贝对象已经包含原来对象的信息，而不是对象的初始信息，即每次拷贝动作不是针对一个全新对象的创建。</p><p>利用clone，在内存中进行数据块的拷贝，复制已有的对象，也是生成对象的一种方式。前提是类实现Cloneable接口，Cloneable接口没有任何方法，是一个空接口，也可以称这样的接口为标志接口，只有实现了该接口，才会支持clone操作。有的人也许会问了，java中的对象都有一个默认的父类Object。<br>Object中有一个clone方法，为什么还必须要实现Cloneable接口呢，这就是cloneable接口这个标志接口的意义，只有实现了这个接口才能实现复制操作，因为jvm在复制对象的时候，会检查对象的类是否实现了Cloneable这个接口，如果没有实现，则会报CloneNotSupportedException异常。类似这样的接口还有Serializable接口、RandomAccess接口等。<br>还有值得一提的是在执行clone操作的时候，不会调用构造函数。</p>]]></content>
    
    
    <summary type="html">常见的对象常见方法有4种：使用new关键字/使用clone方法/反射机制/反序列化</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="jvm" scheme="https://mirsery.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>vue模板的使用</title>
    <link href="https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-07T04:37:38.000Z</published>
    <updated>2022-01-07T04:37:38.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#vue--api--">vue社区api描述</a></li><li><a href="#--------">组件的使用和创建</a></li></ul><!-- tocstop --><p>在前端项目中经常会遇到需要动态渲染页面的功能，一般情况下我们可以采用原生的js进行手动的插入和编写。在vue项目中可以借用vue提供的方法进行模版渲染。<br>在vue3中可以采用component组件进行动态渲染，vue2中则可以采用extend来实现。本文基于vue2来展示动态渲染示例。</p><h2 id="vue社区api描述"><a href="#vue社区api描述" class="headerlink" title="vue社区api描述"></a>vue社区api描述</h2><p>Vue.extend( options )</p><ul><li>参数<ul><li>{Object} options</li></ul></li><li>用法<br> 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</li></ul><p><strong>data</strong> 选项是特例，需要注意 - 在 <strong>Vue.extend()</strong> 中它必须是函数</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mount-point&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><pre><code class="highlight js"><span class="comment">// 创建构造器</span><span class="keyword">var</span> Profile = Vue.extend(&#123;  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&#x27;</span>,  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> &#123;      <span class="attr">firstName</span>: <span class="string">&#x27;Walter&#x27;</span>,      <span class="attr">lastName</span>: <span class="string">&#x27;White&#x27;</span>,      <span class="attr">alias</span>: <span class="string">&#x27;Heisenberg&#x27;</span>    &#125;  &#125;&#125;)<span class="comment">// 创建 Profile 实例，并挂载到一个元素上。</span><span class="keyword">new</span> Profile().$mount(<span class="string">&#x27;#mount-point&#x27;</span>)</code></pre><p>结果如下：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Walter White aka Heisenberg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre><h2 id="组件的使用和创建"><a href="#组件的使用和创建" class="headerlink" title="组件的使用和创建"></a>组件的使用和创建</h2><ul><li>基本示例</li></ul><pre><code class="highlight js"><span class="comment">// 定义一个名为 button-counter 的新组件</span>Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> &#123;      <span class="attr">count</span>: <span class="number">0</span>    &#125;  &#125;,  <span class="attr">template</span>: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span>&#125;)</code></pre><p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 **<button-counter>**。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><pre><code class="highlight js"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">&#x27;#components-demo&#x27;</span> &#125;)</code></pre><p>因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。</p>]]></content>
    
    
    <summary type="html">vuejs中使用模版渲染的示例</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://mirsery.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>新增配置webstorm和vscode支持vue别名的识别</title>
    <link href="https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AEwebstorm%E5%92%8Cvscode%E6%94%AF%E6%8C%81vue%E5%88%AB%E5%90%8D%E7%9A%84%E8%AF%86%E5%88%AB/"/>
    <id>https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AEwebstorm%E5%92%8Cvscode%E6%94%AF%E6%8C%81vue%E5%88%AB%E5%90%8D%E7%9A%84%E8%AF%86%E5%88%AB/</id>
    <published>2022-01-07T01:08:33.000Z</published>
    <updated>2022-01-07T01:08:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#vue3------">vue3项目设置别名</a></li><li><a href="#-webstorm------">为webstorm配置别名识别</a></li><li><a href="#-vscode------">为vscode配置别名识别</a></li></ul><!-- tocstop --><p>vue3项目中，默认别名”@”为”src”路径。在开发的过程中我们的集成开发环境并不能很好的识别这个别名路径，导致我们不能在开发环境中实现代码依赖的跳转，影响我们的开发体验以及开发速率.</p><h2 id="vue3项目设置别名"><a href="#vue3项目设置别名" class="headerlink" title="vue3项目设置别名"></a>vue3项目设置别名</h2><p>vue项目设置别名可以在vue.config.js中进行配置</p><pre><code class="highlight js"><span class="built_in">module</span>.exports = &#123;    <span class="attr">configureWebpack</span>: &#123;        <span class="attr">resolve</span>: &#123;            <span class="attr">alias</span>: &#123;                <span class="string">&#x27;@&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>),            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="为webstorm配置别名识别"><a href="#为webstorm配置别名识别" class="headerlink" title="为webstorm配置别名识别"></a>为webstorm配置别名识别</h2><p>在项目根目录创建<strong>websotrm.config.js</strong>文件，内容大致如下所示:</p><pre><code class="highlight js"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)<span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;    <span class="keyword">return</span> path.join(__dirname, <span class="string">&#x27;.&#x27;</span>, dir)&#125;<span class="built_in">module</span>.exports = &#123;    <span class="attr">context</span>:path.resolve(__dirname,<span class="string">&#x27;./&#x27;</span>),    <span class="attr">resolve</span>: &#123;        <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],        <span class="attr">alias</span>: &#123;            <span class="string">&#x27;@&#x27;</span>: resolve(<span class="string">&#x27;src&#x27;</span>)        &#125;    &#125;&#125;</code></pre><p>在webstorm中，选择Preferences &gt; Languages &amp; Feameworks &gt; JavaScript &gt; WebPack ,选择 resolution 的mode，选择Automatically即可。</p><h2 id="为vscode配置别名识别"><a href="#为vscode配置别名识别" class="headerlink" title="为vscode配置别名识别"></a>为vscode配置别名识别</h2><p>在项目根目录创建<strong>jsconfig.json</strong>文件，内容大致如下所示:</p><pre><code class="highlight json">&#123;  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>,    <span class="attr">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,    <span class="attr">&quot;paths&quot;</span>: &#123;      <span class="attr">&quot;@/*&quot;</span>: [        <span class="string">&quot;./src/*&quot;</span>      ]    &#125;  &#125;,  <span class="attr">&quot;exclude&quot;</span>: [    <span class="string">&quot;node_modules&quot;</span>,    <span class="string">&quot;dist&quot;</span>  ]&#125;</code></pre><p>关闭vscode，重新打开项目，vscode即可实现对别名的识别。</p>]]></content>
    
    
    <summary type="html">vue项目中增加配置文件，使得开发环境可以识别自定义的vue别名能够实现代码跳转</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://mirsery.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>前端包管理私服搭建</title>
    <link href="https://mirsery.github.io/2021/12/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/"/>
    <id>https://mirsery.github.io/2021/12/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/</id>
    <published>2021-12-17T08:01:56.000Z</published>
    <updated>2021-12-17T08:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--dokcer----verdaccio">使用dokcer容器运行verdaccio</a></li><li><a href="#verdaccio--">verdaccio配置</a></li><li><a href="#----">创建用户</a></li></ul><!-- tocstop --><p>verdaccio 是一个简单的，零配置本地私有npm软件包代理注册表。verdaccio开箱即用，拥有自己的小型数据库，能够代理其他注册表（例如npmjs.org)，缓存下载的模块。</p><p><a href="https://github.com/verdaccio/verdaccio">verdaccio项目地址</a></p><h2 id="使用dokcer容器运行verdaccio"><a href="#使用dokcer容器运行verdaccio" class="headerlink" title="使用dokcer容器运行verdaccio"></a>使用dokcer容器运行verdaccio</h2><p><a href="https://hub.docker.com/r/verdaccio/verdaccio">verdaccio docker 仓库地址 </a></p><pre><code class="highlight shell">docker run --restart=always --name verdaccio --privileged=true -v /&#123;location&#125;:/verdaccio -p 4873:4873 -d verdaccio/verdaccio</code></pre><h2 id="verdaccio配置"><a href="#verdaccio配置" class="headerlink" title="verdaccio配置"></a>verdaccio配置</h2><blockquote><p>容器内 /verdaccio/conf  配置文件</p></blockquote><pre><code class="highlight yaml"><span class="comment">#</span><span class="comment"># This is the config file used for the docker images.</span><span class="comment"># It allows all users to do anything, so don&#x27;t use it on production systems.</span><span class="comment">#</span><span class="comment"># Do not configure host and port under `listen` in this file</span><span class="comment"># as it will be ignored when using docker.</span><span class="comment"># see https://verdaccio.org/docs/en/docker#docker-and-custom-port-configuration</span><span class="comment">#</span><span class="comment"># Look here for more config file examples:</span><span class="comment"># https://github.com/verdaccio/verdaccio/tree/master/conf</span><span class="comment">#</span><span class="comment"># path to a directory with all packages</span><span class="attr">storage:</span> <span class="string">/verdaccio/storage/data</span><span class="comment"># path to a directory with plugins to include</span><span class="attr">plugins:</span> <span class="string">/verdaccio/plugins</span><span class="attr">web:</span>  <span class="comment"># WebUI is enabled as default, if you want disable it, just uncomment this line</span>  <span class="comment">#enable: false</span>  <span class="attr">title:</span> <span class="string">Verdaccio</span>  <span class="comment"># comment out to disable gravatar support</span>  <span class="comment"># gravatar: false</span>  <span class="comment"># by default packages are ordercer ascendant (asc|desc)</span>  <span class="comment"># sort_packages: asc</span>  <span class="comment"># darkMode: true</span>  <span class="comment"># logo: http://somedomain/somelogo.png</span>  <span class="comment"># favicon: http://somedomain/favicon.ico | /path/favicon.ico</span><span class="comment"># translate your registry, api i18n not available yet</span><span class="comment"># i18n:</span><span class="comment"># list of the available translations https://github.com/verdaccio/ui/tree/master/i18n/translations</span><span class="comment">#   web: en-US</span><span class="attr">auth:</span>  <span class="attr">htpasswd:</span>    <span class="attr">file:</span> <span class="string">/verdaccio/storage/htpasswd</span>    <span class="comment"># Maximum amount of users allowed to register, defaults to &quot;+infinity&quot;.</span>    <span class="comment"># You can set this to -1 to disable registration.</span>    <span class="comment"># max_users: 1000</span><span class="comment"># a list of other known repositories we can talk to</span><span class="attr">uplinks:</span>  <span class="attr">taobao:</span>    <span class="attr">url:</span> <span class="string">https://registry.npm.taobao.org/</span>  <span class="attr">npmjs:</span>    <span class="attr">url:</span> <span class="string">https://registry.npmjs.org/</span><span class="attr">packages:</span>  <span class="string">&#x27;@*/*&#x27;</span><span class="string">:</span>    <span class="comment"># scoped packages</span>    <span class="attr">access:</span> <span class="string">$all</span>    <span class="attr">publish:</span> <span class="string">$authenticated</span>    <span class="attr">unpublish:</span> <span class="string">$authenticated</span>    <span class="attr">proxy:</span> <span class="string">taobao</span>  <span class="string">&#x27;**&#x27;</span><span class="string">:</span>    <span class="comment"># allow all users (including non-authenticated users) to read and</span>    <span class="comment"># publish all packages</span>    <span class="comment">#</span>    <span class="comment"># you can specify usernames/groupnames (depending on your auth plugin)</span>    <span class="comment"># and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;</span>    <span class="attr">access:</span> <span class="string">$all</span>    <span class="comment"># allow all known users to publish/publish packages</span>    <span class="comment"># (anyone can register by default, remember?)</span>    <span class="attr">publish:</span> <span class="string">$authenticated</span>    <span class="attr">unpublish:</span> <span class="string">$authenticated</span>    <span class="comment"># if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry</span>    <span class="attr">proxy:</span> <span class="string">taobao</span><span class="comment"># You can specify HTTP/1.1 server keep alive timeout in seconds for incoming connections.</span><span class="comment"># A value of 0 makes the http server behave similarly to Node.js versions prior to 8.0.0, which did not have a keep-alive timeout.</span><span class="comment"># WORKAROUND: Through given configuration you can workaround following issue https://github.com/verdaccio/verdaccio/issues/301. Set to 0 in case 60 is not enough.</span><span class="attr">server:</span>  <span class="attr">keepAliveTimeout:</span> <span class="number">60</span><span class="attr">middlewares:</span>  <span class="attr">audit:</span>    <span class="attr">enabled:</span> <span class="literal">true</span><span class="comment"># log settings</span><span class="attr">logs:</span> &#123; <span class="attr">type:</span> <span class="string">stdout</span>, <span class="attr">format:</span> <span class="string">pretty</span>, <span class="attr">level:</span> <span class="string">http</span> &#125;<span class="comment">#experiments:</span><span class="comment">#  # support for npm token command</span><span class="comment">#  token: false</span><span class="comment">#  # enable tarball URL redirect for hosting tarball with a different server, the tarball_url_redirect can be a template string</span><span class="comment">#  tarball_url_redirect: &#x27;https://mycdn.com/verdaccio/$&#123;packageName&#125;/$&#123;filename&#125;&#x27;</span><span class="comment">#  # the tarball_url_redirect can be a function, takes packageName and filename and returns the url, when working with a js configuration file</span><span class="comment">#  tarball_url_redirect(packageName, filename) &#123;</span><span class="comment">#    const signedUrl = // generate a signed url</span><span class="comment">#    return signedUrl;</span><span class="comment">#  &#125;</span><span class="comment"># This affect the web and api (not developed yet)</span><span class="comment">#i18n:</span><span class="comment">#web: en-US</span></code></pre><p>上面是一些默认配置，我们可以简单的进行一些个性化的修改。</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>在容器内执行如下命令:</p><pre><code class="highlight shell">npm adduser --registry http://localhost:4873 # 该地址为登录地址</code></pre><p>接着输入用户名和密码以及邮箱完成注册，完成注册之后可以登录web页面查看信息。</p>]]></content>
    
    
    <summary type="html">利用verdaccio搭建私有npm源</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>docker磁盘占用与清理问题</title>
    <link href="https://mirsery.github.io/2021/12/10/docker/docker%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E6%B8%85%E7%90%86%E9%97%AE%E9%A2%98/"/>
    <id>https://mirsery.github.io/2021/12/10/docker/docker%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E6%B8%85%E7%90%86%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-10T09:50:54.000Z</published>
    <updated>2021-12-10T09:50:54.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--docker----">查看docker占用分布</a></li><li><a href="#----">清理方法</a><ul><li><a href="#------">自动清理命令</a></li><li><a href="#----">手动清除</a></li></ul></li></ul><!-- tocstop --><h2 id="查看docker占用分布"><a href="#查看docker占用分布" class="headerlink" title="查看docker占用分布"></a>查看docker占用分布</h2><pre><code class="highlight shell">docker system df</code></pre><pre><code class="highlight shell">docker system df -v #可以进一步查看空间占用的细节以确定是哪个镜像，容器活着本地卷占用过高的空间</code></pre><h2 id="清理方法"><a href="#清理方法" class="headerlink" title="清理方法"></a>清理方法</h2><h3 id="自动清理命令"><a href="#自动清理命令" class="headerlink" title="自动清理命令"></a>自动清理命令</h3><blockquote><p>该命令自动清理的对象如下：</p></blockquote><ul><li>已经停止的容器</li><li>未被任何容器使用的卷</li><li>未被任何容器所关联的网络</li><li>所有悬空的镜像</li></ul><pre><code class="highlight shell">docker system prune # 对空间进行自动清理docker system prune -a #清除所有未被使用的镜像和悬空镜像docker system prune -f #用以强制删除不提示信息</code></pre><p>针对容器和镜像的删除命令:</p><pre><code class="highlight shell">docker image prune #删除悬空的镜像docker container prune #删除无用的容器<span class="meta">#</span><span class="bash"></span><span class="bash"><span class="comment"># 默认情况下docker container prune命令会清理掉所有处于stopped状态的容器</span></span><span class="meta">#</span><span class="bash"></span><span class="bash">docker volume prune <span class="comment"># 删除无用的卷</span></span>docker network prune # 删除无用的网络</code></pre><h3 id="手动清除"><a href="#手动清除" class="headerlink" title="手动清除"></a>手动清除</h3><ul><li>清理卷<br>如果卷占用过高，可以清除一些不使用的卷，包括一些未被任何容器调用的卷（-v 详细信息中若显示LINKS=0，则未被调用)<pre><code class="highlight shell">docker volume rm $(docker volume ls -qf dangling=true)</code></pre></li><li>容器清理<br>如果发现是容器占用过高的空间，可以手动删除一些:<br>删除所有已退出的容器:<pre><code class="highlight shell">docker rm -v $(docker ps -aq -f status=exited)</code></pre>删除所有状态为dead的容器<pre><code class="highlight shell">docker rm -v $(docker ps -aq -f status=dead)</code></pre></li></ul>]]></content>
    
    
    <summary type="html">docker在使用一段时间后会发现宿主磁盘很容易被占满，手动清除image之后似乎并不能释放磁盘...</summary>
    
    
    
    <category term="docker" scheme="https://mirsery.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://mirsery.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu深度学习驱动安装</title>
    <link href="https://mirsery.github.io/2021/12/10/web/2021/ubuntu%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/"/>
    <id>https://mirsery.github.io/2021/12/10/web/2021/ubuntu%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/</id>
    <published>2021-12-10T06:25:31.000Z</published>
    <updated>2021-12-10T06:25:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu安装-Nvidia驱动"><a href="#Ubuntu安装-Nvidia驱动" class="headerlink" title="Ubuntu安装 Nvidia驱动"></a>Ubuntu安装 Nvidia驱动</h1><!-- toc --><ul><li><a href="#--------------">首先查看本机所安装的显卡型号</a></li><li><a href="#------">官网下载驱动</a></li><li><a href="#---------------">删除原有的开源驱动程序(可选)</a></li><li><a href="#--nouveau--">禁用nouveau驱动</a></li><li><a href="#--">重启</a></li><li><a href="#--nouveau------">验证nouveau是否已经禁用</a></li><li><a href="#--nvidia--">安装nvidia驱动</a></li><li><a href="#----------">查看驱动是否安装成功</a></li><li><a href="#----">其他问题</a></li></ul><!-- tocstop --><h2 id="首先查看本机所安装的显卡型号"><a href="#首先查看本机所安装的显卡型号" class="headerlink" title="首先查看本机所安装的显卡型号"></a>首先查看本机所安装的显卡型号</h2><pre><code class="highlight shell">lspci|grep VGA</code></pre><p><img src="/2021/12/10/web/2021/ubuntu%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/C5902CF2-5023-414E-9BBA-D7FE625ECA55.png"></p><p>根据如上所述的显卡型号，去官网下载对应的系统和对应显卡的驱动。</p><h2 id="官网下载驱动"><a href="#官网下载驱动" class="headerlink" title="官网下载驱动"></a>官网下载驱动</h2><p><a href="https://www.nvidia.cn/Download/index.aspx">nvidia驱动下载地址</a></p><p>选择对应的产品类型，产品系列以及产品型号再根据操作系统系统下载对应的驱动程序。</p><h2 id="删除原有的开源驱动程序-可选"><a href="#删除原有的开源驱动程序-可选" class="headerlink" title="删除原有的开源驱动程序(可选)"></a>删除原有的开源驱动程序(可选)</h2><pre><code class="highlight shell">sudo apt-get remove --pure nvidia*</code></pre><h2 id="禁用nouveau驱动"><a href="#禁用nouveau驱动" class="headerlink" title="禁用nouveau驱动"></a>禁用nouveau驱动</h2><p>编辑 <strong>/etc/modprobe.d/blacklist.conf</strong> ,添加以下内容:</p><pre><code class="highlight plaintext">blacklist nouveaublacklist lbm-nouveauoptions nouveau modeset=0alias nouveau offalias lbm-nouveau off</code></pre><p>关闭nouveau</p><pre><code class="highlight shell">echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</code></pre><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><pre><code class="highlight shell">update-initramfs -u reboot</code></pre><h2 id="验证nouveau是否已经禁用"><a href="#验证nouveau是否已经禁用" class="headerlink" title="验证nouveau是否已经禁用"></a>验证nouveau是否已经禁用</h2><pre><code class="highlight shell">lsmod|grep nouveau</code></pre><p>没有信息显示，说明nouveau已被禁用，接下来可以安装nvdia的显卡驱动。</p><h2 id="安装nvidia驱动"><a href="#安装nvidia驱动" class="headerlink" title="安装nvidia驱动"></a>安装nvidia驱动</h2><ul><li>给文件可执行权限</li></ul><pre><code class="highlight shell">sudo chmod +x NVIDIA-Linux-x86_64-470.86.run</code></pre><ul><li>安装</li></ul><pre><code class="highlight shell">sudo ./NVIDIA-Linux-x86_64-470.86.run -no-x-check -no-nouveau-check -no-opengl-files</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-no-x-check</td><td>安装驱动时关闭X服务</td></tr><tr><td>-no-nouveau-check</td><td>安装驱动时禁用nouveau</td></tr><tr><td>-no-opengl-files</td><td>只安装驱动文件，不安装OpenGL文件</td></tr></tbody></table><h2 id="查看驱动是否安装成功"><a href="#查看驱动是否安装成功" class="headerlink" title="查看驱动是否安装成功"></a>查看驱动是否安装成功</h2><pre><code class="highlight shell">nvidia-smi</code></pre><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>如果出现以下类似的问题</p><pre><code class="highlight plaintext">NVIDIA-SMI has failed because it couldn‘t communicate with NVIDIA driver. Make sure that the latest driver is installed and running.</code></pre><p>解决方案:</p><pre><code class="highlight shell">sudo apt-get install dkmssudo dkms install -m nvidia -v 470.86</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu安装-Nvidia驱动&quot;&gt;&lt;a href=&quot;#Ubuntu安装-Nvidia驱动&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu安装 Nvidia驱动&quot;&gt;&lt;/a&gt;Ubuntu安装 Nvidia驱动&lt;/h1&gt;&lt;!-- toc --&gt;
</summary>
      
    
    
    
    <category term="软件安装" scheme="https://mirsery.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="深度学习" scheme="https://mirsery.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>typescript笔记1</title>
    <link href="https://mirsery.github.io/2021/12/10/web/2021/typescript%E7%AC%94%E8%AE%B01/"/>
    <id>https://mirsery.github.io/2021/12/10/web/2021/typescript%E7%AC%94%E8%AE%B01/</id>
    <published>2021-12-10T05:03:42.000Z</published>
    <updated>2021-12-10T05:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="typescript-笔记-1"><a href="#typescript-笔记-1" class="headerlink" title="typescript 笔记 1"></a>typescript 笔记 1</h1><!-- toc --><ul><li><a href="#typescript---">typescript的安装</a></li><li><a href="#typescript-----">TypeScript的类型注解</a></li><li><a href="#--">接口</a></li><li><a href="#-">类</a></li><li><a href="#symbol--">symbol类型</a></li><li><a href="#-----symbols">众所周知的Symbols</a></li></ul><!-- tocstop --><h2 id="typescript的安装"><a href="#typescript的安装" class="headerlink" title="typescript的安装"></a>typescript的安装</h2><p>使用npm包的形式安装</p><pre><code class="highlight shell">npm install -g typescript</code></pre><h2 id="TypeScript的类型注解"><a href="#TypeScript的类型注解" class="headerlink" title="TypeScript的类型注解"></a>TypeScript的类型注解</h2><pre><code class="highlight typeScript"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: <span class="built_in">string</span></span>)</span>&#123;    <span class="keyword">return</span> <span class="string">&quot;hello, &quot;</span>+person;&#125;<span class="keyword">let</span> user = <span class="string">&quot;Jane User&quot;</span>;<span class="built_in">document</span>.body.innerHtml = greeter(user)</code></pre><p>TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。如果传入的参数不符合类型，则会编译器会给出相应的警告内容.</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>TypeScript里可以定义类似java中的接口，如下所示:</p><pre><code class="highlight typeScript"><span class="keyword">interface</span> Person &#123;    <span class="attr">firstName</span>: <span class="built_in">string</span>;    lastName: <span class="built_in">string</span>&#125;<span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: Person</span>) </span>&#123;    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + person.firstName + <span class="string">&quot;&quot;</span> + person.lastName;&#125;<span class="keyword">let</span> user = &#123;<span class="attr">firstName</span>:<span class="string">&quot;Jane&quot;</span>,<span class="attr">lastName</span>:<span class="string">&quot;User&quot;</span>&#125;;<span class="built_in">document</span>.body.innerHTML = greeter(user)</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>TypeScript支持JavaScript的新特性，比如支持基于类的面向对象编程。以下是官网的例子:</p><blockquote><p>在构造函数上使用public等同于创建了同名的成员变量</p></blockquote><pre><code class="highlight typeScript"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;    <span class="attr">fullName</span>: <span class="built_in">string</span>,    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> firstName,<span class="keyword">public</span> middleInitial,<span class="keyword">public</span> lastName</span>)</span>&#123;        <span class="built_in">this</span>.fullName = firstName + <span class="string">&quot; &quot;</span> + middleInitial + <span class="string">&quot; &quot;</span> + lastName;    &#125;&#125;<span class="keyword">interface</span> Person&#123;    <span class="attr">firstName</span>: <span class="built_in">string</span>,    <span class="attr">lastName</span>: <span class="built_in">string</span>;&#125;<span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: Person</span>)</span>&#123;    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + person.firstName + <span class="string">&quot; &quot;</span> + person.lastName;&#125;<span class="keyword">let</span> user = <span class="keyword">new</span> Student(<span class="string">&quot;Jane&quot;</span>,<span class="string">&quot;M.&quot;</span>,<span class="string">&quot;User&quot;</span>);<span class="built_in">document</span>.body.innerHTML = greeter(user);</code></pre><h2 id="symbol类型"><a href="#symbol类型" class="headerlink" title="symbol类型"></a>symbol类型</h2><blockquote><p>自ECMAScript 2015起，symbol成为了一种新的原生类型，就像number和string一样。</p></blockquote><p>symbol类型的值是通过Symbol构造函数创建的。</p><pre><code class="highlight typeScript"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>();<span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&quot;key&quot;</span>); <span class="comment">// 可选的字符串key</span></code></pre><p>Symbols是不可以改变且唯一的。</p><pre><code class="highlight typeScript"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&quot;key&quot;</span>);<span class="keyword">let</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">&quot;key&quot;</span>);sym2 === sym3; <span class="comment">// false, symbols是唯一的</span></code></pre><p>像字符串一样，symbols也可以被用做对象属性的键。</p><pre><code class="highlight typeScript"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();<span class="keyword">let</span> obj = &#123;    [sym]: <span class="string">&quot;value&quot;</span>&#125;;<span class="built_in">console</span>.log(obj[sym]); <span class="comment">// &quot;value&quot;</span></code></pre><p>Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员.</p><pre><code class="highlight typeScript"><span class="keyword">const</span> getClassNameSymbol = <span class="built_in">Symbol</span>();<span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;    [getClassNameSymbol]()&#123;       <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;    &#125;&#125;<span class="keyword">let</span> c = <span class="keyword">new</span> C();<span class="keyword">let</span> className = c[getClassNameSymbol](); <span class="comment">// &quot;C&quot;</span></code></pre><h2 id="众所周知的Symbols"><a href="#众所周知的Symbols" class="headerlink" title="众所周知的Symbols"></a>众所周知的Symbols</h2><p>除了用户定义的symbols，还有一些已经众所周知的内置symbols。 内置symbols用来表示语言内部的行为。</p><p>以下为这些symbols的列表：</p><ul><li><p>Symbol.hasInstance</p><p>  方法，会被<strong>instanceof</strong>运算符调用。构造器对象用来识别一个对象是否是其实例。</p></li><li><p>Symbol.isConcatSpreadable</p><p>  布尔值，表示当在一个对象上调用<strong>Array.prototype.concat</strong>时，这个对象的数组元素是否可展开。</p></li><li><p>Symbol.iterator</p><p>  方法，被<strong>for-of</strong>语句调用。返回对象的默认迭代器。</p></li><li><p>Symbol.match</p><p>  方法，被<strong>String.prototype.match</strong>调用。正则表达式用来匹配字符串。</p></li><li><p>Symbol.replace</p><p>  方法，被<strong>String.prototype.replace</strong>调用。正则表达式用来替换字符串中匹配的子串。</p></li><li><p>Symbol.search</p><p>  方法，被<strong>String.prototype.search</strong>调用。正则表达式返回被匹配部分在字符串中的索引。</p></li><li><p>Symbol.species</p><p>  函数值，为一个构造函数。用来创建派生对象。</p></li><li><p>Symbol.split</p><p>  方法，被<strong>String.prototype.split</strong>调用。正则表达式来用分割字符串。</p></li><li><p>Symbol.toPrimitive</p><p>  方法，被<strong>ToPrimitive</strong>抽象操作调用。把对象转换为相应的原始值。</p></li><li><p>Symbol.toStringTag</p><p>  方法，被内置方法<strong>Object.prototype.toString</strong>调用。返回创建对象时默认的字符串描述。</p></li><li><p>Symbol.unscopables</p><p>  对象，它自己拥有的属性会被with作用域排除在外。</p></li></ul>]]></content>
    
    
    <summary type="html">typescript是javaScript的超集，他可以编译成javaScript....</summary>
    
    
    
    <category term="js" scheme="https://mirsery.github.io/categories/js/"/>
    
    
    <category term="前端" scheme="https://mirsery.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://mirsery.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>electron-builder打包依赖存放位置</title>
    <link href="https://mirsery.github.io/2021/11/25/web/2021/electron-builder%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE/"/>
    <id>https://mirsery.github.io/2021/11/25/web/2021/electron-builder%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE/</id>
    <published>2021-11-25T06:08:42.000Z</published>
    <updated>2021-11-25T06:08:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#electron-builder-----">electron-builder 打包问题</a><ul><li><a href="#-----">缓存的位置</a></li></ul></li></ul><!-- tocstop --><h1 id="electron-builder-打包问题"><a href="#electron-builder-打包问题" class="headerlink" title="electron-builder 打包问题"></a>electron-builder 打包问题</h1><p>由于国内某些神秘力量会导致采用electron-builder打包app时，从GitHub等地下载依赖时导致文件的下载超时。为此，我们需要手动将依赖下载到指定的目录下面，才能进行下一步的打包工作。</p><h2 id="缓存的位置"><a href="#缓存的位置" class="headerlink" title="缓存的位置"></a>缓存的位置</h2><ul><li>macos</li></ul><pre><code class="highlight shell">~/Library/Caches/electron~/Library/Caches/electron-builder~/Library/Application Support/Caches</code></pre><ul><li><p>Linux </p><pre><code class="highlight shell">~/.cache/electron-builder</code></pre></li><li><p>windows</p><pre><code class="highlight shell"><span class="meta">%</span><span class="bash">LOCALAPPDATA%\\electron\\cache</span><span class="meta">%</span><span class="bash">LOCALAPPDATA%\\electron-builder\\cache</span></code></pre></li></ul>]]></content>
    
    
    <summary type="html">使用 electron-builder 打包的时候会自动下载所需的依赖，但是下载过程可能因某些神秘力量而失败。因此需要手动下载，再将工具放于指定路径...</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>npm镜像源管理</title>
    <link href="https://mirsery.github.io/2021/11/25/web/2021/npm%E9%95%9C%E5%83%8F%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>https://mirsery.github.io/2021/11/25/web/2021/npm%E9%95%9C%E5%83%8F%E6%BA%90%E7%AE%A1%E7%90%86/</id>
    <published>2021-11-25T05:42:58.000Z</published>
    <updated>2021-11-25T05:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----nrm">全局安装nrm</a></li><li><a href="#--nrm">使用nrm</a></li></ul><!-- tocstop --><p>国内由于众所周知的原因，在我们使用npm工具构建前端项目时总会发生一些令人沮丧的事情，每次都需要手动更换镜像源。nrm(npm registry manager)是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换。</p><h2 id="全局安装nrm"><a href="#全局安装nrm" class="headerlink" title="全局安装nrm"></a>全局安装nrm</h2><pre><code class="highlight shell">npm i -g nrm</code></pre><h2 id="使用nrm"><a href="#使用nrm" class="headerlink" title="使用nrm"></a>使用nrm</h2><blockquote><p>查看可用镜像源</p></blockquote><pre><code class="highlight shell">nrm list</code></pre><blockquote><p>选择使用镜像源</p></blockquote><pre><code class="highlight shell">nrm use &lt;name&gt;</code></pre><blockquote><p>增加定制源</p></blockquote><pre><code class="highlight plaintext">nrm add &lt;registry&gt; &lt;url&gt;</code></pre><p>其中reigstry为源名，url为源的路径。</p><blockquote><p>删除镜像源</p></blockquote><pre><code class="highlight shell">nrm del &lt;registry&gt;</code></pre><blockquote><p>测试源速度</p></blockquote><pre><code class="highlight shell">nrm test npm</code></pre>]]></content>
    
    
    <summary type="html">‘nrm npm镜像源管理工具’</summary>
    
    
    
    
  </entry>
  
</feed>

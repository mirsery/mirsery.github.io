<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mirsery</title>
  
  
  <link href="https://mirsery.github.io/atom.xml" rel="self"/>
  
  <link href="https://mirsery.github.io/"/>
  <updated>2021-07-12T02:42:08.283Z</updated>
  <id>https://mirsery.github.io/</id>
  
  <author>
    <name>mirsery</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java Annotation示例</title>
    <link href="https://mirsery.github.io/2021/07/12/java/java%20annotation%E4%BE%8B%E5%AD%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E9%87%8A/"/>
    <id>https://mirsery.github.io/2021/07/12/java/java%20annotation%E4%BE%8B%E5%AD%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E9%87%8A/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="annotation">Annotation</span></h1><p>From Core Java SE9 for the Impatient<br>Annotations are tags that you insert into your source code so that some tool can process them. The tools can operate on the source level, or they can process class files into which the compiler has placed annotations.<br>Annotations do not change the way your programs are compiled. The Java compiler generates the same virtual machine instructions with or without the annotations.<br>To benefit from annotations, you need to select a processing tool and use annotations that your processing tool understands, before you can apply that tool to your code.<br>There is a wide range of uses for annotations. For example, JUnit uses annotations to mark methods that execute tests and to specify how the tests should be run. The Java Persistence Architecture uses annotations to define mappings between classes and database tables, so that objects can be persisted automatically without the developer having to write SQL queries.</p><!-- toc --><ul><li><a href="#using-annotations">using Annotations</a><ul><li><a href="#simple-annotation">simple annotation</a></li><li><a href="#annotation-elements">annotation elements</a></li><li><a href="#multilple-and-repeated-annotations">Multilple and Repeated Annotations</a></li><li><a href="#annotating-declarations">Annotating Declarations</a></li><li><a href="#annotating-type-users">Annotating Type Users</a></li><li><a href="#making-receivers-explicit">Making Receivers Explicit</a></li></ul></li><li><a href="#defineing-annotations">defineing Annotations</a></li><li><a href="#annotations-for-compilation">Annotations for Compilation</a></li><li><a href="#annotations-for-managing-resources">Annotations for Managing Resources</a></li></ul><!-- tocstop --><h2><span id="using-annotations">using Annotations</span></h2><h3><span id="simple-annotation">simple annotation</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheTest</span> </span>&#123;<br>    ...<br>    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkRandomInsertions</span><span class="hljs-params">()</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3><span id="annotation-elements">annotation elements</span></h3><p>Annotation can hava key/value pairs called elements,such as<br>@Test(timeout=10000)<br>An annotation element is one of the following:<br>• A primitive type value<br>• A String<br>• A Class object<br>• An instance of an enum<br>• An annotation<br>• An array of the preceding (but not an array of arrays)</p><h3><span id="multilple-and-repeated-annotations">Multilple and Repeated Annotations</span></h3><p>An item can have multiple annotations:<br>@Test<br>@BugReport(showStopper=true,reportedBy=”Joe”)<br>public void checkRandomInsertions( )<br>If the author of an annotation declared it to be repeatable, you can repeat the same annotation multiple times:<br>@BugReport(showStopper=true, reportedBy=”Joe”)<br>@BugReport(reportedBy={“Harry”, “Carl”})<br>public void checkRandomInsertions()</p><h3><span id="annotating-declarations">Annotating Declarations</span></h3><p>They fail into two categories : <code>declarations</code> and <code> type uses</code>.Declaration annotations can appear at the declarations of  </p><ul><li>Classes(including enum) and interfaces (including annotation interfaces)</li><li>Methods</li><li>Constructors</li><li>Instance variable (including enum constants)</li><li>Local variables (including those deckared in for and try-with-resources statements)</li><li>Parameter variables and catch clasuse parameters</li><li>Type parameters</li><li>Packages<h3><span id="annotating-type-users">Annotating Type Users</span></h3>A declaration annotation provides some information about the item being declared.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String userId)</span></span><br></code></pre></td></tr></table></figure>It is arrerted that userId parameter is not null.<h3><span id="making-receivers-explicit">Making Receivers Explicit</span></h3>Suppose you want to annotate parameters that are not being mutated by a method.</li></ul><h2><span id="defineing-annotations">defineing Annotations</span></h2><p>@Target(ElementType.METHOD)<br>@Retention(RetentionPolicy.RUNTIME)<br>public @interface Test {<br>    long timeout();<br>    …<br>}<br>The @interface declaration creates an actual Java interface. Tools that process annotations receive objects that implement the annotation interface. When the JUnit test runner tool gets an object that implements Test, it simply invokes the timeout method to retrieve the timeout element of a particular Test annotation.</p><h2><span id="annotations-for-compilation">Annotations for Compilation</span></h2><p>The @Deprecated annotation can be attached to any items whose use is no longer encouraged. The compiler will warn when you use a deprecated item. This annotation has the same role as the @deprecated Javadoc tag. However, the annotation persists until runtime.</p><h2><span id="annotations-for-managing-resources">Annotations for Managing Resources</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">@Resource(name=&quot;jdbc/employeedb&quot;)<br>private DataSource source;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;annotation&quot;&gt;Annotation&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;From Core Java SE9 for the Impatient&lt;br&gt;Annotations are tags that you insert into your so</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="annotation" scheme="https://mirsery.github.io/tags/annotation/"/>
    
  </entry>
  
  <entry>
    <title>java 中面向切面的Aop 解析</title>
    <link href="https://mirsery.github.io/2021/07/12/java/java%E4%B8%AD%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2aop%E8%A7%A3%E6%9E%90/"/>
    <id>https://mirsery.github.io/2021/07/12/java/java%E4%B8%AD%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2aop%E8%A7%A3%E6%9E%90/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="aop-解析">Aop 解析</span></h1><blockquote><p> 了解aop协议</p></blockquote><!-- toc --><ul><li><a href="#%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84aop">实现简易的Aop</a></li></ul><!-- tocstop --><p>AOP（面向切面编程）是Spring框架的特色功能之一。通过设置横切关注点（cross cutting concerns），AOP提供了极高的扩展性。</p><h2><span id="实现简易的aop">实现简易的Aop</span></h2><ol><li>定义一个 需要被代理的接口，并实现接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Job</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doWork</span><span class="hljs-params">(String msg)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Work</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Job</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doWork</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;[do-work] &quot;</span> + msg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>实现InvocationHandler接口并创建代理方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Object o;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WorkHandler</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.o = o;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        method.invoke(o, args);<br>        System.out.println(<span class="hljs-string">&quot;[proxy-invoke]&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>场景测试类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkMain</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Job work = <span class="hljs-keyword">new</span> Work();<br>        WorkHandler workHandler = <span class="hljs-keyword">new</span> WorkHandler(work);<br>        Job job = (Job) Proxy.newProxyInstance(work.getClass().getClassLoader(),<br>                work.getClass().getInterfaces(),workHandler);<br>        System.out.println(job.doWork(<span class="hljs-string">&quot;hahahah&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;aop-解析&quot;&gt;Aop 解析&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 了解aop协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9E%E7%8E%B0%E7%AE</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="aop" scheme="https://mirsery.github.io/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>java发起http请求</title>
    <link href="https://mirsery.github.io/2021/07/12/java/java%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82/"/>
    <id>https://mirsery.github.io/2021/07/12/java/java%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="在java中利用jdk提供的方法我们可以很轻松的发起一个http请求">在java中利用jdk提供的方法我们可以很轻松的发起一个http请求。</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">URL  realURL = <span class="hljs-keyword">new</span> URL(url);  <span class="hljs-comment">//java.net.URL</span><br>URLConnection conn = realURL.openConnection( );<br><span class="hljs-comment">//设置请求头</span><br>connection.setRequestProperties(<span class="hljs-string">&quot;accept&quot;</span>,<span class="hljs-string">&quot;*/*&quot;</span>);<br>conn.setRequestProperty(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-string">&quot;Keep-Alive&quot;</span>);<br>conn.setRequestProperty(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>conn.setRequestProperty(<span class="hljs-string">&quot;user-agent&quot;</span>,<span class="hljs-string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;</span>);<br><span class="hljs-comment">// 发送POST请求必须设置如下两行</span><br>conn.setDoOutput(<span class="hljs-keyword">true</span>);<br>conn.setDoInput(<span class="hljs-keyword">true</span>);<br> <span class="hljs-comment">// 获取URLConnection对象对应的输出流</span><br>out = <span class="hljs-keyword">new</span> PrintWriter(conn.getOutputStream());<br><span class="hljs-comment">// 发送请求参数</span><br>out.print(param);<br>out.flush();<br>BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(conn.getInputStream()));<br>String line;<br>String result;<br><span class="hljs-keyword">while</span> ((line = in.readLine()) != <span class="hljs-keyword">null</span>) &#123;result += line;&#125;<br></code></pre></td></tr></table></figure><h2><span id="发起一个post请求">发起一个post请求</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient.Builder().<br>    connectTimeout(<span class="hljs-number">10</span>, TimeUnit.SECONDS).<br>    readTimeout(<span class="hljs-number">20</span>, TimeUnit.SECONDS).build(); <span class="hljs-comment">//超时时间设置</span><br>MediaType mediaType = MediaType.parse(<span class="hljs-string">&quot;application/json&quot;</span>);<br>    String url = <span class="hljs-string">&quot;request_url&quot;</span>;<br>okhttp3.RequestBody requestBody=okhttp3.RequestBody.<br>    create(message, mediaType);<br>Request request = <span class="hljs-keyword">new</span> Request.Builder().url(url).post(requestBody).<br>addHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>    addHeader(<span class="hljs-string">&quot;header&quot;</span>, key).build();<br><span class="hljs-keyword">try</span> &#123;<br>        Response response = client.newCall(request).execute();<br>        response.body().string();<br> &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br> &#125;   <br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;在java中利用jdk提供的方法我们可以很轻松的发起一个http请求&quot;&gt;在java中利用jdk提供的方法我们可以很轻松的发起一个http请求。&lt;/span&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="http" scheme="https://mirsery.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>mybatis插入数据后返回自增主键id</title>
    <link href="https://mirsery.github.io/2021/07/12/java/mybatis%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE/"/>
    <id>https://mirsery.github.io/2021/07/12/java/mybatis%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="mybatis-插入数据后返回自增主键id">[mybatis] 插入数据后返回自增主键id</span></h1><h2><span id="xml映射">xml映射</span></h2><p>在xml中定义<strong>useGeneratedKeys</strong>为true,返回主键id的值,<strong>keyProperty</strong>和<strong>keyColumn</strong>分别代表数据库记录主键字段和java对象成员属性名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- 插入数据:返回记录主键id值 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>  <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>        insert  into stu (name,age) values (#&#123;name&#125;,#&#123;age&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h2><span id="接口映射器">接口映射器</span></h2><p>在接口映射器中通过注解@Options分别设置参数useGeneratedKeys，keyProperty，keyColumn值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回主键字段id值</span><br><span class="hljs-meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;, keyColumn = &quot;id&quot;)</span><br><span class="hljs-meta">@Insert(&quot;insert  into stu (name,age) values (#&#123;name&#125;,#&#123;age&#125;)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Student stu)</span></span>;<br></code></pre></td></tr></table></figure><h2><span id="获取新添加记录主键字段值">获取新添加记录主键字段值</span></h2><p>需要注意的是，在MyBatis中添加操作返回的是记录数并非记录主键id。因此，如果需要获取新添加记录的主键值，需要在执行添加操作之后，直接读取Java对象的主键属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer rows = sqlSession.getMapper(StuMapper.class).insertOneTest(student);<br>System.out.println(<span class="hljs-string">&quot;rows = &quot;</span> + rows); <span class="hljs-comment">// 添加操作返回记录数</span><br>System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + student.getId()); <span class="hljs-comment">// 执行添加操作之后通过Java对象获取主键属性值</span><br></code></pre></td></tr></table></figure><h2><span id="添加批量记录时返回主键id">添加批量记录时返回主键ID</span></h2><p>如果希望执行批量添加并返回各记录主键字段值，只能在xml映射器中实现，在接口映射器中无法做到。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 批量添加数据,并返回主键字段 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>        insert  into stu (name,age) values<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;t&quot;</span>&gt;</span><br>            (#&#123;t.name&#125;,#&#123;t.age&#125;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到,执行批量添加并返回记录主键值的xml映射器配置,跟添加单条记录时是一致的. 不同的地方仅仅是使用了foreach元素构建批量添加语句.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;mybatis-插入数据后返回自增主键id&quot;&gt;[mybatis] 插入数据后返回自增主键id&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;xml映射&quot;&gt;xml映射&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在xml中定义&lt;strong&gt;useGenerated</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="mybatis" scheme="https://mirsery.github.io/tags/mybatis/"/>
    
    <category term="sql" scheme="https://mirsery.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>netty框架获取websocket协议客户端的真实IP地址问题</title>
    <link href="https://mirsery.github.io/2021/07/12/java/netty%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%8E%B7%E5%8F%96websocket%E5%8D%87%E7%BA%A7%E5%8D%8F%E8%AE%AE%E5%89%8D%E7%9A%84http%20header/"/>
    <id>https://mirsery.github.io/2021/07/12/java/netty%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%8E%B7%E5%8F%96websocket%E5%8D%87%E7%BA%A7%E5%8D%8F%E8%AE%AE%E5%89%8D%E7%9A%84http%20header/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="netty框架获取websocket协议客户端的真实ip地址问题">netty框架获取websocket协议客户端的真实IP地址问题</span></h1><blockquote><p> 背景 目前服务器采用nginx进行反向代理部署，利用socketchannel获取的socketAddress为代理服务器的局域网ip</p></blockquote><h2><span id="代理服务器的配置">代理服务器的配置</span></h2><p>首先代理服务器需将真实的ip地址转发到反向代理的服务上，因此代理服务器需增加代理的请求头。下面是nginx作为代理服务器的样例配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">server &#123;<br>    listen xx;<br>    location / &#123;<br>                client_max_body_size 0;<br>                proxy_redirect http://$host/ http://$http_host/;<br>                proxy_set_header Host $host:$server_port;<br>                proxy_set_header X-Real-IP $remote_addr;<br>                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>                proxy_pass http://xxxxxx:xxxx;<br>                proxy_http_version 1.1;<br>                proxy_set_header Upgrade $http_upgrade;<br>                proxy_set_header Connection &#x27;upgrade&#x27;;<br>                proxy_read_timeout 600s;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中** proxy_set_header X-Real-IP $remote_addr;**将真实的客户端ip转发给代理服务中。</p><p>##netty框架中获取传递的<strong>X-Real-IP</strong>请求头地址<br>netty中需要在协议升级之前读取channel的请求头的内容，下面是实例代码。</p><blockquote><p> 该handler需配置在<strong>WebSocketServerProtocolHandler</strong>之前<strong>ChannelInboundHandlerAdapter</strong>不会修改Bytebuf的引用计数问题，详情见<a href="./bytebuf-yin-yong-ji-shu-wen-ti"># ByteBuf 引用计数问题</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpHeadersHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String REAL_IP = <span class="hljs-string">&quot;X-Real-IP&quot;</span>;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IotClientManager clientManager;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>       <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> FullHttpRequest) &#123;<br>            FullHttpRequest httpRequest = (FullHttpRequest) msg;<br>            HttpHeaders headers = httpRequest.headers();<br>            String ip = headers.get(REAL_IP);<br>            <span class="hljs-keyword">if</span> (ip != <span class="hljs-keyword">null</span>) &#123;<br>                clientManager.setIP(ctx.channel(), ip);<br>            &#125;<br>        &#125;<br>        ctx.fireChannelRead(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;netty框架获取websocket协议客户端的真实ip地址问题&quot;&gt;netty框架获取websocket协议客户端的真实IP地址问题&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 背景 目前服务器采用nginx进行反向代理部署，利用socke</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="netty" scheme="https://mirsery.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Springboot 中干掉if else</title>
    <link href="https://mirsery.github.io/2021/07/12/java/springBoot%E4%B8%AD%E6%9B%BF%E6%8D%A2if-else/"/>
    <id>https://mirsery.github.io/2021/07/12/java/springBoot%E4%B8%AD%E6%9B%BF%E6%8D%A2if-else/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="springboot-中干掉if-else">Springboot 中干掉if else</span></h1><blockquote><p> 来自：掘金（作者：cipher）<br>原文链接 <a href="https://juejin.im/post/5c551122e51d457fcc5a9790">https://juejin.im/post/5c551122e51d457fcc5a9790</a></p></blockquote><h2><span id="需求">需求</span></h2><p>这里虚拟一个业务需求，让大家容易理解。假设有一个订单系统，里面的一个功能是根据订单的不同类型作出不同的处理。<br>订单实体:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderDTO</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String code;<br>    <span class="hljs-keyword">private</span> BigDecimal price;<br>    <span class="hljs-keyword">private</span> String type;  <br>&#125;<br></code></pre></td></tr></table></figure><p>service接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOrderService</span> </span>&#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * 根据订单的不同类型做出不同的处理</span><br><span class="hljs-comment">            * <span class="hljs-doctag">@param</span> dto 订单实体</span><br><span class="hljs-comment">            * <span class="hljs-doctag">@return</span> </span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-function">String <span class="hljs-title">handle</span><span class="hljs-params">(OrderDTO dto)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>##传统实现<br>根据订单类写一堆的if-else:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOrderService</span> </span>&#123;<br>    String type = dto.getType();<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;1&quot;</span>.equals(type))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;处理普通订单&quot;</span>;<br>        &#125;<span class="hljs-function">elese <span class="hljs-title">if</span><span class="hljs-params">(<span class="hljs-string">&quot;2&quot;</span>.equals(type)</span>)</span>&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;处理团购订单&quot;</span>;<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;3&quot;</span>.equals(type))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;处理促销订单&quot;</span>;<br>      &#125;                <br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2><span id="策略模式实现">策略模式实现</span></h2><p>利用策略模式只需要实现两行可实现业务逻辑:<br>@Service<br>public class OrderServiceV2Impl implements IOrderService {<br>    @Autowrited<br>    private HandlerContext handlerContext;</p><pre><code>@Overridepublic String handle(OrderDTO dto)&#123;    AbstractHandler handler = handlerContext.getInstance(dto.getType());    return handler.handle(dto);</code></pre><p>   }<br>}<br>可以看到上面的方法中注入了HandlerContext，这是一个处理器上下文，用来保存不同的业务处理器，具体在下文会讲解。我们从中获取一个抽象的处理器AbstractHandler，调用其方法实现业务逻辑。<br>现在可以了解到，我们主要的业务逻辑是在处理器中实现的，因此有多少个订单类型，就对应有多少个处理器。以后需求变化，增加了订单类型，只需要添加相应的处理器就可以，上述OrderServiceV2Impl完全不需改动。</p><hr><p>以上是转自网友 cipher 的文章,今天突然发现springboot可以注入同一接口实现的services集合就想到可以利用其value属性实现策略模式.<br>修改时间 2021-01-06 23:51:58</p><pre><code>其实在springboot中实现策略模式，我们可以利用springboot本身提供的@service 注解以及其 同一接口的实现的Map注入就可以解决。下面简单的举个例子。</code></pre><p>首先我们先定一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DataListener</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onData</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着定义几个实现该接口的类 DataListener1, DataListener2.<br>我们在实现的类DataListener1…上增加@service注解，同时给他命名（其默认名可以为字符串类型的策略），接着我们定义一个场景类<strong>DataHandleContext</strong>,<br>场景类中引入如下变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowrite</span><br><span class="hljs-keyword">public</span> Map&lt;String,DataListener&gt; dataListenerMap;<span class="hljs-comment">//该类是所定义的策略的map集合</span><br></code></pre></td></tr></table></figure><p>至此，我们就很简单的实现了策略模式。策略的命名可以采用枚举类进行控制，这样新增策略时只需要在枚举类中新增相应的枚举类型以及新建相关的service层类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;springboot-中干掉if-else&quot;&gt;Springboot 中干掉if else&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 来自：掘金（作者：cipher）&lt;br&gt;原文链接 &lt;a href=&quot;https://juejin.im/p</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="转载" scheme="https://mirsery.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>springCloud 常见配置</title>
    <link href="https://mirsery.github.io/2021/07/12/java/springCloud%E9%85%8D%E7%BD%AE/"/>
    <id>https://mirsery.github.io/2021/07/12/java/springCloud%E9%85%8D%E7%BD%AE/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="springcloud-常见配置">springCloud 常见配置</span></h1><h2><span id="服务注册类配置">服务注册类配置</span></h2><p>前缀 eureka.client</p><blockquote><p> org.springframework.cloud.netflix.eureka.EurekaClientConfigBean 中定义了常用的配置以及对应的说明和默认值。<br>|参数名|说明|默认值|<br>|:—:|:—:|:—:|<br>enable|应用Eureka客户端|true|<br>registryFetchIntervalSeconds|从Eureka服务端获取注册信息的时间间隔，单位为秒|30<br>instanceInfoReplicationIntervalSeconds|更新实例信息的变化到Eureka服务端的时间间隔时间，单位为秒|30<br>initialInstanceInfoReplicationIntervalSeconds|初始化实例信息到Eureka服务端的时间间隔时间，单位为秒|40<br>eurekaServiceUrlPollIntervalSeconds|轮询Eureka服务端地址更改的时间间隔，单位为秒，当我们与springCloud Config配合，动态刷新Eureka的serviceURL地址时需要关注该需求|300<br>eurekaServerReadTimeoutSeconds|读取Eureka Server信息的超时时间，单位秒|8<br>eurekaServerConnectTimeoutSeconds|连接Eureka Server信息的超时时间，单位秒|5<br>eurekaServerTotalConnections|从Eureka客户端到所有Eureka服务端的连接总数|200<br>eurekaServerTotalConnectionPerlist|从Eureka客户端到每个Eureka服务端主机的连接总数|50<br>eurekaConnection sss</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;springcloud-常见配置&quot;&gt;springCloud 常见配置&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;服务注册类配置&quot;&gt;服务注册类配置&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;前缀 eureka.client&lt;/p&gt;
&lt;blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>关于springboot 中添加filter的方法</title>
    <link href="https://mirsery.github.io/2021/07/12/java/springboot%20%E4%B8%AD%E6%B7%BB%E5%8A%A0filter/"/>
    <id>https://mirsery.github.io/2021/07/12/java/springboot%20%E4%B8%AD%E6%B7%BB%E5%8A%A0filter/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="关于springboot-中添加filter的方法">关于springboot 中添加filter的方法</span></h1><blockquote><p> 转载自(简书作者二哥很猛)[<a href="https://www.jianshu.com/p/3d421fbce734]">https://www.jianshu.com/p/3d421fbce734]</a><br>由于springboot基于servlet3.0+,内嵌tomcat容器 因此无法像之前一样通过web.xml中配置Filter,本文基于springboot1.5.6</p></blockquote><ul><li><p>第一种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(filterName = &quot;myFilter&quot;,urlPatterns = &quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@ServletComponentScan(basePackages = &quot;com.fanyin.eghm&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EghmApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EghmApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@ServletComponentScan 所扫描的包路径必须包含该Filter</p></li><li><p>第二种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">filterRegistrationBean</span><span class="hljs-params">()</span></span>&#123;<br>        FilterRegistrationBean bean = <span class="hljs-keyword">new</span> FilterRegistrationBean();<br>        bean.setFilter(<span class="hljs-keyword">new</span> MyFilter2());<br>        bean.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>第三种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;proxyFilter&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Filter <span class="hljs-title">filter</span> <span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Filter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(javax.servlet.FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> </span>&#123;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DelegatingFilterProxyRegistrationBean <span class="hljs-title">delegatingFilterProxyRegistrationBean</span><span class="hljs-params">()</span></span>&#123;<br>        DelegatingFilterProxyRegistrationBean bean = <span class="hljs-keyword">new</span> DelegatingFilterProxyRegistrationBean(<span class="hljs-string">&quot;proxyFilter&quot;</span>);<br>        bean.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>第四种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;myFilter&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Filter <span class="hljs-title">filter</span> <span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Filter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(javax.servlet.FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> </span>&#123;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>            &#125;<br>        &#125;;<br>    &#125;<br></code></pre></td></tr></table></figure><p>说明<br>第二种和第三种类似,均实现了AbstractFilterRegistrationBean接口,而该接口间接实现了ServletContextInitializer，springboot在启动容器后会查找实现该接口的bean，并调用onStartup()方法添加自定义的Filter。<br>两者的区别 DelegatingFilterProxyRegistrationBean 通过传入的proxyFilter名字,在WebApplicationContext查找该Fillter Bean，并通过DelegatingFilterProxy生成基于该Bean的代理Filter对象，而 FilterRegistrationBean 则是直接设置一个Filter，因此该Filter可以有spring容器管理,也可不用spring管理。<br>注意：如果Filter声明为一个Bean，则不需要定义为FilterRegistrationBean，也会被spring发现并添加。<br>方法四 该方式无法定义拦截规则等，默认全局。</p></li></ul><p>EmbeddedWebApplicationContext 容器启动后执行 springboot 2.0 变更为ServletWebServerApplicationContext 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selfInitialize</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        prepareEmbeddedWebApplicationContext(servletContext);<br>        ConfigurableListableBeanFactory beanFactory = getBeanFactory();<br>        ExistingWebApplicationScopes existingScopes = <span class="hljs-keyword">new</span> ExistingWebApplicationScopes(<br>                beanFactory);<br>        WebApplicationContextUtils.registerWebApplicationScopes(beanFactory,<br>                getServletContext());<br>        existingScopes.restore();<br>        WebApplicationContextUtils.registerEnvironmentBeans(beanFactory,<br>                getServletContext());<br>        <span class="hljs-keyword">for</span> (ServletContextInitializer beans : getServletContextInitializerBeans()) &#123;<br>            beans.onStartup(servletContext);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>getServletContextInitializerBeans() 会返回实现了ServletContextInitializer接口的集合,同时初始化一些数据,如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServletContextInitializerBeans</span><span class="hljs-params">(ListableBeanFactory beanFactory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.initializers = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;Class&lt;?&gt;, ServletContextInitializer&gt;();<br>        addServletContextInitializerBeans(beanFactory);<br>        addAdaptableBeans(beanFactory);<br>        List&lt;ServletContextInitializer&gt; sortedInitializers = <span class="hljs-keyword">new</span> ArrayList&lt;ServletContextInitializer&gt;();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;?, List&lt;ServletContextInitializer&gt;&gt; entry : <span class="hljs-keyword">this</span>.initializers<br>                .entrySet()) &#123;<br>            AnnotationAwareOrderComparator.sort(entry.getValue());<br>            sortedInitializers.addAll(entry.getValue());<br>        &#125;<br>        <span class="hljs-keyword">this</span>.sortedList = Collections.unmodifiableList(sortedInitializers);<br>    &#125;<br></code></pre></td></tr></table></figure><p>addAdaptableBeans addServletContextInitializerBeans 在调用onStartup()方法之前会添加Filter与Servlet,注意Filter与Servlet必须已经声明为Bean<br>第一种则最终也是采用第二种方式,区别就是在springboot启动时将扫描到的包路径作为入参传递给ServletComponentRegisteringPostProcessor 而该类实现了BeanFactoryPostProcessor接口,因此在BeanFactory初始化后,会调用postProcessBeanFactory()方法,在该方法中通过之前传入的包来扫描相应的类,并将@WebFilter的类由相应的处理器转换为FilterRegistrationBean。<br>ServletComponentRegisteringPostProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">ServletComponentRegisteringPostProcessor(Set&lt;String&gt; packagesToScan) &#123;<br>    <span class="hljs-keyword">this</span>.packagesToScan = packagesToScan;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">if</span> (isRunningInEmbeddedContainer()) &#123;<br>        ClassPathScanningCandidateComponentProvider componentProvider = createComponentProvider();<br>        <span class="hljs-keyword">for</span> (String packageToScan : <span class="hljs-keyword">this</span>.packagesToScan) &#123;<br>            scanPackage(componentProvider, packageToScan);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scanPackage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        ClassPathScanningCandidateComponentProvider componentProvider,</span></span><br><span class="hljs-params"><span class="hljs-function">        String packageToScan)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (BeanDefinition candidate : componentProvider<br>            .findCandidateComponents(packageToScan)) &#123;<br>        <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> ScannedGenericBeanDefinition) &#123;<br>            <span class="hljs-keyword">for</span> (ServletComponentHandler handler : handlers) &#123;<br>                handler.handle(((ScannedGenericBeanDefinition) candidate),<br>                        (BeanDefinitionRegistry) <span class="hljs-keyword">this</span>.applicationContext);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>WebFilterHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">WebFilterHandler() &#123;<br>    <span class="hljs-keyword">super</span>(WebFilter.class);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doHandle</span><span class="hljs-params">(Map&lt;String, Object&gt; attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">        ScannedGenericBeanDefinition beanDefinition,</span></span><br><span class="hljs-params"><span class="hljs-function">        BeanDefinitionRegistry registry)</span> </span>&#123;<br>    BeanDefinitionBuilder builder = BeanDefinitionBuilder<br>            .rootBeanDefinition(FilterRegistrationBean.class);<br>    builder.addPropertyValue(<span class="hljs-string">&quot;asyncSupported&quot;</span>, attributes.get(<span class="hljs-string">&quot;asyncSupported&quot;</span>));<br>    builder.addPropertyValue(<span class="hljs-string">&quot;dispatcherTypes&quot;</span>, extractDispatcherTypes(attributes));<br>    builder.addPropertyValue(<span class="hljs-string">&quot;filter&quot;</span>, beanDefinition);<br>    builder.addPropertyValue(<span class="hljs-string">&quot;initParameters&quot;</span>, extractInitParameters(attributes));<br>    String name = determineName(attributes, beanDefinition);<br>    builder.addPropertyValue(<span class="hljs-string">&quot;name&quot;</span>, name);<br>    builder.addPropertyValue(<span class="hljs-string">&quot;servletNames&quot;</span>, attributes.get(<span class="hljs-string">&quot;servletNames&quot;</span>));<br>    builder.addPropertyValue(<span class="hljs-string">&quot;urlPatterns&quot;</span>,<br>            extractUrlPatterns(<span class="hljs-string">&quot;urlPatterns&quot;</span>, attributes));<br>    registry.registerBeanDefinition(name, builder.getBeanDefinition());<br>&#125;<br></code></pre></td></tr></table></figure><p>添加自定义Servlet 也可采用方法一@WebServlet 或者ServletRegistrationBean<br>添加自定义Listener也可以采用方法一 @WebListener或者ServletListenerRegistrationBean ,注意监听事件是泛型</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;关于springboot-中添加filter的方法&quot;&gt;关于springboot 中添加filter的方法&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 转载自(简书作者二哥很猛)[&lt;a href=&quot;https://www.jianshu.co</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
    <category term="filter" scheme="https://mirsery.github.io/tags/filter/"/>
    
  </entry>
  
  <entry>
    <title>springboot 中应用缓存（一）</title>
    <link href="https://mirsery.github.io/2021/07/12/java/springboot%20%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98(%E4%B8%80)/"/>
    <id>https://mirsery.github.io/2021/07/12/java/springboot%20%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98(%E4%B8%80)/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="springboot-中应用缓存一">springboot 中应用缓存（一）</span></h1><!-- toc --><ul><li><a href="#springboot-%E7%BC%93%E5%AD%98%E6%94%AF%E6%8C%81">springboot 缓存支持</a></li><li><a href="#cachemanager-%E7%9A%84%E4%BD%BF%E7%94%A8">CacheManager 的使用</a></li></ul><!-- tocstop --><p>一般情况的程序的压力瓶颈在数据库。当需要重复的获取相同的数据或者获取的数据更新周期很慢时，我们会进行如果一次又一次直接进行数据库的请求或远程服务的调用会导致IO的阻塞，从而导致程序性能的恶化。</p><h2><span id="springboot-缓存支持">springboot 缓存支持</span></h2><p>springboot定义了org.springframework.cache.CacheManager和org.springframework.cache.Cache接口用来统一不通的缓存技术。其中CacheManager是Spring提供的各种缓存技术抽象接口，Cache接口包含缓存的各种操作（增加、删除、获得缓存）。</p><p>CacheManager 的实现</p><table><thead><tr><th>CacheManager</th><th>描述</th></tr></thead><tbody><tr><td>SimpleCacheManager</td><td>使用简单的Collection来存储缓存，主要用来测试用途</td></tr><tr><td>ConcurrentMapCacheManager</td><td>使用ConcurrentMap来存储缓存</td></tr><tr><td>NoOpCacheManager</td><td>仅做测试用途，不会实际存储缓存</td></tr><tr><td>EhCacheManager</td><td>使用EhCache作为缓存技术</td></tr><tr><td>GuavaCacheManager</td><td>使用Google Guava的GuavaCache做为缓存技术</td></tr><tr><td>HazelcastCacheManager</td><td>使用Hazelcast作为缓存技术</td></tr><tr><td>JCacheCacheManager</td><td>支持JCache（JSR-107)标准的实现作为缓存技术，如Apache Commons JCS</td></tr><tr><td>RedisCacheManager</td><td>使用redis作为缓存技术</td></tr></tbody></table><h2><span id="cachemanager-的使用">CacheManager 的使用</span></h2><blockquote><p>1、 <a href="#CacheManager_1">注册bean</a><br>2、<a href="#CacheManager_2">开启声明缓存支持</a><br>3、<a href="#CacheManager_3">声明缓存规则</a></p></blockquote><ol><li><span id="CacheManager_1">注册Bean</span><br> 在pom.xml中引入如下:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml:n">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;<br>    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;<br>    &lt;version&gt;2.10.6&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>根据查看源码,可知<strong>spring-boot-starter-cache</strong> 引入<strong>spring-context-support-5.2.2.RELEASE.jar</strong> 包，查看源码<strong>org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java:n">/*<br> * Copyright 2012-2019 the original author or authors.<br> *<br> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);<br> * you may not use this file except in compliance with the License.<br> * You may obtain a copy of the License at<br> *<br> *      https://www.apache.org/licenses/LICENSE-2.0<br> *<br> * Unless required by applicable law or agreed to in writing, software<br> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,<br> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br> * See the License for the specific language governing permissions and<br> * limitations under the License.<br> */<br><br>package org.springframework.boot.autoconfigure.cache;<br><br>import net.sf.ehcache.Cache;<br>import net.sf.ehcache.CacheManager;<br><br>import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;<br>import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;<br>import org.springframework.boot.autoconfigure.condition.ResourceCondition;<br>import org.springframework.cache.ehcache.EhCacheCacheManager;<br>import org.springframework.cache.ehcache.EhCacheManagerUtils;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Conditional;<br>import org.springframework.context.annotation.Configuration;<br>import org.springframework.core.io.Resource;<br><br>/**<br> * EhCache cache configuration. Only kick in if a configuration file location is set or if<br> * a default configuration file exists.<br> *<br> * @author Eddú Meléndez<br> * @author Stephane Nicoll<br> * @author Madhura Bhave<br> */<br>@Configuration(proxyBeanMethods = false)<br>@ConditionalOnClass(&#123; Cache.class, EhCacheCacheManager.class &#125;)<br>@ConditionalOnMissingBean(org.springframework.cache.CacheManager.class)<br>@Conditional(&#123; CacheCondition.class, EhCacheCacheConfiguration.ConfigAvailableCondition.class &#125;)<br>class EhCacheCacheConfiguration &#123;<br><br>@Bean<br>EhCacheCacheManager cacheManager(CacheManagerCustomizers customizers, CacheManager ehCacheCacheManager) &#123;<br>return customizers.customize(new EhCacheCacheManager(ehCacheCacheManager));<br>&#125;<br><br>@Bean<br>@ConditionalOnMissingBean<br>CacheManager ehCacheCacheManager(CacheProperties cacheProperties) &#123;<br>Resource location = cacheProperties.resolveConfigLocation(cacheProperties.getEhcache().getConfig());<br>if (location != null) &#123;<br>return EhCacheManagerUtils.buildCacheManager(location);<br>&#125;<br>return EhCacheManagerUtils.buildCacheManager();<br>&#125;<br>/**<br> * Determine if the EhCache configuration is available. This either kick in if a<br> * default configuration has been found or if property referring to the file to use<br> * has been set.<br> */<br>static class ConfigAvailableCondition extends ResourceCondition &#123;<br>ConfigAvailableCondition() &#123;<br>super(&quot;EhCache&quot;, &quot;spring.cache.ehcache.config&quot;, &quot;classpath:/ehcache.xml&quot;);<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以自动注册bean。配置文件默认地址是<strong>classpath:/ehcache.xml</strong></p><ol><li><span id="CacheManager_2">开启声明缓存支持</span><br> 开启缓存支持只需要在配置类中增加**@EnableCaching**注解即可。</li><li><span id="#CacheManager_3">声明缓存规则</span></li></ol><table><thead><tr><th>注解</th><th>解释</th></tr></thead><tbody><tr><td>@Cacheable</td><td>在方法前spring 先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放进缓存</td></tr><tr><td>@CachePut</td><td>无论怎样，都会将方法的返回值放到缓存中。@CachePut的属性与@Cacheable保存一致。</td></tr><tr><td>@CacheEvict</td><td>将一条或多条数据从缓存中删除</td></tr><tr><td>@Caching</td><td>可以通过@Caching注解组合多个注解策略在一个方法上</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;springboot-中应用缓存一&quot;&gt;springboot 中应用缓存（一）&lt;/span&gt;&lt;/h1&gt;&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#springboot-%E7%BC%93%E5%AD%98%E6%94%AF%E6%8</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
    <category term="cache" scheme="https://mirsery.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>springboot 中应用缓存（二）</title>
    <link href="https://mirsery.github.io/2021/07/12/java/springboot%20%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98(%E4%BA%8C)/"/>
    <id>https://mirsery.github.io/2021/07/12/java/springboot%20%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98(%E4%BA%8C)/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<p>#springboot 中应用缓存（二）</p><blockquote><p> 项目中如果引用了shiro框架的话，缓存实例的引用需要增加@lazy标签或者采用手动注入Bean的方式</p></blockquote><!-- toc --><!-- tocstop --><p>##Spring Boot默认的ConcurrentMapCacheManager</p><ol><li>添加缓存</li><li>application中开启**@EnableCaching**标注</li><li>创建service层<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java:n">@Service<br>public class CacheDemoService &#123;<br><br>    @CachePut(value = &quot;test&quot;, key = &quot;#key&quot;)//将返回的数据写入缓存 <br>    public String getMessage(String msg, String key) &#123;<br>        System.out.println(&quot;CachePut the message, key : &quot; + key);<br>        return msg;<br>    &#125;<br><br>    @Cacheable(value = &quot;test&quot;, key = &quot;#key&quot;)    //第一次执行方法缓存，第二次若参数相同时则不会触发方法，而是从缓存中直接返回数据<br>    public String getDemo(String key) &#123;<br>        String msg = &quot;hello world cache&quot;;<br>        System.out.println(&quot;Cacheable the message, key : &quot; + key);<br>        return msg;<br>    &#125;<br><br>    @CacheEvict(value = &quot;test&quot;, key = &quot;#key&quot;)<br>    public void deleteCache(String key) &#123;<br>        System.out.println(&quot;delete the cache key : &quot; + key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>##SpringBoot中使用其他缓存技术<br>###EhCache</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>Springboot 会自动配置EhCacheManager的Bean<br>###Guava</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>18.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>###Redis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#springboot 中应用缓存（二）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 项目中如果引用了shiro框架的话，缓存实例的引用需要增加@lazy标签或者采用手动注入Bean的方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- toc --&gt;



&lt;!-- tocs</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
    <category term="cache" scheme="https://mirsery.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>springboot 组合注解和元注解</title>
    <link href="https://mirsery.github.io/2021/07/12/java/springboot%20%E7%BB%84%E5%90%88%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%85%83%E6%B3%A8%E8%A7%A3/"/>
    <id>https://mirsery.github.io/2021/07/12/java/springboot%20%E7%BB%84%E5%90%88%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%85%83%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="springboot-组合注解和元注解">springboot 组合注解和元注解</span></h1><p><strong>元注解</strong> 指可以注解到别的注解上的注解，被注解的注解称之为组合注解，组合注解具有元注解的功能。<br>示例<br>AnnotationMain</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationMain</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(DemoConfig.class);<br>        DemoService service = context.getBean(DemoService.class);<br>        service.outputResult();<br>        context.close();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>WiselyConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> WiselyConfiguration &#123;<br><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>DemoConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WiselyConfiguration(&quot;com.xx.annotation&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoConfig</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>DemoService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoService</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outputResult</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;从组合注解中获取bean&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;springboot-组合注解和元注解&quot;&gt;springboot 组合注解和元注解&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;元注解&lt;/strong&gt; 指可以注解到别的注解上的注解，被注解的注解称之为组合注解，组合注解具有元注解的功能。&lt;br&gt;示例&lt;b</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
    <category term="annotation" scheme="https://mirsery.github.io/tags/annotation/"/>
    
  </entry>
  
  <entry>
    <title>springboot 中新增异步任务</title>
    <link href="https://mirsery.github.io/2021/07/12/java/springboot%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8/"/>
    <id>https://mirsery.github.io/2021/07/12/java/springboot%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="springboot-中新增异步任务">springboot 中新增异步任务</span></h1><blockquote><p> 一般情况下，异步任务主要是处理一些相对耗时的任务。比如邮件、短信等信息的推送。</p></blockquote><p>springboot中使用支持异步任务开箱即用。<br>1、首先在application中添加 <em><strong>@EnableAsync</strong></em>注解<br>2、新增一个compent组件，并且在application中添加其扫描包地址<br>3、在新建的compent中使用***@Async**注解注释方法即可实现任务的异步调用。</p><p>下面是示例代码</p><p>1、WebTestApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.xxxx.component&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebTestApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(WebTestApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、TestController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PushCompent pushCompent;<br>    <span class="hljs-meta">@PostMapping(&quot;/testAsync&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testAsync</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String requestBody)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">long</span> time = System.currentTimeMillis();<br>        Future&lt;Boolean&gt; r1 = pushCompent.pushToAndroid(requestBody);<br>        Future&lt;Boolean&gt; r2 = pushCompent.pushToIos(requestBody);<br>        Future&lt;Boolean&gt; r3 = pushCompent.pushToWeb(requestBody);<br>        <span class="hljs-keyword">for</span> (; ; ) &#123;<br>            <span class="hljs-keyword">if</span> (r1.isDone() &amp;&amp; r2.isDone() &amp;&amp; r3.isDone()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cost millis is &quot;</span> + (System.currentTimeMillis() - time);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、PushCompent.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PushCompent</span> </span>&#123;<br><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Future&lt;Boolean&gt; <span class="hljs-title">pushToAndroid</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AsyncResult&lt;&gt;(<span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Future&lt;Boolean&gt; <span class="hljs-title">pushToIos</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread.sleep(<span class="hljs-number">2345</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AsyncResult&lt;&gt;(<span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Future&lt;Boolean&gt; <span class="hljs-title">pushToWeb</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread.sleep(<span class="hljs-number">4567</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AsyncResult&lt;&gt;(<span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p>注意事项:<br>如下方式会使@Async失效</p><ul><li>异步方法使用static修饰</li><li>异步类没有使用@Component注解（或其他注解）导致spring无法扫描到异步类</li><li>异步方法不能与调用异步方法的方法在同一个类中</li><li>类中需要使用@Autowired或@Resource等注解自动注入，不能自己手动new对象</li><li>如果使用SpringBoot框架必须在启动类中增加@EnableAsync注解</li><li>在Async 方法上标注@Transactional是没用的。 在Async 方法调用的方法上标注@Transactional 有效</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;springboot-中新增异步任务&quot;&gt;springboot 中新增异步任务&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 一般情况下，异步任务主要是处理一些相对耗时的任务。比如邮件、短信等信息的推送。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
    <category term="异步任务" scheme="https://mirsery.github.io/tags/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>在springboot中使用计划任务</title>
    <link href="https://mirsery.github.io/2021/07/12/java/springboot%E4%B8%AD%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://mirsery.github.io/2021/07/12/java/springboot%E4%B8%AD%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="在springboot中使用计划任务">在springboot中使用计划任务</span></h1><p>1、首先在配置类中新增***@EnableScheduing<em><strong>来开启对计划任务的支持<br>2、在需要执行计划任务的方法上注解</strong></em>@Scheduled***声明这是一个计划任务<br>3、Spring通过@Scheduled支持多种类型的计划任务，包含cron、fixDelay、fixRate等</p><p>示例代码:<br>Application</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.xxxx.xxSchedule&quot;)</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebTestApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(WebTestApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleTaskService</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;YYYY-MM-dd HH:mm:ss&quot;</span>);<br>    <span class="hljs-meta">@Scheduled(fixedRate = 5000)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task1</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(dateFormat.format(<span class="hljs-keyword">new</span> Date()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>@Scheduled注解可以控制方法定时执行，其中有三个参数可选择：</p><ul><li>1、fixedDelay控制方法执行的间隔时间，是以上一次方法执行完开始算起，如上一次方法执行阻塞住了，那么直到上一次执行完，并间隔给定的时间后，执行下一次。</li><li>2、fixedRate是按照一定的速率执行，是从上一次方法执行开始的时间算起，如果上一次方法阻塞住了，下一次也是不会执行，但是在阻塞这段时间内累计应该执行的次数，当不再阻塞时，一下子把这些全部执行掉，而后再按照固定速率继续执行。</li><li>3、cron表达式可以定制化执行任务，但是执行的方式是与fixedDelay相近的，也是会按照上一次方法结束时间开始算起。</li><li>4、initialDelay 。如： @Scheduled(initialDelay = 10000,fixedRate = 15000) 这个定时器就是在上一个的基础上加了一个initialDelay = 10000 意思就是在容器启动后,延迟10秒后再执行一次定时器,以后每15秒再执行一次该定时器。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;在springboot中使用计划任务&quot;&gt;在springboot中使用计划任务&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;1、首先在配置类中新增***@EnableScheduing&lt;em&gt;&lt;strong&gt;来开启对计划任务的支持&lt;br&gt;2、在需要执行计划任务的方法上注</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
    <category term="计划任务" scheme="https://mirsery.github.io/tags/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>springboot自动配置</title>
    <link href="https://mirsery.github.io/2021/07/12/java/springboot%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>https://mirsery.github.io/2021/07/12/java/springboot%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="自动配置">自动配置</span></h1><h2><span id="自动配置中使用的条件化注解">自动配置中使用的条件化注解</span></h2><table><thead><tr><th align="center">条件化注解</th><th align="center">配置生效条件</th></tr></thead><tbody><tr><td align="center">@ConditionalOnBean</td><td align="center">配置了某个特定的Bean</td></tr><tr><td align="center">@ConditionalOnMissingBean</td><td align="center">没有配置特定的Bean</td></tr><tr><td align="center">@ConditionalOnClass</td><td align="center">Classpath中有特定的类</td></tr><tr><td align="center">@ConditionalOnMissingClass</td><td align="center">Classpath中缺少指定的类</td></tr><tr><td align="center">@ConditionalOnExpression</td><td align="center">给定的Spring Expression Language(SpEL)表达式计算结果为true</td></tr><tr><td align="center">@ConditionalOnJava</td><td align="center">Java版本匹配特定值或者或者一个范围值</td></tr><tr><td align="center">@ConditionalOnJndi</td><td align="center">参数中给定的JND的位置必须存在一个，如果没有参数，则要有JNDI InitialContext</td></tr><tr><td align="center">@ConditionalOnProperty</td><td align="center">指定的配置属性要有一个明确的值</td></tr><tr><td align="center">@ConditionalOnResource</td><td align="center">Classpath里需要有特定的资源</td></tr><tr><td align="center">@ConditionalOnWebApplication</td><td align="center">这是一个web应用</td></tr><tr><td align="center">@ConditionalOnNotWebApplication</td><td align="center">非web应用</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;自动配置&quot;&gt;自动配置&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;自动配置中使用的条件化注解&quot;&gt;自动配置中使用的条件化注解&lt;/span&gt;&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;条件化注解&lt;/th&gt;</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="springboot" scheme="https://mirsery.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>改善java程序的一些建议（笔记）</title>
    <link href="https://mirsery.github.io/2021/07/12/java/%E6%94%B9%E5%96%84java%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/"/>
    <id>https://mirsery.github.io/2021/07/12/java/%E6%94%B9%E5%96%84java%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<p>##不使用stop方法停止线程<br>stop是一个过时的方法。Thread类的stop方法会根据线程状态来判断是终结线程还是设置线程为不可运行的状态，对于未启动的线程(线程状态为NEW)来说，会设置其标志位为不可启动，而其他的状态则是直接停止。<br>在新的jdk中如果当时线程的状态不是NEW，则会抛出IllegalThreadStateException异常。<br>stop会直接关闭所有的子线程并不保证子线程的逻辑完整性。<br>##使用线程异常处理器提升系统的可靠性<br>在jdk1.5之后添加一个setUncaughtExceptionHandler方法，实现了线程异常捕捉和处理。构建高可用的服务需要我们在出现异常的时候捕捉异常，并重启一个新的线程进行工作。在生产环境中我们需要注意以下三个比较重要的问题:</p><ul><li>共享资源锁定<br>  如果异常产生的原因是资源被锁定，自动重启应用只会增加系统的负担，无法提供不间断的服务。例如一个即时通信服务器(XMPP server)出现信息不能写入的情况，即使重启服务也无法解决问题，对此最好的解决方法就是停止所有的线程释放资源。</li><li>脏数据引起的系统逻辑混乱<br>  异常的产生中断了正在执行的业务逻辑，特别是如果正在执行一个原子操作(像即时通信服务器中的用户验证和签到这两个事情因该在同一个操作中处理，不允许出现验证成功但签到不成功的情况)，但如果此时抛出了运行期异常就可能会破坏正常的业务逻辑，例如如果用户的验证通过了，但是签到不成功的情况，在这情况下应该重启应用服务器，虽然可以提供服务但是对部分用户则产生了逻辑异常。</li><li>内存溢出<br>  线程异常了，但由于该线程创建的对象并不会马上回收，如果在重新启动新的线程在创建一批对象，特别是加入了场景接管，就非常危险了，例如通过即时通信服务重启一个线程必须保证原在线用户的<code>透明性</code>(用户不会察觉服务的重启)，在这种情况下就需要在线程启动初始化的时候加载大量对象以保证用户的状态信息，但是如果线程反复重启很可能引起OutOfMemory内存泄漏问题。<br>##volatile不能保证数据的同步性<br>volatile只能保证工作内存中的数据是从主内存中读取的最新的值，但是并不能保证数据的同步性。<br>(1）第一个时间片段<br>A线程获得执行机会，因为有关键字volatile修饰，所以它从主内存中获得count的最新值998，接下来的事情又分为两种类型：<br>如果是单CPU，此时调度器暂停A线程执行，出让执行机会给B线程，于是B线程也获得了count的最新值998。<br>如果是多CPU，此时线程A继续执行，而线程B也同时获得count的最新值998。<br>（2）第二个时间片段<br>如果是单CPU, B线程执行完加1动作（这是一个原子处理），count的值为999，由于是volatile类型的变量，所以直接写入主内存，然后A线程继续执行，计算的结果也是999，重新写入主内存中。<br>如果是多CPU, A线程执行完加1动作后修改主内存的变量count为999，线程B执行完毕后也修改主内存中的变量为999。<br>这两个时间片段执行完毕后，原本期望的结果为1000，但运行后的值却为999，这表示出现了线程不安全的情况。这也是我们要说明的：volatile关键字并不能保证线程安全，它只能保证当线程需要该变量的值时能够获得最新的值，而不能保证多个线程修改的安全性。<br>##异步运算考虑使用Callable接口<br>多线程应用实现的方式有三种:<br>1、 继承Thread类<br>2、 实现Runnable接口<br>3、 实现callable接口<br>  实现callable接口表示他是一个可调度的任务，需要调用执行器Executor来执行。callable允许抛出异常以及允许有返回值。<br>##Lock和Synchronized的区别</li><li>Lock(显式锁)<br>  显式锁是对象级别的锁，是跟随对象的，简单的说把Lock定义为多线程类的私有属性是起不到资源互斥作用的，除非把Lock定义为所有线程的共享变量。<ul><li>Lock锁支持更细粒度的锁控制</li><li>Lock是无阻塞锁<pre><code>      当线程A持有锁的时候，线程B也期望获得锁，此时如果程序中使用的是显式锁则线程B为等待状态(在通常情况中也认         为该线程被阻塞了)，若使用的是内部锁则为阻塞状态。</code></pre></li><li>Lock可以实现公平锁<pre><code>     什么叫非公平锁呢？当一个线程A持有锁，而线程B、C处于阻塞（或等待）状态时，若线程A释放锁，JVM将从线程B、C中随机选择一个线程持有锁并使其获得执行权，这叫做非公平锁（因为它抛弃了先来后到的顺序）；若JVM选择了等待时间最长的一个线程持有锁，则为公平锁（保证每个线程的等待时间均衡）。需要注意的是，即使是公平锁，JVM也无法准确做到“公平”，在程序中不能以此作为精确计算。</code></pre>显式锁默认是非公平锁，但可以在构造函数中加入参数true来声明出公平锁，而synchronized实现的是非公平锁，它不能实现公平锁。</li><li>Lock是代码级的，synchronized是JVM级的<pre><code>      Lock是通过编码实现的，synchronized是在运行期由JVM解释的，相对来说synchronized的优化可能性更高，毕竟是在最核心部分支持的，Lock的优化则需要用户自行考虑。</code></pre>显式锁和内部锁的功能各不相同，在性能上也稍有差别，但随着JDK的不断推进，相对来说，显式锁使用起来更加便利和强大，在实际开发中选择哪种类型的锁就需要根据实际情况考虑了：灵活、强大则选择Lock，快捷、安全则选择synchronized。<br>##使用CountDownLatch协调子线程<br>CountDownLatch的作用是一个计数器，每个线程在运行完毕之后都会执行countDown表示自己已经结束，这对于多个子任务的计算特别有效，比如一个异步任务需要拆分成10个子任务执行，主任务必须知道子任务是否完成，所有子任务完成后才能进行合并运算，从而保证了一个主任务的逻辑正确性。<br>##CycliBarrier让多线程个齐步走<br>CyclicBarrier关卡可以让所有线程全部处于等待状态（阻塞），然后在满足条件的情况下继续执行，这就好比是一条起跑线，不管是如何到达起跑线的，只要到达这条起跑线就必须等待其他人员，待人员到齐后再各奔东西，CyclicBarrier关注的是汇合点的信息，而不在乎之前或之后做何处理。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##不使用stop方法停止线程&lt;br&gt;stop是一个过时的方法。Thread类的stop方法会根据线程状态来判断是终结线程还是设置线程为不可运行的状态，对于未启动的线程(线程状态为NEW)来说，会设置其标志位为不可启动，而其他的状态则是直接停止。&lt;br&gt;在新的jdk中如果当</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="笔记" scheme="https://mirsery.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java热部署的简单介绍</title>
    <link href="https://mirsery.github.io/2021/07/12/java/%E7%83%AD%E9%83%A8%E7%BD%B2%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86/"/>
    <id>https://mirsery.github.io/2021/07/12/java/%E7%83%AD%E9%83%A8%E7%BD%B2%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="java热部署的简单介绍">java热部署的简单介绍</span></h1><!-- toc --><ul><li><a href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">简单介绍</a></li><li><a href="#%E6%BA%90%E7%A0%81%E9%83%A8%E5%88%86">源码部分</a></li></ul><!-- tocstop --><h2><span id="简单介绍">简单介绍</span></h2><p>在类加载器中，类只可以加载一次并且不可卸载。java类只能被加载一次，并且无法卸载。想要实现热部署可以分以下三个步骤：<br>1、销毁该自定义ClassLoader<br>2、更新class类文件<br>3、创建新的ClassLoader去加载更新后的class类文件。</p><h2><span id="源码部分">源码部分</span></h2><ol><li><p>自定义类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            String fileName = name.substring(name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span> )+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.class&quot;</span> ;<br>            InputStream inputStream = <span class="hljs-keyword">this</span>.getClass().getResourceAsStream(fileName);<br>            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inputStream.available()];<br>            inputStream.read(b);<br>            <span class="hljs-keyword">return</span> defineClass(name, b, <span class="hljs-number">0</span>, b.length);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);<br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>替换的类</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//class 1</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helloword</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello world! V1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//class2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helloword</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello world! V2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>测试类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( String[] args )</span> <span class="hljs-keyword">throws</span> Exception</span><br><span class="hljs-function">    </span>&#123;<br>        loadHelloWorld();<br>        System.gc();<span class="hljs-comment">//等待gc回收</span><br>        Thread.sleep(<span class="hljs-number">3</span>* <span class="hljs-number">1000</span>);<br>        File fileV2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;Helloword2.class&quot;</span>);<br>        File fileV1 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;target/classes/com/mirsery/test/Helloword.class&quot;</span>);<br>        fileV1.delete();<br>        fileV2.renameTo(fileV1);<br>        System.out.println(<span class="hljs-string">&quot;Update Success!&quot;</span>);<br>        loadHelloWorld();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadHelloWorld</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        MyClassLoader myClassLoader = <span class="hljs-keyword">new</span> MyClassLoader();<br>        Class&lt;?&gt; class1 = myClassLoader.findClass(<span class="hljs-string">&quot;com.test.Helloword&quot;</span>);<br>        Object obj = class1.newInstance();<br>        Method method = class1.getMethod( <span class="hljs-string">&quot;say&quot;</span>);<br>        method.invoke(obj);<br>        System.out.println(obj);<br>        System.out.println(obj.getClass());<br>        System.out.println(obj.getClass().getClassLoader());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;java热部署的简单介绍&quot;&gt;java热部署的简单介绍&lt;/span&gt;&lt;/h1&gt;&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D&quot;&gt;简单介绍&lt;/a&gt;&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="热部署" scheme="https://mirsery.github.io/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>类加载器</title>
    <link href="https://mirsery.github.io/2021/07/12/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://mirsery.github.io/2021/07/12/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2021-07-12T02:42:08.283Z</published>
    <updated>2021-07-12T02:42:08.283Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="类加载器">类加载器</span></h1><blockquote><p> 类加载器最初是为了满足java Applet的需求而开发出来的。java Applet需要从远程下载java类文件到浏览器中并执行。现在类加载器在web容器中和OSGI中得到了广泛的使用。一般情况下，我们并不需要直接和类加载进行交互，java虚拟机的默认行为已经满足大多数情况的需求了。<br>[TOC]</p></blockquote><h2><span id="类加载器基本概念">类加载器基本概念</span></h2><p>类加载器用来加载java类到虚拟机中，一般情况下Java虚拟机使用Java类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><h2><span id="网络类加载器">网络类加载器</span></h2><p>下面将通过一个网络类加载器来说明如何通过类加载器来实现组件的动态更新。即基本的场景是：Java 字节代码（.class）文件存放在服务器上，客户端通过网络的方式获取字节代码并执行。当有版本更新的时候，只需要替换掉服务器上保存的文件即可。通过类加载器可以比较简单的实现这种需求。<br>类 NetworkClassLoader负责通过网络下载 Java 类字节代码并定义出 Java 类。它的实现与 FileSystemClassLoader类似。在通过 NetworkClassLoader加载了某个版本的类之后，一般有两种做法来使用它。第一种做法是使用 Java 反射 API。另外一种做法是使用接口。需要注意的是，并不能直接在客户端代码中引用从服务器上下载的类，因为客户端代码的类加载器找不到这些类。使用 Java 反射 API 可以直接调用 Java 类的方法。而使用接口的做法则是把接口的类放在客户端中，从服务器上加载实现此接口的不同版本的类。在客户端通过相同的接口来使用这些实现类。</p><h2><span id="类加载器与-web-容器">类加载器与 Web 容器</span></h2><p>对于运行在 Java EE™容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。<br>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：</p><ul><li>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。</li><li>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</li><li>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。<br>##类加载器与 OSGi<br>OSGi™是 Java 上的动态模块系统。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方式用来管理软件的生命周期。OSGi 已经被实现和部署在很多产品上，在开源社区也得到了广泛的支持。Eclipse 就是基于 OSGi 技术来构建的。<br>OSGi 中的每个模块（bundle）都包含 Java 包和类。模块可以声明它所依赖的需要导入（import）的其它模块的 Java 包和类（通过 Import-Package），也可以声明导出（export）自己的包和类，供其它模块使用（通过 Export-Package）。也就是说需要能够隐藏和共享一个模块中的某些 Java 包和类。这是通过 OSGi 特有的类加载器机制来实现的。OSGi 中的每个模块都有对应的一个类加载器。它负责加载模块自己包含的 Java 包和类。当它需要加载 Java 核心库的类时（以 java开头的包和类），它会代理给父类加载器（通常是启动类加载器）来完成。当它需要加载所导入的 Java 类时，它会代理给导出此 Java 类的模块来完成加载。模块也可以显式的声明某些 Java 包和类，必须由父类加载器来加载。只需要设置系统属性 org.osgi.framework.bootdelegation的值即可。<br>假设有两个模块 bundleA 和 bundleB，它们都有自己对应的类加载器 classLoaderA 和 classLoaderB。在 bundleA 中包含类 com.bundleA.Sample，并且该类被声明为导出的，也就是说可以被其它模块所使用的。bundleB 声明了导入 bundleA 提供的类 com.bundleA.Sample，并包含一个类 com.bundleB.NewSample继承自 com.bundleA.Sample。在 bundleB 启动的时候，其类加载器 classLoaderB 需要加载类 com.bundleB.NewSample，进而需要加载类 com.bundleA.Sample。由于 bundleB 声明了类 com.bundleA.Sample是导入的，classLoaderB 把加载类 com.bundleA.Sample的工作代理给导出该类的 bundleA 的类加载器 classLoaderA。classLoaderA 在其模块内部查找类 com.bundleA.Sample并定义它，所得到的类 com.bundleA.Sample实例就可以被所有声明导入了此类的模块使用。对于以 java开头的类，都是由父类加载器来加载的。如果声明了系统属性 org.osgi.framework.bootdelegation=com.example.core.*，那么对于包 com.example.core中的类，都是由父类加载器来完成的。<br>OSGi 模块的这种类加载器结构，使得一个类的不同版本可以共存在 Java 虚拟机中，带来了很大的灵活性。不过它的这种不同，也会给开发人员带来一些麻烦，尤其当模块需要使用第三方提供的库的时候。下面提供几条比较好的建议：</li><li>如果一个类库只有一个模块使用，把该类库的 jar 包放在模块中，在 Bundle-ClassPath中指明即可。</li><li>如果一个类库被多个模块共用，可以为这个类库单独的创建一个模块，把其它模块需要用到的 Java 包声明为导出的。其它模块声明导入这些类。</li><li>如果类库提供了 SPI 接口，并且利用线程上下文类加载器来加载 SPI 实现的 Java 类，有可能会找不到 Java 类。如果出现了 NoClassDefFoundError异常，首先检查当前线程的上下文类加载器是否正确。通过 Thread.currentThread().getContextClassLoader()就可以得到该类加载器。该类加载器应该是该模块对应的类加载器。如果不是的话，可以首先通过 class.getClassLoader()来得到模块对应的类加载器，再通过Thread.currentThread().setContextClassLoader()来设置当前线程的上下文类加载器。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;类加载器&quot;&gt;类加载器&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 类加载器最初是为了满足java Applet的需求而开发出来的。java Applet需要从远程下载java类文件到浏览器中并执行。现在类加载器在web容器中和OSGI中得到</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="类加载器" scheme="https://mirsery.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ByteBuffer详解</title>
    <link href="https://mirsery.github.io/2021/07/12/java/ByteBuffer%20%E8%AF%A6%E8%A7%A3/"/>
    <id>https://mirsery.github.io/2021/07/12/java/ByteBuffer%20%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-07-12T02:42:08.279Z</published>
    <updated>2021-07-12T02:42:08.279Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="bytebuffer详解">ByteBuffer详解</span></h1><blockquote><p>参考了开源中国上<a href="https://my.oschina.net/talenttan/home">talent-tan</a>的一篇博客 <a href="https://my.oschina.net/talenttan/blog/889887">图解bytebuffer</a></p></blockquote><hr><p>java.nio.ByteBuffer</p><ul><li>byte get( )<br>  从当前位置获得一个字节，并将当前位置移动到下一个字节。</li><li>byte get(int index)<br>  从指定索引处获得一个字节。</li><li>ByteBuffer put(byte b)<br>  向当前位置推入一个字节，并将当前位置移动到下一个字节。返回对缓冲区的引用。</li><li>ByteBuffer put(int index,byte b)<br>  向指定索引处推入一个字节，返回对这个缓冲区的引用。</li><li>ByteBuffer get(byte[] destination)</li><li>ByteBuffer get(byte[] destination,int offset ,int length)<br>   用缓冲区中的字节来填充字节数组，或者字节数组的某个区域，并将当前位置向前移动读入的字节数个位置。<br>  如果缓冲区不够大就不会读入任何字节，并抛出BufferUnderflow Exception。返回对这个缓冲区的引用。<br>  参数: destination     要填充的字节数组<pre><code>           offset              要填充区域的偏移量            length              要填充区域的长度</code></pre></li><li>Xxx getXxx()</li><li>Xxx getXxx(int index)</li><li>ByteBuffer putXxx(xxx value)</li><li>ByteBuffer putXxx(int value,xxx value)<br>  获得或放置一个二进制数。Xxx是Int、Long、Short、Char、Float或者Double中的一个。</li><li>ByteBuffer order(ByteOrder order)</li><li>ByteBuffer order(order)<br>  设置获得字节顺序，order是ByteOrder类的常量BIG_ENDLAN或者LITTLE_ENDIAN中的一个。</li><li>static ByteBuffer allcate(int capacity)<br> 构建具有指定容量的缓冲区，该缓冲区是对给定数组的包装。</li><li>CharBuffer asCharBuffer ( )<br>  构建字符缓冲区，它是对缓冲区的包装。对该字符缓冲区的变更将在这个缓冲区中反映出来，但是该字符缓冲区<br>  有自己的位置、界限和标记。</li></ul><hr><p>java.nio.CharBuffer</p><ul><li>char get()</li><li>CharBuffer get(char[] destination)</li><li>CharBuffer get(char[] destination,int offset,int length)<br>  从这个缓冲区的当前位置开始，获取一个char值，或者一个范围内的所有char值，<br>  然后将位置向前移动越过所有读入的字符。最后两个方法将返回this。</li><li>CharBuffer put(char c)</li><li>CharBuffer put(char[] source)</li><li>CharBuffer put(char[] source,int offset,int length)</li><li>CharBuffer put(String source)</li><li>CharBuffer put(CharBuffer source)<br>从这个缓冲区的当前位置开始，放置一个char值，或者一个范围内的所有char值，然后将位置向前移动越过所有被<br>写出的字符。当放置的值是从CharBuffer读入时，将读入剩下所有剩余字符。所有方法返回this。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;bytebuffer详解&quot;&gt;ByteBuffer详解&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考了开源中国上&lt;a href=&quot;https://my.oschina.net/talenttan/home&quot;&gt;talent-tan&lt;/a&gt;的一</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="ByteBuffer" scheme="https://mirsery.github.io/tags/ByteBuffer/"/>
    
    <category term="netty" scheme="https://mirsery.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>ByteBuf 引用计数问题</title>
    <link href="https://mirsery.github.io/2021/07/12/java/Bytebuf%20%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>https://mirsery.github.io/2021/07/12/java/Bytebuf%20%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-12T02:42:08.279Z</published>
    <updated>2021-07-12T02:42:08.279Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="bytebuf-引用计数问题">ByteBuf 引用计数问题</span></h1><blockquote><p> netty框架使用过程中关于ByteBuf 的处理<br>SImpleChannelInbound 会release ByteBuf，ChannelInboundHandlerAdapter 不会影响ByteBuf的引用计数</p></blockquote><!-- toc --><ul><li><a href="#%E9%87%87%E7%94%A8%E5%B0%BE%E5%9B%9E%E6%94%B6%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE">采用尾回收自动释放</a></li><li><a href="#%E6%89%8B%E5%8A%A8%E9%87%8A%E6%94%BE">手动释放</a></li></ul><!-- tocstop --><p>下面是使用<strong>EmbeddedChannel</strong>来演示ByteBuf引用计数回收的示例</p><h2><span id="采用尾回收自动释放">采用尾回收自动释放</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">EmbeddedChannel embeddedChannel = <span class="hljs-keyword">new</span> EmbeddedChannel();<br>embeddedChannel.pipeline().addLast(<span class="hljs-keyword">new</span> MyInBound());<br>ByteBuf buf = Unpooled.buffer();<br>buf.writeBytes(<span class="hljs-string">&quot;hello world!&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>embeddedChannel.writeInbound(buf);<br>System.out.println(<span class="hljs-string">&quot;The buf refCnt is &quot;</span> + buf.refCnt());<br><span class="hljs-keyword">try</span> &#123;<br>    Thread.sleep(<span class="hljs-number">10</span> * <span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInBound</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;my inbound===&quot;</span>);<br>        ByteBuf byteBuf = (ByteBuf) msg;<br>        System.out.println(byteBuf.slice().toString(CharsetUtil.UTF_8));<br>        ctx.fireChannelRead(byteBuf);<span class="hljs-comment">//must pass Bytebuf 才能出发尾引用计数回收</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2><span id="手动释放">手动释放</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInBound</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;my inbound===&quot;</span>);<br>        ByteBuf byteBuf = (ByteBuf) msg;<br>        System.out.println(byteBuf.slice().toString(CharsetUtil.UTF_8));<br>        byteBuf.release();<br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> netty自带的编码器处理了ByteBuf的引用释放问题 例如：StringDecoder.class</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;bytebuf-引用计数问题&quot;&gt;ByteBuf 引用计数问题&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; netty框架使用过程中关于ByteBuf 的处理&lt;br&gt;SImpleChannelInbound 会release ByteBuf，</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="netty" scheme="https://mirsery.github.io/tags/netty/"/>
    
    <category term="ByteBuf" scheme="https://mirsery.github.io/tags/ByteBuf/"/>
    
  </entry>
  
  <entry>
    <title>NIO SelectionKey 类解析</title>
    <link href="https://mirsery.github.io/2021/07/12/java/Java%20NIO%20SelectionKey/"/>
    <id>https://mirsery.github.io/2021/07/12/java/Java%20NIO%20SelectionKey/</id>
    <published>2021-07-12T02:42:08.279Z</published>
    <updated>2021-07-12T02:42:08.279Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="nio-selectionkey-类解析">NIO SelectionKey 类解析</span></h1><blockquote><p> A token representing the registration of a SelectableChannel with a Selector.</p></blockquote><!-- toc --><ul><li><a href="#selectionkey%E7%B1%BB%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95">SelectionKey类解释以及用法</a></li><li><a href="#%E5%8F%98%E9%87%8F">变量</a><ul><li><a href="#op_accept-1-4"><strong>OP_ACCEPT</strong> 1 &lt;&lt; 4</a></li><li><a href="#op_connect-1-3"><strong>OP_CONNECT</strong> 1 &lt;&lt; 3</a></li><li><a href="#op_read-1-0"><strong>OP_READ</strong> 1 &lt;&lt; 0</a></li><li><a href="#op_write-1-2"><strong>OP_WRITE</strong> 1 &lt;&lt; 2</a></li></ul></li><li><a href="#%E6%96%B9%E6%B3%95">方法</a><ul><li><a href="#public-abstract-selectablechannel-channel"><strong>public abstract SelectableChannel channel()</strong></a></li></ul></li></ul><!-- tocstop --><h2><span id="selectionkey类解释以及用法">SelectionKey类解释以及用法</span></h2><p><img src="./_image/2021/969959BD-AB3E-4F9B-9133-ACDF5C67AEF6.png"><br>以下是 <strong>javadoc</strong> 对 <strong>SelectionKey</strong> 的解释：<br>A token representing the registration of a SelectableChannel with a Selector.</p><p>A selection key is created each time a channel is registered with a selector. A key remains valid until it is cancelled by invoking its cancel method, by closing its channel, or by closing its selector. Cancelling a key does not immediately remove it from its selector; it is instead added to the selector’s cancelled-key set for removal during the next selection operation. The validity of a key may be tested by invoking its isValid method.</p><p>A selection key contains two operation sets represented as integer values. Each bit of an operation set denotes a category of selectable operations that are supported by the key’s channel.</p><p>The interest set determines which operation categories will be tested for readiness the next time one of the selector’s selection methods is invoked. The interest set is initialized with the value given when the key is created; it may later be changed via the interestOps(int) method.</p><p>The ready set identifies the operation categories for which the key’s channel has been detected to be ready by the key’s selector. The ready set is initialized to zero when the key is created; it may later be updated by the selector during a selection operation, but it cannot be updated directly.</p><p>That a selection key’s ready set indicates that its channel is ready for some operation category is a hint, but not a guarantee, that an operation in such a category may be performed by a thread without causing the thread to block. A ready set is most likely to be accurate immediately after the completion of a selection operation. It is likely to be made inaccurate by external events and by I/O operations that are invoked upon the corresponding channel.</p><p>This class defines all known operation-set bits, but precisely which bits are supported by a given channel depends upon the type of the channel. Each subclass of SelectableChannel defines an validOps() method which returns a set identifying just those operations that are supported by the channel. An attempt to set or test an operation-set bit that is not supported by a key’s channel will result in an appropriate run-time exception.</p><p>It is often necessary to associate some application-specific data with a selection key, for example an object that represents the state of a higher-level protocol and handles readiness notifications in order to implement that protocol. Selection keys therefore support the attachment of a single arbitrary object to a key. An object can be attached via the attach method and then later retrieved via the attachment method.</p><p>Selection keys are safe for use by multiple concurrent threads.The operations of reading and writing the interest set will, in general, be synchronized with certain operations of the selector.Exactly how this synchronization is performed is implementation-dependent: In a naive implementation, reading or writing the interest set may block indefinitely if a selection operation is already in progress; in a high-performance implementation, reading or writing the interest set may block briefly, if at all. In any case, a selection operation will always use the interest-set value that was current at the moment that the operation began.</p><blockquote><p>selector is thread safe but Selectionkeys’s set is not!</p></blockquote><h2><span id="变量">变量</span></h2><h3><span id="op_accept-1-ltlt-4"><strong>OP_ACCEPT</strong>  1 &lt;&lt; 4</span></h3><blockquote><p> Operation-set bit for socket-accept operations<br>Suppose that a selection key’s interest set contains <strong>OP_ACCEPT</strong> at the start of a selection operation. If the selector detects that the corresponding server-socket channel is ready to accept another connection, or has an error pending, then it will add <strong>OP_ACCEPT</strong> to the key’s ready set and add the key to its <strong>selected-key set</strong>.</p></blockquote><h3><span id="op_connect-1-ltlt-3"><strong>OP_CONNECT</strong> 1 &lt;&lt; 3</span></h3><blockquote><p>Operation-set bit for socket-connect operations.<br>Operation-set bit for socket-connect operations.<br>Suppose that a selection key’s interest set contains <strong>OP_CONNECT</strong> at the start of a selection operation. If the selector detects that the corresponding socket channel is ready to complete its connection sequence, or has an error pending, then it will add <strong>OP_CONNECT</strong> to the key’s ready set and add the key to its <strong>selected-key set</strong>.</p></blockquote><h3><span id="op_read-1-ltlt-0"><strong>OP_READ</strong> 1 &lt;&lt; 0</span></h3><blockquote><p>Operation-set bit for read operations.<br>Operation-set bit for read operations.<br>Suppose that a selection key’s interest set contains <strong>OP_READ</strong> at the start of a selection operation. If the selector detects that the corresponding channel is ready for reading, has reached end-of-stream, has been remotely shut down for further reading, or has an error pending, then it will add <strong>OP_READ</strong> to the key’s ready-operation set and add the key to its <strong>selected-key set</strong>.</p></blockquote><h3><span id="op_write-1-ltlt-2"><strong>OP_WRITE</strong> 1 &lt;&lt; 2</span></h3><blockquote><p> Operation-set bit for write operations.<br>Operation-set bit for write operations.<br>Suppose that a selection key’s interest set contains <strong>OP_WRITE</strong> at the start of a selection operation. If the selector detects that the corresponding channel is ready for writing, has been remotely shut down for further writing, or has an error pending, then it will add <strong>OP_WRITE</strong> to the key’s ready set and add the key to its <strong>selected-key set</strong>.</p></blockquote><h2><span id="方法">方法</span></h2><h3><span id="public-abstract-selectablechannel-channel"><strong>public abstract SelectableChannel channel()</strong></span></h3><blockquote><p> Returns the channel for which this key was created.<br> This method will continue to return the selector even after the key is cancelled.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;nio-selectionkey-类解析&quot;&gt;NIO SelectionKey 类解析&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; A token representing the registration of a SelectableCh</summary>
      
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="nio" scheme="https://mirsery.github.io/tags/nio/"/>
    
    <category term="socket" scheme="https://mirsery.github.io/tags/socket/"/>
    
  </entry>
  
</feed>

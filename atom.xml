<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mirsery</title>
  
  <subtitle>兴趣使然博客</subtitle>
  <link href="https://mirsery.github.io/atom.xml" rel="self"/>
  
  <link href="https://mirsery.github.io/"/>
  <updated>2022-01-07T04:37:38.000Z</updated>
  <id>https://mirsery.github.io/</id>
  
  <author>
    <name>mirsery</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue模板的使用</title>
    <link href="https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-07T04:37:38.000Z</published>
    <updated>2022-01-07T04:37:38.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#vue--api--">vue社区api描述</a></li><li><a href="#--------">组件的使用和创建</a></li></ul><!-- tocstop --><p>在前端项目中经常会遇到需要动态渲染页面的功能，一般情况下我们可以采用原生的js进行手动的插入和编写。在vue项目中可以借用vue提供的方法进行模版渲染。<br>在vue3中可以采用component组件进行动态渲染，vue2中则可以采用extend来实现。本文基于vue2来展示动态渲染示例。</p><h2 id="vue社区api描述"><a href="#vue社区api描述" class="headerlink" title="vue社区api描述"></a>vue社区api描述</h2><p>Vue.extend( options )</p><ul><li>参数<ul><li>{Object} options</li></ul></li><li>用法<br> 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</li></ul><p><strong>data</strong> 选项是特例，需要注意 - 在 <strong>Vue.extend()</strong> 中它必须是函数</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mount-point&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><pre><code class="highlight js"><span class="comment">// 创建构造器</span><span class="keyword">var</span> Profile = Vue.extend(&#123;  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&#x27;</span>,  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> &#123;      <span class="attr">firstName</span>: <span class="string">&#x27;Walter&#x27;</span>,      <span class="attr">lastName</span>: <span class="string">&#x27;White&#x27;</span>,      <span class="attr">alias</span>: <span class="string">&#x27;Heisenberg&#x27;</span>    &#125;  &#125;&#125;)<span class="comment">// 创建 Profile 实例，并挂载到一个元素上。</span><span class="keyword">new</span> Profile().$mount(<span class="string">&#x27;#mount-point&#x27;</span>)</code></pre><p>结果如下：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Walter White aka Heisenberg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre><h2 id="组件的使用和创建"><a href="#组件的使用和创建" class="headerlink" title="组件的使用和创建"></a>组件的使用和创建</h2><ul><li>基本示例</li></ul><pre><code class="highlight js"><span class="comment">// 定义一个名为 button-counter 的新组件</span>Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> &#123;      <span class="attr">count</span>: <span class="number">0</span>    &#125;  &#125;,  <span class="attr">template</span>: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span>&#125;)</code></pre><p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 **<button-counter>**。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><pre><code class="highlight js"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">&#x27;#components-demo&#x27;</span> &#125;)</code></pre><p>因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。</p>]]></content>
    
    
    <summary type="html">vuejs中使用模版渲染的示例</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://mirsery.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>新增配置webstorm和vscode支持vue别名的识别</title>
    <link href="https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AEwebstorm%E5%92%8Cvscode%E6%94%AF%E6%8C%81vue%E5%88%AB%E5%90%8D%E7%9A%84%E8%AF%86%E5%88%AB/"/>
    <id>https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AEwebstorm%E5%92%8Cvscode%E6%94%AF%E6%8C%81vue%E5%88%AB%E5%90%8D%E7%9A%84%E8%AF%86%E5%88%AB/</id>
    <published>2022-01-07T01:08:33.000Z</published>
    <updated>2022-01-07T01:08:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#vue3------">vue3项目设置别名</a></li><li><a href="#-webstorm------">为webstorm配置别名识别</a></li><li><a href="#-vscode------">为vscode配置别名识别</a></li></ul><!-- tocstop --><p>vue3项目中，默认别名”@”为”src”路径。在开发的过程中我们的集成开发环境并不能很好的识别这个别名路径，导致我们不能在开发环境中实现代码依赖的跳转，影响我们的开发体验以及开发速率.</p><h2 id="vue3项目设置别名"><a href="#vue3项目设置别名" class="headerlink" title="vue3项目设置别名"></a>vue3项目设置别名</h2><p>vue项目设置别名可以在vue.config.js中进行配置</p><pre><code class="highlight js"><span class="built_in">module</span>.exports = &#123;    <span class="attr">configureWebpack</span>: &#123;        <span class="attr">resolve</span>: &#123;            <span class="attr">alias</span>: &#123;                <span class="string">&#x27;@&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>),            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="为webstorm配置别名识别"><a href="#为webstorm配置别名识别" class="headerlink" title="为webstorm配置别名识别"></a>为webstorm配置别名识别</h2><p>在项目根目录创建<strong>websotrm.config.js</strong>文件，内容大致如下所示:</p><pre><code class="highlight js"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)<span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;    <span class="keyword">return</span> path.join(__dirname, <span class="string">&#x27;.&#x27;</span>, dir)&#125;<span class="built_in">module</span>.exports = &#123;    <span class="attr">context</span>:path.resolve(__dirname,<span class="string">&#x27;./&#x27;</span>),    <span class="attr">resolve</span>: &#123;        <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],        <span class="attr">alias</span>: &#123;            <span class="string">&#x27;@&#x27;</span>: resolve(<span class="string">&#x27;src&#x27;</span>)        &#125;    &#125;&#125;</code></pre><p>在webstorm中，选择Preferences &gt; Languages &amp; Feameworks &gt; JavaScript &gt; WebPack ,选择 resolution 的mode，选择Automatically即可。</p><h2 id="为vscode配置别名识别"><a href="#为vscode配置别名识别" class="headerlink" title="为vscode配置别名识别"></a>为vscode配置别名识别</h2><p>在项目根目录创建<strong>jsconfig.json</strong>文件，内容大致如下所示:</p><pre><code class="highlight json">&#123;  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>,    <span class="attr">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,    <span class="attr">&quot;paths&quot;</span>: &#123;      <span class="attr">&quot;@/*&quot;</span>: [        <span class="string">&quot;./src/*&quot;</span>      ]    &#125;  &#125;,  <span class="attr">&quot;exclude&quot;</span>: [    <span class="string">&quot;node_modules&quot;</span>,    <span class="string">&quot;dist&quot;</span>  ]&#125;</code></pre><p>关闭vscode，重新打开项目，vscode即可实现对别名的识别。</p>]]></content>
    
    
    <summary type="html">vue项目中增加配置文件，使得开发环境可以识别自定义的vue别名能够实现代码跳转</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://mirsery.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>前端包管理私服搭建</title>
    <link href="https://mirsery.github.io/2021/12/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/"/>
    <id>https://mirsery.github.io/2021/12/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/</id>
    <published>2021-12-17T08:01:56.000Z</published>
    <updated>2021-12-17T08:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--dokcer----verdaccio">使用dokcer容器运行verdaccio</a></li><li><a href="#verdaccio--">verdaccio配置</a></li><li><a href="#----">创建用户</a></li></ul><!-- tocstop --><p>verdaccio 是一个简单的，零配置本地私有npm软件包代理注册表。verdaccio开箱即用，拥有自己的小型数据库，能够代理其他注册表（例如npmjs.org)，缓存下载的模块。</p><p><a href="https://github.com/verdaccio/verdaccio">verdaccio项目地址</a></p><h2 id="使用dokcer容器运行verdaccio"><a href="#使用dokcer容器运行verdaccio" class="headerlink" title="使用dokcer容器运行verdaccio"></a>使用dokcer容器运行verdaccio</h2><p><a href="https://hub.docker.com/r/verdaccio/verdaccio">verdaccio docker 仓库地址 </a></p><pre><code class="highlight shell">docker run --restart=always --name verdaccio --privileged=true -v /&#123;location&#125;:/verdaccio -p 4873:4873 -d verdaccio/verdaccio</code></pre><h2 id="verdaccio配置"><a href="#verdaccio配置" class="headerlink" title="verdaccio配置"></a>verdaccio配置</h2><blockquote><p>容器内 /verdaccio/conf  配置文件</p></blockquote><pre><code class="highlight yaml"><span class="comment">#</span><span class="comment"># This is the config file used for the docker images.</span><span class="comment"># It allows all users to do anything, so don&#x27;t use it on production systems.</span><span class="comment">#</span><span class="comment"># Do not configure host and port under `listen` in this file</span><span class="comment"># as it will be ignored when using docker.</span><span class="comment"># see https://verdaccio.org/docs/en/docker#docker-and-custom-port-configuration</span><span class="comment">#</span><span class="comment"># Look here for more config file examples:</span><span class="comment"># https://github.com/verdaccio/verdaccio/tree/master/conf</span><span class="comment">#</span><span class="comment"># path to a directory with all packages</span><span class="attr">storage:</span> <span class="string">/verdaccio/storage/data</span><span class="comment"># path to a directory with plugins to include</span><span class="attr">plugins:</span> <span class="string">/verdaccio/plugins</span><span class="attr">web:</span>  <span class="comment"># WebUI is enabled as default, if you want disable it, just uncomment this line</span>  <span class="comment">#enable: false</span>  <span class="attr">title:</span> <span class="string">Verdaccio</span>  <span class="comment"># comment out to disable gravatar support</span>  <span class="comment"># gravatar: false</span>  <span class="comment"># by default packages are ordercer ascendant (asc|desc)</span>  <span class="comment"># sort_packages: asc</span>  <span class="comment"># darkMode: true</span>  <span class="comment"># logo: http://somedomain/somelogo.png</span>  <span class="comment"># favicon: http://somedomain/favicon.ico | /path/favicon.ico</span><span class="comment"># translate your registry, api i18n not available yet</span><span class="comment"># i18n:</span><span class="comment"># list of the available translations https://github.com/verdaccio/ui/tree/master/i18n/translations</span><span class="comment">#   web: en-US</span><span class="attr">auth:</span>  <span class="attr">htpasswd:</span>    <span class="attr">file:</span> <span class="string">/verdaccio/storage/htpasswd</span>    <span class="comment"># Maximum amount of users allowed to register, defaults to &quot;+infinity&quot;.</span>    <span class="comment"># You can set this to -1 to disable registration.</span>    <span class="comment"># max_users: 1000</span><span class="comment"># a list of other known repositories we can talk to</span><span class="attr">uplinks:</span>  <span class="attr">taobao:</span>    <span class="attr">url:</span> <span class="string">https://registry.npm.taobao.org/</span>  <span class="attr">npmjs:</span>    <span class="attr">url:</span> <span class="string">https://registry.npmjs.org/</span><span class="attr">packages:</span>  <span class="string">&#x27;@*/*&#x27;</span><span class="string">:</span>    <span class="comment"># scoped packages</span>    <span class="attr">access:</span> <span class="string">$all</span>    <span class="attr">publish:</span> <span class="string">$authenticated</span>    <span class="attr">unpublish:</span> <span class="string">$authenticated</span>    <span class="attr">proxy:</span> <span class="string">taobao</span>  <span class="string">&#x27;**&#x27;</span><span class="string">:</span>    <span class="comment"># allow all users (including non-authenticated users) to read and</span>    <span class="comment"># publish all packages</span>    <span class="comment">#</span>    <span class="comment"># you can specify usernames/groupnames (depending on your auth plugin)</span>    <span class="comment"># and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;</span>    <span class="attr">access:</span> <span class="string">$all</span>    <span class="comment"># allow all known users to publish/publish packages</span>    <span class="comment"># (anyone can register by default, remember?)</span>    <span class="attr">publish:</span> <span class="string">$authenticated</span>    <span class="attr">unpublish:</span> <span class="string">$authenticated</span>    <span class="comment"># if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry</span>    <span class="attr">proxy:</span> <span class="string">taobao</span><span class="comment"># You can specify HTTP/1.1 server keep alive timeout in seconds for incoming connections.</span><span class="comment"># A value of 0 makes the http server behave similarly to Node.js versions prior to 8.0.0, which did not have a keep-alive timeout.</span><span class="comment"># WORKAROUND: Through given configuration you can workaround following issue https://github.com/verdaccio/verdaccio/issues/301. Set to 0 in case 60 is not enough.</span><span class="attr">server:</span>  <span class="attr">keepAliveTimeout:</span> <span class="number">60</span><span class="attr">middlewares:</span>  <span class="attr">audit:</span>    <span class="attr">enabled:</span> <span class="literal">true</span><span class="comment"># log settings</span><span class="attr">logs:</span> &#123; <span class="attr">type:</span> <span class="string">stdout</span>, <span class="attr">format:</span> <span class="string">pretty</span>, <span class="attr">level:</span> <span class="string">http</span> &#125;<span class="comment">#experiments:</span><span class="comment">#  # support for npm token command</span><span class="comment">#  token: false</span><span class="comment">#  # enable tarball URL redirect for hosting tarball with a different server, the tarball_url_redirect can be a template string</span><span class="comment">#  tarball_url_redirect: &#x27;https://mycdn.com/verdaccio/$&#123;packageName&#125;/$&#123;filename&#125;&#x27;</span><span class="comment">#  # the tarball_url_redirect can be a function, takes packageName and filename and returns the url, when working with a js configuration file</span><span class="comment">#  tarball_url_redirect(packageName, filename) &#123;</span><span class="comment">#    const signedUrl = // generate a signed url</span><span class="comment">#    return signedUrl;</span><span class="comment">#  &#125;</span><span class="comment"># This affect the web and api (not developed yet)</span><span class="comment">#i18n:</span><span class="comment">#web: en-US</span></code></pre><p>上面是一些默认配置，我们可以简单的进行一些个性化的修改。</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>在容器内执行如下命令:</p><pre><code class="highlight shell">npm adduser --registry http://localhost:4873 # 该地址为登录地址</code></pre><p>接着输入用户名和密码以及邮箱完成注册，完成注册之后可以登录web页面查看信息。</p>]]></content>
    
    
    <summary type="html">利用verdaccio搭建私有npm源</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>docker磁盘占用与清理问题</title>
    <link href="https://mirsery.github.io/2021/12/10/docker/docker%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E6%B8%85%E7%90%86%E9%97%AE%E9%A2%98/"/>
    <id>https://mirsery.github.io/2021/12/10/docker/docker%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E6%B8%85%E7%90%86%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-10T09:50:54.000Z</published>
    <updated>2021-12-10T09:50:54.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--docker----">查看docker占用分布</a></li><li><a href="#----">清理方法</a><ul><li><a href="#------">自动清理命令</a></li><li><a href="#----">手动清除</a></li></ul></li></ul><!-- tocstop --><h2 id="查看docker占用分布"><a href="#查看docker占用分布" class="headerlink" title="查看docker占用分布"></a>查看docker占用分布</h2><pre><code class="highlight shell">docker system df</code></pre><pre><code class="highlight shell">docker system df -v #可以进一步查看空间占用的细节以确定是哪个镜像，容器活着本地卷占用过高的空间</code></pre><h2 id="清理方法"><a href="#清理方法" class="headerlink" title="清理方法"></a>清理方法</h2><h3 id="自动清理命令"><a href="#自动清理命令" class="headerlink" title="自动清理命令"></a>自动清理命令</h3><blockquote><p>该命令自动清理的对象如下：</p></blockquote><ul><li>已经停止的容器</li><li>未被任何容器使用的卷</li><li>未被任何容器所关联的网络</li><li>所有悬空的镜像</li></ul><pre><code class="highlight shell">docker system prune # 对空间进行自动清理docker system prune -a #清除所有未被使用的镜像和悬空镜像docker system prune -f #用以强制删除不提示信息</code></pre><p>针对容器和镜像的删除命令:</p><pre><code class="highlight shell">docker image prune #删除悬空的镜像docker container prune #删除无用的容器<span class="meta">#</span><span class="bash"></span><span class="bash"><span class="comment"># 默认情况下docker container prune命令会清理掉所有处于stopped状态的容器</span></span><span class="meta">#</span><span class="bash"></span><span class="bash">docker volume prune <span class="comment"># 删除无用的卷</span></span>docker network prune # 删除无用的网络</code></pre><h3 id="手动清除"><a href="#手动清除" class="headerlink" title="手动清除"></a>手动清除</h3><ul><li>清理卷<br>如果卷占用过高，可以清除一些不使用的卷，包括一些未被任何容器调用的卷（-v 详细信息中若显示LINKS=0，则未被调用)<pre><code class="highlight shell">docker volume rm $(docker volume ls -qf dangling=true)</code></pre></li><li>容器清理<br>如果发现是容器占用过高的空间，可以手动删除一些:<br>删除所有已退出的容器:<pre><code class="highlight shell">docker rm -v $(docker ps -aq -f status=exited)</code></pre>删除所有状态为dead的容器<pre><code class="highlight shell">docker rm -v $(docker ps -aq -f status=dead)</code></pre></li></ul>]]></content>
    
    
    <summary type="html">docker在使用一段时间后会发现宿主磁盘很容易被占满，手动清除image之后似乎并不能释放磁盘...</summary>
    
    
    
    <category term="docker" scheme="https://mirsery.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://mirsery.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu深度学习驱动安装</title>
    <link href="https://mirsery.github.io/2021/12/10/web/2021/ubuntu%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/"/>
    <id>https://mirsery.github.io/2021/12/10/web/2021/ubuntu%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/</id>
    <published>2021-12-10T06:25:31.000Z</published>
    <updated>2021-12-10T06:25:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu安装-Nvidia驱动"><a href="#Ubuntu安装-Nvidia驱动" class="headerlink" title="Ubuntu安装 Nvidia驱动"></a>Ubuntu安装 Nvidia驱动</h1><!-- toc --><ul><li><a href="#--------------">首先查看本机所安装的显卡型号</a></li><li><a href="#------">官网下载驱动</a></li><li><a href="#---------------">删除原有的开源驱动程序(可选)</a></li><li><a href="#--nouveau--">禁用nouveau驱动</a></li><li><a href="#--">重启</a></li><li><a href="#--nouveau------">验证nouveau是否已经禁用</a></li><li><a href="#--nvidia--">安装nvidia驱动</a></li><li><a href="#----------">查看驱动是否安装成功</a></li><li><a href="#----">其他问题</a></li></ul><!-- tocstop --><h2 id="首先查看本机所安装的显卡型号"><a href="#首先查看本机所安装的显卡型号" class="headerlink" title="首先查看本机所安装的显卡型号"></a>首先查看本机所安装的显卡型号</h2><pre><code class="highlight shell">lspci|grep VGA</code></pre><p><img src="/2021/12/10/web/2021/ubuntu%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/C5902CF2-5023-414E-9BBA-D7FE625ECA55.png"></p><p>根据如上所述的显卡型号，去官网下载对应的系统和对应显卡的驱动。</p><h2 id="官网下载驱动"><a href="#官网下载驱动" class="headerlink" title="官网下载驱动"></a>官网下载驱动</h2><p><a href="https://www.nvidia.cn/Download/index.aspx">nvidia驱动下载地址</a></p><p>选择对应的产品类型，产品系列以及产品型号再根据操作系统系统下载对应的驱动程序。</p><h2 id="删除原有的开源驱动程序-可选"><a href="#删除原有的开源驱动程序-可选" class="headerlink" title="删除原有的开源驱动程序(可选)"></a>删除原有的开源驱动程序(可选)</h2><pre><code class="highlight shell">sudo apt-get remove --pure nvidia*</code></pre><h2 id="禁用nouveau驱动"><a href="#禁用nouveau驱动" class="headerlink" title="禁用nouveau驱动"></a>禁用nouveau驱动</h2><p>编辑 <strong>/etc/modprobe.d/blacklist.conf</strong> ,添加以下内容:</p><pre><code class="highlight plaintext">blacklist nouveaublacklist lbm-nouveauoptions nouveau modeset=0alias nouveau offalias lbm-nouveau off</code></pre><p>关闭nouveau</p><pre><code class="highlight shell">echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</code></pre><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><pre><code class="highlight shell">update-initramfs -u reboot</code></pre><h2 id="验证nouveau是否已经禁用"><a href="#验证nouveau是否已经禁用" class="headerlink" title="验证nouveau是否已经禁用"></a>验证nouveau是否已经禁用</h2><pre><code class="highlight shell">lsmod|grep nouveau</code></pre><p>没有信息显示，说明nouveau已被禁用，接下来可以安装nvdia的显卡驱动。</p><h2 id="安装nvidia驱动"><a href="#安装nvidia驱动" class="headerlink" title="安装nvidia驱动"></a>安装nvidia驱动</h2><ul><li>给文件可执行权限</li></ul><pre><code class="highlight shell">sudo chmod +x NVIDIA-Linux-x86_64-470.86.run</code></pre><ul><li>安装</li></ul><pre><code class="highlight shell">sudo ./NVIDIA-Linux-x86_64-470.86.run -no-x-check -no-nouveau-check -no-opengl-files</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-no-x-check</td><td>安装驱动时关闭X服务</td></tr><tr><td>-no-nouveau-check</td><td>安装驱动时禁用nouveau</td></tr><tr><td>-no-opengl-files</td><td>只安装驱动文件，不安装OpenGL文件</td></tr></tbody></table><h2 id="查看驱动是否安装成功"><a href="#查看驱动是否安装成功" class="headerlink" title="查看驱动是否安装成功"></a>查看驱动是否安装成功</h2><pre><code class="highlight shell">nvidia-smi</code></pre><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>如果出现以下类似的问题</p><pre><code class="highlight plaintext">NVIDIA-SMI has failed because it couldn‘t communicate with NVIDIA driver. Make sure that the latest driver is installed and running.</code></pre><p>解决方案:</p><pre><code class="highlight shell">sudo apt-get install dkmssudo dkms install -m nvidia -v 470.86</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu安装-Nvidia驱动&quot;&gt;&lt;a href=&quot;#Ubuntu安装-Nvidia驱动&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu安装 Nvidia驱动&quot;&gt;&lt;/a&gt;Ubuntu安装 Nvidia驱动&lt;/h1&gt;&lt;!-- toc --&gt;
</summary>
      
    
    
    
    <category term="软件安装" scheme="https://mirsery.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="深度学习" scheme="https://mirsery.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>typescript笔记1</title>
    <link href="https://mirsery.github.io/2021/12/10/web/2021/typescript%E7%AC%94%E8%AE%B01/"/>
    <id>https://mirsery.github.io/2021/12/10/web/2021/typescript%E7%AC%94%E8%AE%B01/</id>
    <published>2021-12-10T05:03:42.000Z</published>
    <updated>2021-12-10T05:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="typescript-笔记-1"><a href="#typescript-笔记-1" class="headerlink" title="typescript 笔记 1"></a>typescript 笔记 1</h1><!-- toc --><ul><li><a href="#typescript---">typescript的安装</a></li><li><a href="#typescript-----">TypeScript的类型注解</a></li><li><a href="#--">接口</a></li><li><a href="#-">类</a></li><li><a href="#symbol--">symbol类型</a></li><li><a href="#-----symbols">众所周知的Symbols</a></li></ul><!-- tocstop --><h2 id="typescript的安装"><a href="#typescript的安装" class="headerlink" title="typescript的安装"></a>typescript的安装</h2><p>使用npm包的形式安装</p><pre><code class="highlight shell">npm install -g typescript</code></pre><h2 id="TypeScript的类型注解"><a href="#TypeScript的类型注解" class="headerlink" title="TypeScript的类型注解"></a>TypeScript的类型注解</h2><pre><code class="highlight typeScript"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: <span class="built_in">string</span></span>)</span>&#123;    <span class="keyword">return</span> <span class="string">&quot;hello, &quot;</span>+person;&#125;<span class="keyword">let</span> user = <span class="string">&quot;Jane User&quot;</span>;<span class="built_in">document</span>.body.innerHtml = greeter(user)</code></pre><p>TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。如果传入的参数不符合类型，则会编译器会给出相应的警告内容.</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>TypeScript里可以定义类似java中的接口，如下所示:</p><pre><code class="highlight typeScript"><span class="keyword">interface</span> Person &#123;    <span class="attr">firstName</span>: <span class="built_in">string</span>;    lastName: <span class="built_in">string</span>&#125;<span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: Person</span>) </span>&#123;    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + person.firstName + <span class="string">&quot;&quot;</span> + person.lastName;&#125;<span class="keyword">let</span> user = &#123;<span class="attr">firstName</span>:<span class="string">&quot;Jane&quot;</span>,<span class="attr">lastName</span>:<span class="string">&quot;User&quot;</span>&#125;;<span class="built_in">document</span>.body.innerHTML = greeter(user)</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>TypeScript支持JavaScript的新特性，比如支持基于类的面向对象编程。以下是官网的例子:</p><blockquote><p>在构造函数上使用public等同于创建了同名的成员变量</p></blockquote><pre><code class="highlight typeScript"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;    <span class="attr">fullName</span>: <span class="built_in">string</span>,    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> firstName,<span class="keyword">public</span> middleInitial,<span class="keyword">public</span> lastName</span>)</span>&#123;        <span class="built_in">this</span>.fullName = firstName + <span class="string">&quot; &quot;</span> + middleInitial + <span class="string">&quot; &quot;</span> + lastName;    &#125;&#125;<span class="keyword">interface</span> Person&#123;    <span class="attr">firstName</span>: <span class="built_in">string</span>,    <span class="attr">lastName</span>: <span class="built_in">string</span>;&#125;<span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: Person</span>)</span>&#123;    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + person.firstName + <span class="string">&quot; &quot;</span> + person.lastName;&#125;<span class="keyword">let</span> user = <span class="keyword">new</span> Student(<span class="string">&quot;Jane&quot;</span>,<span class="string">&quot;M.&quot;</span>,<span class="string">&quot;User&quot;</span>);<span class="built_in">document</span>.body.innerHTML = greeter(user);</code></pre><h2 id="symbol类型"><a href="#symbol类型" class="headerlink" title="symbol类型"></a>symbol类型</h2><blockquote><p>自ECMAScript 2015起，symbol成为了一种新的原生类型，就像number和string一样。</p></blockquote><p>symbol类型的值是通过Symbol构造函数创建的。</p><pre><code class="highlight typeScript"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>();<span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&quot;key&quot;</span>); <span class="comment">// 可选的字符串key</span></code></pre><p>Symbols是不可以改变且唯一的。</p><pre><code class="highlight typeScript"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&quot;key&quot;</span>);<span class="keyword">let</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">&quot;key&quot;</span>);sym2 === sym3; <span class="comment">// false, symbols是唯一的</span></code></pre><p>像字符串一样，symbols也可以被用做对象属性的键。</p><pre><code class="highlight typeScript"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();<span class="keyword">let</span> obj = &#123;    [sym]: <span class="string">&quot;value&quot;</span>&#125;;<span class="built_in">console</span>.log(obj[sym]); <span class="comment">// &quot;value&quot;</span></code></pre><p>Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员.</p><pre><code class="highlight typeScript"><span class="keyword">const</span> getClassNameSymbol = <span class="built_in">Symbol</span>();<span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;    [getClassNameSymbol]()&#123;       <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;    &#125;&#125;<span class="keyword">let</span> c = <span class="keyword">new</span> C();<span class="keyword">let</span> className = c[getClassNameSymbol](); <span class="comment">// &quot;C&quot;</span></code></pre><h2 id="众所周知的Symbols"><a href="#众所周知的Symbols" class="headerlink" title="众所周知的Symbols"></a>众所周知的Symbols</h2><p>除了用户定义的symbols，还有一些已经众所周知的内置symbols。 内置symbols用来表示语言内部的行为。</p><p>以下为这些symbols的列表：</p><ul><li><p>Symbol.hasInstance</p><p>  方法，会被<strong>instanceof</strong>运算符调用。构造器对象用来识别一个对象是否是其实例。</p></li><li><p>Symbol.isConcatSpreadable</p><p>  布尔值，表示当在一个对象上调用<strong>Array.prototype.concat</strong>时，这个对象的数组元素是否可展开。</p></li><li><p>Symbol.iterator</p><p>  方法，被<strong>for-of</strong>语句调用。返回对象的默认迭代器。</p></li><li><p>Symbol.match</p><p>  方法，被<strong>String.prototype.match</strong>调用。正则表达式用来匹配字符串。</p></li><li><p>Symbol.replace</p><p>  方法，被<strong>String.prototype.replace</strong>调用。正则表达式用来替换字符串中匹配的子串。</p></li><li><p>Symbol.search</p><p>  方法，被<strong>String.prototype.search</strong>调用。正则表达式返回被匹配部分在字符串中的索引。</p></li><li><p>Symbol.species</p><p>  函数值，为一个构造函数。用来创建派生对象。</p></li><li><p>Symbol.split</p><p>  方法，被<strong>String.prototype.split</strong>调用。正则表达式来用分割字符串。</p></li><li><p>Symbol.toPrimitive</p><p>  方法，被<strong>ToPrimitive</strong>抽象操作调用。把对象转换为相应的原始值。</p></li><li><p>Symbol.toStringTag</p><p>  方法，被内置方法<strong>Object.prototype.toString</strong>调用。返回创建对象时默认的字符串描述。</p></li><li><p>Symbol.unscopables</p><p>  对象，它自己拥有的属性会被with作用域排除在外。</p></li></ul>]]></content>
    
    
    <summary type="html">typescript是javaScript的超集，他可以编译成javaScript....</summary>
    
    
    
    <category term="js" scheme="https://mirsery.github.io/categories/js/"/>
    
    
    <category term="前端" scheme="https://mirsery.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://mirsery.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>electron-builder打包依赖存放位置</title>
    <link href="https://mirsery.github.io/2021/11/25/web/2021/electron-builder%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE/"/>
    <id>https://mirsery.github.io/2021/11/25/web/2021/electron-builder%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE/</id>
    <published>2021-11-25T06:08:42.000Z</published>
    <updated>2021-11-25T06:08:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#electron-builder-----">electron-builder 打包问题</a><ul><li><a href="#-----">缓存的位置</a></li></ul></li></ul><!-- tocstop --><h1 id="electron-builder-打包问题"><a href="#electron-builder-打包问题" class="headerlink" title="electron-builder 打包问题"></a>electron-builder 打包问题</h1><p>由于国内某些神秘力量会导致采用electron-builder打包app时，从GitHub等地下载依赖时导致文件的下载超时。为此，我们需要手动将依赖下载到指定的目录下面，才能进行下一步的打包工作。</p><h2 id="缓存的位置"><a href="#缓存的位置" class="headerlink" title="缓存的位置"></a>缓存的位置</h2><ul><li>macos</li></ul><pre><code class="highlight shell">~/Library/Caches/electron~/Library/Caches/electron-builder~/Library/Application Support/Caches</code></pre><ul><li><p>Linux </p><pre><code class="highlight shell">~/.cache/electron-builder</code></pre></li><li><p>windows</p><pre><code class="highlight shell"><span class="meta">%</span><span class="bash">LOCALAPPDATA%\\electron\\cache</span><span class="meta">%</span><span class="bash">LOCALAPPDATA%\\electron-builder\\cache</span></code></pre></li></ul>]]></content>
    
    
    <summary type="html">使用 electron-builder 打包的时候会自动下载所需的依赖，但是下载过程可能因某些神秘力量而失败。因此需要手动下载，再将工具放于指定路径...</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>npm镜像源管理</title>
    <link href="https://mirsery.github.io/2021/11/25/web/2021/npm%E9%95%9C%E5%83%8F%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>https://mirsery.github.io/2021/11/25/web/2021/npm%E9%95%9C%E5%83%8F%E6%BA%90%E7%AE%A1%E7%90%86/</id>
    <published>2021-11-25T05:42:58.000Z</published>
    <updated>2021-11-25T05:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----nrm">全局安装nrm</a></li><li><a href="#--nrm">使用nrm</a></li></ul><!-- tocstop --><p>国内由于众所周知的原因，在我们使用npm工具构建前端项目时总会发生一些令人沮丧的事情，每次都需要手动更换镜像源。nrm(npm registry manager)是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换。</p><h2 id="全局安装nrm"><a href="#全局安装nrm" class="headerlink" title="全局安装nrm"></a>全局安装nrm</h2><pre><code class="highlight shell">npm i -g nrm</code></pre><h2 id="使用nrm"><a href="#使用nrm" class="headerlink" title="使用nrm"></a>使用nrm</h2><blockquote><p>查看可用镜像源</p></blockquote><pre><code class="highlight shell">nrm list</code></pre><blockquote><p>选择使用镜像源</p></blockquote><pre><code class="highlight shell">nrm use &lt;name&gt;</code></pre><blockquote><p>增加定制源</p></blockquote><pre><code class="highlight plaintext">nrm add &lt;registry&gt; &lt;url&gt;</code></pre><p>其中reigstry为源名，url为源的路径。</p><blockquote><p>删除镜像源</p></blockquote><pre><code class="highlight shell">nrm del &lt;registry&gt;</code></pre><blockquote><p>测试源速度</p></blockquote><pre><code class="highlight shell">nrm test npm</code></pre>]]></content>
    
    
    <summary type="html">‘nrm npm镜像源管理工具’</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>npm下载包路径设置</title>
    <link href="https://mirsery.github.io/2021/11/18/web/2021/npm%E4%B8%8B%E8%BD%BD%E5%8C%85%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/"/>
    <id>https://mirsery.github.io/2021/11/18/web/2021/npm%E4%B8%8B%E8%BD%BD%E5%8C%85%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/</id>
    <published>2021-11-18T08:39:45.000Z</published>
    <updated>2021-11-18T08:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#mac-npm--------">MAC npm 下载包路径设置</a><ul><li><a href="#--npm-prefix-cache------">查看npm的prefix和cache路径配置信息</a></li><li><a href="#-----------">设置下载路径 缓存路径</a></li><li><a href="#--npm----">查看npm配置信息</a></li><li><a href="#--npm--">清空npm缓存</a></li><li><a href="#---------------------">验证缓存数据的有效性和完整性，清理垃圾数据</a></li></ul></li></ul><!-- tocstop --><h1 id="MAC-npm-下载包路径设置"><a href="#MAC-npm-下载包路径设置" class="headerlink" title="MAC npm 下载包路径设置"></a>MAC npm 下载包路径设置</h1><h2 id="查看npm的prefix和cache路径配置信息"><a href="#查看npm的prefix和cache路径配置信息" class="headerlink" title="查看npm的prefix和cache路径配置信息"></a>查看npm的prefix和cache路径配置信息</h2><pre><code class="highlight shell">npm config get cachenpm config get prefix</code></pre><h2 id="设置下载路径-缓存路径"><a href="#设置下载路径-缓存路径" class="headerlink" title="设置下载路径 缓存路径"></a>设置下载路径 缓存路径</h2><pre><code class="highlight shell">npm config set cache &quot;/cachePath&quot;npm config set prefix &quot;/prefixPath&quot;</code></pre><h2 id="查看npm配置信息"><a href="#查看npm配置信息" class="headerlink" title="查看npm配置信息"></a>查看npm配置信息</h2><pre><code class="highlight shell">npm config list</code></pre><h2 id="清空npm缓存"><a href="#清空npm缓存" class="headerlink" title="清空npm缓存"></a>清空npm缓存</h2><pre><code class="highlight shell">npm cache clean -f</code></pre><h2 id="验证缓存数据的有效性和完整性，清理垃圾数据"><a href="#验证缓存数据的有效性和完整性，清理垃圾数据" class="headerlink" title="验证缓存数据的有效性和完整性，清理垃圾数据"></a>验证缓存数据的有效性和完整性，清理垃圾数据</h2><pre><code class="highlight shell">npm cache verfy</code></pre>]]></content>
    
    
    <summary type="html">MAC npm 下载包路径设置</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://mirsery.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>hls测试流部署</title>
    <link href="https://mirsery.github.io/2021/11/17/talk/2021/hls%E6%B5%8B%E8%AF%95%E6%B5%81%E9%83%A8%E7%BD%B2/"/>
    <id>https://mirsery.github.io/2021/11/17/talk/2021/hls%E6%B5%8B%E8%AF%95%E6%B5%81%E9%83%A8%E7%BD%B2/</id>
    <published>2021-11-17T02:36:39.000Z</published>
    <updated>2021-11-17T02:36:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用nginx/ffmpeg将mp4格式的文件转换成m3u8流，并利用web服务器进行发布</p></blockquote><!-- toc --><ul><li><a href="#hls----------">hls测试流简易部署全过程</a><ul><li><a href="#------------m3u8">第一步将下载的视频切片成m3u8</a></li><li><a href="#------------web------">第二步将切片的文件部署到web服务器中发布</a></li></ul></li></ul><!-- tocstop --><h1 id="hls测试流简易部署全过程"><a href="#hls测试流简易部署全过程" class="headerlink" title="hls测试流简易部署全过程"></a>hls测试流简易部署全过程</h1><p>web开发的过程中有时候会遇到缺少hls在线测试流的情况，这个时候就需要我们自己搭建可用的测试流服务。</p><h2 id="第一步将下载的视频切片成m3u8"><a href="#第一步将下载的视频切片成m3u8" class="headerlink" title="第一步将下载的视频切片成m3u8"></a>第一步将下载的视频切片成m3u8</h2><p>在此操作之前我们需要用到ffmpeg（<a href="https://ffmpeg.org/download.html">点击下载</a>). FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec。</p><p>下载安装完之后我们可以调用如下命令:</p><pre><code class="highlight shell">ffmpeg -i yoursource.mp4 -f segment -segment_time 60 -segment_format mpegts -segment_list yourtarget.m3u8 -c copy -bsf:v h264_mp4toannexb -map 0 yourtarget-%04d.ts</code></pre><p>上述命令会按照60s的间隔对mp4文件进行切片。</p><h2 id="第二步将切片的文件部署到web服务器中发布"><a href="#第二步将切片的文件部署到web服务器中发布" class="headerlink" title="第二步将切片的文件部署到web服务器中发布"></a>第二步将切片的文件部署到web服务器中发布</h2><p>以下是nginx服务器的简单部署配置示例</p><pre><code class="highlight plaintext">server &#123;        listen 80;        index index.html;        server_name xxxxxx; // 服务名        location /&#123;            add_header Access-Control-Allow-Origin *; //允许跨域            root /xxxx/videoPath; //视频切片存放路径        &#125; &#125;</code></pre><p>完成以上配置之后直接访问m3u8文件的web地址即可播放视频流</p>]]></content>
    
    
    <summary type="html">hls测试流简易部署全过程</summary>
    
    
    
    <category term="生活" scheme="https://mirsery.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="闲谈" scheme="https://mirsery.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>PostMan 接口调试指南</title>
    <link href="https://mirsery.github.io/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>https://mirsery.github.io/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/</id>
    <published>2021-08-27T01:59:48.000Z</published>
    <updated>2021-08-27T01:59:48.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----host--">设置线上host地址</a></li><li><a href="#-collection------------">在Collection中设置所有接口的认证方式</a></li><li><a href="#------">新建登录接口</a></li><li><a href="#------">新建其他接口</a></li></ul><!-- tocstop --><blockquote><p>Postman是API开发的一个协作平台。Postman简化构建API的每个步骤，简化了协作过程，方便开发者更快地创建更好的API。</p></blockquote><p>在web开发中接口的调试是必不可少的一环，为了方便接口的测试我们采用了多种调试工具。Postman提供了一种较为舒适的方式来测试接口，接下来我简要记录下postman的一些个人常用的功能。采用postman调试需要传入token的接口</p><h2 id="设置线上host地址"><a href="#设置线上host地址" class="headerlink" title="设置线上host地址"></a>设置线上host地址</h2><p>postman提供的environment,开发者可以在environment中定义环境的变量以及给环境赋值，environment中可以配置线上host地址用来快捷切换不同环境下的接口调试。<br><img src="/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/85996362-D0F8-46C6-AB94-87139309B230.png"></p><h2 id="在Collection中设置所有接口的认证方式"><a href="#在Collection中设置所有接口的认证方式" class="headerlink" title="在Collection中设置所有接口的认证方式"></a>在Collection中设置所有接口的认证方式</h2><blockquote><p>提供设置Collection域下的Authorization/Tests/Pre-request Script/Variables</p></blockquote><ul><li>Authorization<br>支持多种方式验证方式<br><img src="/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/AB620B7D-F13F-48CE-BFA1-36A7FFDA255E.png"></li></ul><p>下面以简单的<strong>API key</strong>类型接口测试为示例</p><ol><li><p>单击对应的Collection，选择<strong>Authorization</strong>，并在类型中选择并填入如下内容,其中<strong>token</strong> 为接口认证的key值(按照实际项目修改)，value中填入<strong>Collection变量</strong> <em></em> ,并选择认证的域为请求头<strong>header</strong>(按照实际项目修改).<br><img src="/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/FD4485D2-F81D-4EE6-9D6B-FA7B0BC7986F.png"></p></li><li><p>点击<strong>Variables</strong> ，新增以下2个变量（<strong>token</strong>,<strong>host</strong>).添加<strong>host</strong>主要是为了接口调用的时候，默认调用本地的接口，而不借助环境变量的形式访问。</p><blockquote><p>环境变量的参数会覆盖Collection下的参数</p></blockquote></li></ol><!-- **lnherit auth from parent** --><h2 id="新建登录接口"><a href="#新建登录接口" class="headerlink" title="新建登录接口"></a>新建登录接口</h2><p>在collection中新建接口，选择对应的GET、POST。在Authorization下的type选择<strong>No Auth</strong>,接着传入其余自定义的参数完成方法的构建。在tests中可以编写一些脚本对数据结果进行处理。</p><p><img src="/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/9DCF84DB-D287-43E8-A262-FABC5C0A8DAF.png"></p><p>请求接口中 <strong></strong> 是该请求所在的collection的变量或environment的引用（优先级如上文所述)<br>**pm.response.json()**将返回的变量解析成一个json对象（如果返回值为json格式的话），解析出登录接口返回的token值，并将token值赋给对应的collection中的变量。<br>**pm.collectionVariables.set(“token”, “token value”);**将token值传递给相应的collection变量</p><h2 id="新建其他接口"><a href="#新建其他接口" class="headerlink" title="新建其他接口"></a>新建其他接口</h2><p>新建其他的接口的时候，在Authorization下的type选择<strong>lnherit auth from parent</strong>即可继承该collection下的请求认证参数，即接口调试无须手动传入token值，方便了接口调试。</p>]]></content>
    
    
    <summary type="html">Postman是API开发的一个协作平台。Postman简化构建API的每个步骤，简化了协作过程，方便开发者更快地创建更好的API...</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Mybatis xml映射器(四)</title>
    <link href="https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%BA%94/"/>
    <id>https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%BA%94/</id>
    <published>2021-08-24T13:50:24.000Z</published>
    <updated>2021-08-24T13:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#discriminator----">discriminator 鉴别器</a><ul><li><a href="#discriminator--------">discriminator 鉴别器用法示例</a></li></ul></li><li><a href="#----">自动映射</a><ul><li><a href="#------">自动映射例子</a></li><li><a href="#------">自动映射等级</a></li></ul></li></ul><!-- tocstop --><blockquote><p>该文档摘抄自<a href="https://blog.mybatis.org./">https://blog.mybatis.org。</a></p></blockquote><h1 id="discriminator-鉴别器"><a href="#discriminator-鉴别器" class="headerlink" title="discriminator 鉴别器"></a>discriminator 鉴别器</h1><p>有时候，一个数据库查询可能会返回多个不同的结果集（但总体上还是有一定的联系的）。 鉴别器（discriminator）元素就是被设计来应对这种情况的，另外也能处理其它情况，例如类的继承层次结构。 鉴别器的概念很好理解——它很像 Java 语言中的 switch 语句。</p><h2 id="discriminator-鉴别器用法示例"><a href="#discriminator-鉴别器用法示例" class="headerlink" title="discriminator 鉴别器用法示例"></a>discriminator 鉴别器用法示例</h2><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">column</span>=<span class="string">&quot;draft&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;DraftPost&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></code></pre><p>一个鉴别器的定义需要指定 column 和 javaType 属性。column 指定了 MyBatis 查询被比较值的地方。 而 javaType 用来确保使用正确的相等测试（虽然很多情况下字符串的相等测试都可以工作）。例如：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;vehicleResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Vehicle&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;vin&quot;</span> <span class="attr">column</span>=<span class="string">&quot;vin&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;year&quot;</span> <span class="attr">column</span>=<span class="string">&quot;year&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;make&quot;</span> <span class="attr">column</span>=<span class="string">&quot;make&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;model&quot;</span> <span class="attr">column</span>=<span class="string">&quot;model&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;color&quot;</span> <span class="attr">column</span>=<span class="string">&quot;color&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">column</span>=<span class="string">&quot;vehicle_type&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;carResult&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;truckResult&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;vanResult&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;suvResult&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><p>在这个示例中，MyBatis 会从结果集中得到每条记录，然后比较它的 vehicle type 值。 如果它匹配任意一个鉴别器的 case，就会使用这个 case 指定的结果映射。 这个过程是互斥的，也就是说，剩余的结果映射将被忽略（除非它是扩展的，我们将在稍后讨论它）。 如果不能匹配任何一个 case，MyBatis 就只会使用鉴别器块外定义的结果映射。 所以，如果 carResult 的声明如下：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;carResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Car&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;doorCount&quot;</span> <span class="attr">column</span>=<span class="string">&quot;door_count&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><p>那么只有 doorCount 属性会被加载。这是为了即使鉴别器的 case 之间都能分为完全独立的一组，尽管和父结果映射可能没有什么关系。在上面的例子中，我们当然知道 cars 和 vehicles 之间有关系，也就是 Car 是一个 Vehicle。因此，我们希望剩余的属性也能被加载。而这只需要一个小修改。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;carResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Car&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;vehicleResult&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;doorCount&quot;</span> <span class="attr">column</span>=<span class="string">&quot;door_count&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><p>现在 vehicleResult 和 carResult 的属性都会被加载了，下面是等同的简洁风格:</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;vehicleResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Vehicle&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;vin&quot;</span> <span class="attr">column</span>=<span class="string">&quot;vin&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;year&quot;</span> <span class="attr">column</span>=<span class="string">&quot;year&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;make&quot;</span> <span class="attr">column</span>=<span class="string">&quot;make&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;model&quot;</span> <span class="attr">column</span>=<span class="string">&quot;model&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;color&quot;</span> <span class="attr">column</span>=<span class="string">&quot;color&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">column</span>=<span class="string">&quot;vehicle_type&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;carResult&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;doorCount&quot;</span> <span class="attr">column</span>=<span class="string">&quot;door_count&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">case</span>&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;truckResult&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;boxSize&quot;</span> <span class="attr">column</span>=<span class="string">&quot;box_size&quot;</span> /&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;extendedCab&quot;</span> <span class="attr">column</span>=<span class="string">&quot;extended_cab&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">case</span>&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;vanResult&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;powerSlidingDoor&quot;</span> <span class="attr">column</span>=<span class="string">&quot;power_sliding_door&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">case</span>&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;suvResult&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;allWheelDrive&quot;</span> <span class="attr">column</span>=<span class="string">&quot;all_wheel_drive&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">case</span>&gt;</span>  <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><h1 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h1><p>当自动映射查询结果时，MyBatis 会获取结果中返回的列名并在 Java 类中查找相同名字的属性（忽略大小写）。 这意味着如果发现了 ID 列和 id 属性，MyBatis 会将列 ID 的值赋给 id 属性。<br>通常<strong>数据库列使用大写字母组成的单词命名，单词间用下划线分隔</strong>；而 <strong>Java 属性一般遵循驼峰命名法约定</strong>。为了在这两种命名方式之间启用自动映射，需要将 <strong>mapUnderscoreToCamelCase</strong> 设置为 <strong>true</strong>。</p><h2 id="自动映射例子"><a href="#自动映射例子" class="headerlink" title="自动映射例子"></a>自动映射例子</h2><p>提供了结果映射后，自动映射也能工作。在这种情况下，对于每一个结果映射，在 ResultSet 出现的列，如果没有设置手动映射，将被自动映射。在自动映射处理完毕后，再处理手动映射。 在下面的例子中，id 和 userName 列将被自动映射，hashed_password 列将根据配置进行映射.</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span>  select    user_id             as &quot;id&quot;,    user_name           as &quot;userName&quot;,    hashed_password  from some_table  where id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hashed_password&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><h2 id="自动映射等级"><a href="#自动映射等级" class="headerlink" title="自动映射等级"></a>自动映射等级</h2><p>有三种自动映射等级：</p><ul><li>NONE - 禁用自动映射。仅对手动映射的属性进行映射。</li><li>PARTIAL - 对除在内部定义了嵌套结果映射（也就是连接的属性）以外的属性进行映射(DEFAULT 默认等级s)</li><li>FULL - 自动映射所有属性。</li></ul><blockquote><p>默认值是 PARTIAL，这是有原因的。当对连接查询的结果使用 FULL 时，连接查询会在同一行中获取多个不同实体的数据，因此可能导致非预期的映射。 </p></blockquote><p>下面是可能导致风险的例子</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  select    B.id,    B.title,    A.username,  from Blog B left outer join Author A on B.author_id = A.id  where B.id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;authorResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Author&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><p>在该结果映射中，Blog 和 Author 均将被自动映射。但是注意 Author 有一个 id 属性，在 ResultSet 中也有一个名为 id 的列，所以 Author 的 id 将填入 Blog 的 id，这可不是你期望的行为。 所以，要谨慎使用 FULL。无论设置的自动映射等级是哪种，你都可以通过在结果映射上设置 autoMapping 属性来为指定的结果映射设置启用/禁用自动映射。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;false&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hashed_password&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre>]]></content>
    
    
    <summary type="html">mybatis鉴别器discriminator和自动映射</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="mybatis" scheme="https://mirsery.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis xml映射器(四)</title>
    <link href="https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E5%9B%9B/"/>
    <id>https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E5%9B%9B/</id>
    <published>2021-08-24T08:55:24.000Z</published>
    <updated>2021-08-24T08:55:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#------select---">关联的嵌套 Select 查询</a><ul><li><a href="#---------">关联的嵌套使用示例</a></li><li><a href="#---------">关联的嵌套结果映射</a></li></ul></li></ul><!-- tocstop --><blockquote><p>该文档摘抄自<a href="https://blog.mybatis.org./">https://blog.mybatis.org。</a></p></blockquote><h1 id="关联的嵌套-Select-查询"><a href="#关联的嵌套-Select-查询" class="headerlink" title="关联的嵌套 Select 查询"></a>关联的嵌套 Select 查询</h1><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>column</td><td>数据中的列名或者是列的别名。一般情况下，这和传递给<strong>resultSet.getString(columnName)</strong> 方法的参数一样。 注意：在使用复合主键的时候，你可以使用<strong>column=”{prop1=col1,prop2=col2}”<strong>这样的语法来指定多个传递给嵌套</strong>Select</strong>查询语句的列名。这会使得<strong>prop1</strong>和<strong>prop2</strong>作为参数对象，被设置为对应嵌套 Select 语句的参数。</td></tr><tr><td>select</td><td>用于加载复杂类型属性的映射语句的 ID，它会从<strong>column</strong>属性指定的列中检索数据，作为参数传递给目标<strong>select</strong>语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用<strong>column=”{prop1=col1,prop2=col2}”<strong>这样的语法来指定多个传递给嵌套</strong>Select</strong>查询语句的列名。这会使得<strong>prop1</strong>和<strong>prop2</strong>作为参数对象，被设置为对应嵌套<strong>Select</strong>语句的参数。</td></tr><tr><td>fetchType</td><td>可选的，有效值为<strong>lazy</strong>和<strong>eager</strong>.该属性设置会覆盖全局配置参数lazyLoadingEnabled</td></tr></tbody></table><h2 id="关联的嵌套使用示例"><a href="#关联的嵌套使用示例" class="headerlink" title="关联的嵌套使用示例"></a>关联的嵌套使用示例</h2><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectAuthor&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAuthor&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span>  SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><blockquote><p>这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为“N+1 查询问题”。 </p></blockquote><p>概括地讲，N+1 查询问题是这样子的：<br>你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。<br>对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。</p><h2 id="关联的嵌套结果映射"><a href="#关联的嵌套结果映射" class="headerlink" title="关联的嵌套结果映射"></a>关联的嵌套结果映射</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>resultMap</td><td>结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 ResultSet。这样的 ResultSet 有部分数据是重复的。 为了将结果集正确地映射到嵌套的对象树中, MyBatis 允许你“串联”结果映射，以便解决嵌套结果集的问题。</td></tr><tr><td>columnPrefix</td><td>当连接多个表时，你可能会不得不使用列别名来避免在 ResultSet 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。</td></tr><tr><td>notNullColumn</td><td>默认情况下，在至少一个被映射到属性的列不为空时，子对象才会被创建。 你可以在这个属性上指定非空的列来改变默认行为，指定后，Mybatis 将只在这些列非空时才创建一个子对象。可以使用逗号分隔来指定多个列。默认值：未设置（unset）。</td></tr><tr><td>autoMapping</td><td>如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。注意，本属性对外部的结果映射无效，所以不能搭配 select 或 resultMap 元素使用。默认值：未设置（unset）。</td></tr></tbody></table><p>下面是一个简单的关联嵌套结果映射</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  select    B.id            as blog_id,    B.title         as blog_title,    B.author_id     as blog_author_id,    A.id            as author_id,    A.username      as author_username,    A.password      as author_password,    A.email         as author_email,    A.bio           as author_bio  from Blog B left outer join Author A on B.author_id = A.id  where B.id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;authorResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Author&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_password&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_email&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_bio&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><blockquote><pre><div class="caption"><span>id 元素在嵌套结果映射中扮演着非常重要的角色。你应该总是指定一个或多个可以唯一标识结果的属性。 虽然，即使不指定这个属性，MyBatis 仍然可以工作，但是会产生严重的性能问题。 只需要指定可以唯一标识结果的最少属性。显然，你可以选择主键（复合主键也可以）。</span></div><code class="highlight !!!非常重要```：">上面的示例使用了外部的结果映射元素来映射关联。这使得 Author 的结果映射可以被重用。 然而，如果你不打算重用它，或者你更喜欢将你所有的结果映射放在一个具有描述性的结果映射元素中。 你可以直接将结果映射作为子元素嵌套在内。这里给出使用这种方式的等效例子：```xml&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt;   &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;   &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;   &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;   &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;   &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;</code></pre></blockquote><p>那如果博客（blog）有一个共同作者（co-author）该怎么办？select 语句看起来会是这样的：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  select    B.id            as blog_id,    B.title         as blog_title,    A.id            as author_id,    A.username      as author_username,    A.password      as author_password,    A.email         as author_email,    A.bio           as author_bio,    CA.id           as co_author_id,    CA.username     as co_author_username,    CA.password     as co_author_password,    CA.email        as co_author_email,    CA.bio          as co_author_bio  from Blog B  left outer join Author A on B.author_id = A.id  left outer join Author CA on B.co_author_id = CA.id  where B.id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;authorResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Author&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_password&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_email&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_bio&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span></span><span class="tag">    <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;coAuthor&quot;</span></span><span class="tag">    <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span></span><span class="tag">    <span class="attr">columnPrefix</span>=<span class="string">&quot;co_&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><h2 id="关联的多结果集（ResultSet）"><a href="#关联的多结果集（ResultSet）" class="headerlink" title="关联的多结果集（ResultSet）"></a>关联的多结果集（ResultSet）</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>column</td><td>当使用多个结果集时，该属性指定结果集中用于与 foreignColumn 匹配的列（多个列名以逗号隔开），以识别关系中的父类型与子类型。</td></tr><tr><td>foreignColumn</td><td>指定外键对应的列名，指定的列将与父类型中 column 的给出的列进行匹配。</td></tr><tr><td>resultSet</td><td>指定用于加载复杂类型的结果集名字。</td></tr></tbody></table><blockquote><p>解决 N+1 查询问题的方法</p></blockquote><pre><code class="highlight sql">DELIMITER $$<span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> getBlogsAndAuthors(<span class="keyword">IN</span> blog_id <span class="type">INT</span>, <span class="keyword">IN</span> author_id <span class="type">INT</span>)<span class="keyword">BEGIN</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> BLOG <span class="keyword">WHERE</span> ID <span class="operator">=</span> blog_id;<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> AUTHOR <span class="keyword">WHERE</span> ID <span class="operator">=</span> author_id;<span class="keyword">END</span> $$</code></pre><p>在映射语句中，必须通过<strong>resultSets</strong>属性为每个结果集指定一个名字，多个名字使用逗号隔开。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultSets</span>=<span class="string">&quot;blogs,authors&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">statementType</span>=<span class="string">&quot;CALLABLE&quot;</span>&gt;</span>  &#123;call getBlogsAndAuthors(#&#123;id,jdbcType=INTEGER,mode=IN&#125;)&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>现在我们可以指定使用 “authors” 结果集的数据来填充 “author” 关联：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;title&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">resultSet</span>=<span class="string">&quot;authors&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span> <span class="attr">foreignColumn</span>=<span class="string">&quot;id&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;bio&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">association</span>&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><h2 id="集合的嵌套-Select-查询"><a href="#集合的嵌套-Select-查询" class="headerlink" title="集合的嵌套 Select 查询"></a>集合的嵌套 Select 查询</h2><p>如何使用嵌套 Select 查询来为博客加载文章</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectPostsForBlog&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostsForBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span>  SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h2 id="集合的嵌套结果映射"><a href="#集合的嵌套结果映射" class="headerlink" title="集合的嵌套结果映射"></a>集合的嵌套结果映射</h2><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  select  B.id as blog_id,  B.title as blog_title,  B.author_id as blog_author_id,  P.id as post_id,  P.subject as post_subject,  P.body as post_body,  from Blog B  left outer join Post P on B.id = P.blog_id  where B.id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_id&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_subject&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;body&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_body&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><p>等价于</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogPostResult&quot;</span> <span class="attr">columnPrefix</span>=<span class="string">&quot;post_&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogPostResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Post&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">column</span>=<span class="string">&quot;subject&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;body&quot;</span> <span class="attr">column</span>=<span class="string">&quot;body&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><h2 id="集合的多结果集"><a href="#集合的多结果集" class="headerlink" title="集合的多结果集"></a>集合的多结果集</h2><p>集合的多结果集的映射类似关联的多结果集映射，都是采用存储过程来实现。</p>]]></content>
    
    
    <summary type="html">关联/集合嵌套结果映射和关联/集合嵌套查询</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="mybatis" scheme="https://mirsery.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis xml映射器(三)</title>
    <link href="https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%89/"/>
    <id>https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%89/</id>
    <published>2021-08-24T07:35:59.000Z</published>
    <updated>2021-08-24T07:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#mybatis-----">Mybatis 参数映射</a><ul><li><a href="#-----">字符串替换</a></li></ul></li><li><a href="#--sql">动态sql</a><ul><li><a href="#if">if</a></li><li><a href="#choose-when-otherwise">choose、when、otherwise</a></li><li><a href="#trim-where-set">trim、where、set</a></li><li><a href="#foreach">foreach</a></li></ul></li><li><a href="#script">script</a></li></ul><!-- tocstop --><blockquote><p>该文档摘抄自<a href="https://blog.mybatis.org./">https://blog.mybatis.org。</a></p></blockquote><h1 id="Mybatis-参数映射"><a href="#Mybatis-参数映射" class="headerlink" title="Mybatis 参数映射"></a>Mybatis 参数映射</h1><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p>默认情况下，使用 <strong>#{}</strong> 参数语法时，MyBatis 会创建 <strong>PreparedStatement</strong> 参数占位符，并通过占位符安全地设置参数（就像使用 ? 一样）。 这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL 语句中直接插入一个<strong>不转义的字符串</strong>。 比如 ORDER BY 子句，这时候你可以：</p><pre><code class="highlight xml">ORDER BY $&#123;columnName&#125;</code></pre><p>如果你想<strong>select</strong>一个表，任意一个列数据时，可以写成如下方式:</p><pre><code class="highlight java"><span class="meta">@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)</span><span class="function">User <span class="title">findByColumn</span><span class="params">(<span class="meta">@Param(&quot;column&quot;)</span> String column, <span class="meta">@Param(&quot;value&quot;)</span> String value)</span></span>;</code></pre><blockquote><p> 用这种方式接受用户的输入，并用作语句参数是不安全的，会导致潜在的 SQL 注入攻击。因此，要么不允许用户输入这些字段，要么自行转义并检验这些参数。</p></blockquote><h1 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h1><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>example:</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span>    AND title like #&#123;title&#125;  <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span>    AND author_name like #&#123;author.name&#125;  <span class="tag">&lt;/<span class="name">if</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><p>choose 元素有点类似Java中的switch语句，多个条件中选择一个使用.</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  SELECT * FROM BLOG WHERE state = &#x27;ACTIVE&#x27;  <span class="tag">&lt;<span class="name">choose</span>&gt;</span>    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span>      AND title like #&#123;title&#125;    <span class="tag">&lt;/<span class="name">when</span>&gt;</span>    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span>      AND author_name like #&#123;author.name&#125;    <span class="tag">&lt;/<span class="name">when</span>&gt;</span>    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>      AND featured = 1    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span>  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h2 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h2><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  SELECT * FROM BLOG  <span class="tag">&lt;<span class="name">where</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span>         state = #&#123;state&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span>        AND title like #&#123;title&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span>        AND author_name like #&#123;author.name&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  <span class="tag">&lt;/<span class="name">where</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。<br>如果 where 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 where 元素的功能。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span>         state = #&#123;state&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span>        AND title like #&#123;title&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span>        AND author_name like #&#123;author.name&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></code></pre><p><strong>prefixOverrides</strong> 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容。用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span>  update Author    <span class="tag">&lt;<span class="name">set</span>&gt;</span>      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;/<span class="name">set</span>&gt;</span>  where id=#&#123;id&#125;<span class="tag">&lt;/<span class="name">update</span>&gt;</span></code></pre><p>这个例子中，set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。下面是和set等价的trim写法：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></code></pre><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>foreach 常见使用场景一般是批量插入和对集合进行遍历（构造IN条件语句时).</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span>  SELECT *  FROM POST P  WHERE ID in  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span>        #&#123;item&#125;  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符。</p><blockquote><p>你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p></blockquote><h1 id="script"><a href="#script" class="headerlink" title="script"></a>script</h1><p>要在带注解的映射器接口类中使用动态 SQL，可以使用 script 元素,比如:</p><pre><code class="highlight java"><span class="meta">@Update(&#123;&quot;&lt;script&gt;&quot;,</span><span class="meta">     &quot;update Author&quot;,</span><span class="meta">     &quot;  &lt;set&gt;&quot;,</span><span class="meta">     &quot;    &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;,</span><span class="meta">     &quot;    &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;,</span><span class="meta">     &quot;    &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;,</span><span class="meta">     &quot;    &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;,</span><span class="meta">     &quot;  &lt;/set&gt;&quot;,</span><span class="meta">     &quot;where id=#&#123;id&#125;&quot;,</span><span class="meta">     &quot;&lt;/script&gt;&quot;&#125;)</span>   <span class="function"><span class="keyword">void</span> <span class="title">updateAuthorValues</span><span class="params">(Author author)</span></span>;</code></pre>]]></content>
    
    
    <summary type="html">Mybatis的参数映射、字符串替换、动态sql、if、choose 等...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="mybatis" scheme="https://mirsery.github.io/tags/mybatis/"/>
    
    <category term="动态sql" scheme="https://mirsery.github.io/tags/%E5%8A%A8%E6%80%81sql/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis xml映射器(二)</title>
    <link href="https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%BA%8C/"/>
    <id>https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%BA%8C/</id>
    <published>2021-08-24T07:09:18.000Z</published>
    <updated>2021-08-24T07:09:18.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><!-- tocstop --><blockquote><p>该文档摘抄自<a href="https://blog.mybatis.org./">https://blog.mybatis.org。</a><br>Mybatis xml映射器insert、update 和 delete 标签</p></blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">insert</span></span><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span></span><span class="tag">  <span class="attr">parameterType</span>=<span class="string">&quot;domain.blog.Author&quot;</span></span><span class="tag">  <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">  <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span><span class="tag">  <span class="attr">keyProperty</span>=<span class="string">&quot;&quot;</span></span><span class="tag">  <span class="attr">keyColumn</span>=<span class="string">&quot;&quot;</span></span><span class="tag">  <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;&quot;</span></span><span class="tag">  <span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">update</span></span><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;updateAuthor&quot;</span></span><span class="tag">  <span class="attr">parameterType</span>=<span class="string">&quot;domain.blog.Author&quot;</span></span><span class="tag">  <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">  <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span><span class="tag">  <span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">delete</span></span><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;deleteAuthor&quot;</span></span><span class="tag">  <span class="attr">parameterType</span>=<span class="string">&quot;domain.blog.Author&quot;</span></span><span class="tag">  <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">  <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span><span class="tag">  <span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></code></pre><p>example:</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span>&gt;</span>  insert into Author (id,username,password,email,bio)  values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)<span class="tag">&lt;/<span class="name">insert</span>&gt;</span><span class="comment">&lt;!-- 返回生成的主键id的值 --&gt;</span><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">    <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span>  insert into Author (username,password,email,bio)  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)<span class="tag">&lt;/<span class="name">insert</span>&gt;</span><span class="comment">&lt;!-- 批量插入示例 !--&gt;</span><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">    <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span>  insert into Author (username, password, email, bio) values  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span>    (#&#123;item.username&#125;, #&#123;item.password&#125;, #&#123;item.email&#125;, #&#123;item.bio&#125;)  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span><span class="tag">&lt;/<span class="name">insert</span>&gt;</span><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthor&quot;</span>&gt;</span>  update Author set    username = #&#123;username&#125;,    password = #&#123;password&#125;,    email = #&#123;email&#125;,    bio = #&#123;bio&#125;  where id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">update</span>&gt;</span><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteAuthor&quot;</span>&gt;</span>  delete from Author where id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">delete</span>&gt;</span></code></pre><p>Insert, Update, Delete 元素的属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>–</td></tr><tr><td>parameterType</td><td>将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td>flushCache</td><td>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td>statementType</td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td>useGeneratedKeys</td><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td>keyProperty</td><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td>keyColumn</td><td>（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td>databaseId</td><td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Mybatis xml映射器insert、update 和 delete 标签...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="mybatis" scheme="https://mirsery.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis xml映射器（一)</title>
    <link href="https://mirsery.github.io/2021/08/24/java/2021/Mybatis%20xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%80/"/>
    <id>https://mirsery.github.io/2021/08/24/java/2021/Mybatis%20xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%80/</id>
    <published>2021-08-24T01:28:54.000Z</published>
    <updated>2021-08-24T01:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#select------">select 元素的属性</a><ul><li><a href="#select-----">select 用法示例</a></li><li><a href="#select-----">select 元素属性</a></li></ul></li><li><a href="#resultset-----">ResultSet 结果映射</a><ul><li><a href="#resultset-------">ResultSet 简易用法示例</a></li><li><a href="#resultmap-------">ResultMap 简易用法示例</a></li><li><a href="#resultmap---">ResultMap 属性</a></li><li><a href="#------">高级结果映射</a></li></ul></li></ul><!-- tocstop --><blockquote><p>该文档摘抄自<a href="https://blog.mybatis.org.mybatis/">https://blog.mybatis.org。MyBatis</a> 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><h1 id="select-元素的属性"><a href="#select-元素的属性" class="headerlink" title="select 元素的属性"></a>select 元素的属性</h1><h2 id="select-用法示例"><a href="#select-用法示例" class="headerlink" title="select 用法示例"></a>select 用法示例</h2><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPerson&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;hashmap&quot;</span>&gt;</span>  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span></span><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;selectPerson&quot;</span></span><span class="tag">  <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span></span><span class="tag">  <span class="attr">parameterMap</span>=<span class="string">&quot;deprecated&quot;</span></span><span class="tag">  <span class="attr">resultType</span>=<span class="string">&quot;hashmap&quot;</span></span><span class="tag">  <span class="attr">resultMap</span>=<span class="string">&quot;personResultMap&quot;</span></span><span class="tag">  <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span></span><span class="tag">  <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">  <span class="attr">timeout</span>=<span class="string">&quot;10&quot;</span></span><span class="tag">  <span class="attr">fetchSize</span>=<span class="string">&quot;256&quot;</span></span><span class="tag">  <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span><span class="tag">  <span class="attr">resultSetType</span>=<span class="string">&quot;FORWARD_ONLY&quot;</span>&gt;</span></code></pre><h2 id="select-元素属性"><a href="#select-元素属性" class="headerlink" title="select 元素属性"></a>select 元素属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在命名空间中唯一的标识符可以用来引用这条语句</td></tr><tr><td>parameterType</td><td>将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset)</td></tr><tr><td>resultType</td><td>期望从这条语句中返回结果的类全限定名或别名,resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td>resultMap</td><td>对外部 resultMap 的命名引用,resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td>flushCache</td><td>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。</td></tr><tr><td>useCache</td><td>将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）</td></tr><tr><td>fetchSize</td><td>这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）。</td></tr><tr><td>statementType</td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td>resultSetType</td><td>FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。</td></tr><tr><td>databaseId</td><td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td></tr><tr><td>resultOrdered</td><td>这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：false。</td></tr><tr><td>resultSets</td><td>这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。</td></tr></tbody></table><h1 id="ResultSet-结果映射"><a href="#ResultSet-结果映射" class="headerlink" title="ResultSet 结果映射"></a>ResultSet 结果映射</h1><blockquote><p>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系</p></blockquote><h2 id="ResultSet-简易用法示例"><a href="#ResultSet-简易用法示例" class="headerlink" title="ResultSet 简易用法示例"></a>ResultSet 简易用法示例</h2><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span>  select id, username, hashedPassword  from some_table  where id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>上述代码片段，将数据库结果查询的列映射到<strong>HashMap</strong>上，使用<strong>resultType</strong>指定。在大部分情况下<strong>HashMap</strong>并不是一个很好的领域模型，一般业务中会采用<strong>JavaBean</strong>或<strong>POJO</strong>作为领域模型。以下是一个简易的JavaBean:</p><pre><code class="highlight java"><span class="keyword">package</span> com.someapp.model;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;  <span class="keyword">private</span> <span class="keyword">int</span> id;  <span class="keyword">private</span> String username;  <span class="keyword">private</span> String hashedPassword;  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> id;  &#125;  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;    <span class="keyword">this</span>.id = id;  &#125;  <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> username;  &#125;  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;    <span class="keyword">this</span>.username = username;  &#125;  <span class="function"><span class="keyword">public</span> String <span class="title">getHashedPassword</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> hashedPassword;  &#125;  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHashedPassword</span><span class="params">(String hashedPassword)</span> </span>&#123;    <span class="keyword">this</span>.hashedPassword = hashedPassword;  &#125;&#125;</code></pre><p>基于以上JavaBean规范，上面的类有3个属性:id,username,hashedPassword,这些属性会对应到select语句中的列名。这样的一个 JavaBean 可以被映射到 ResultSet，就像映射到 HashMap 一样简单。</p><pre><code class="highlight java">&lt;select id=<span class="string">&quot;selectUsers&quot;</span> resultType=<span class="string">&quot;com.someapp.model.User&quot;</span>&gt;  select id, username, hashedPassword  from some_table  where id = #&#123;id&#125;&lt;/select&gt;</code></pre><p>可以采用类型别名，避免输入类的全限定名,例如：</p><pre><code class="highlight xml"><span class="comment">&lt;!-- mybatis-config.xml 中 --&gt;</span><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.someapp.model.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>/&gt;</span><span class="comment">&lt;!-- SQL 映射 XML 中 --&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  select id, username, hashedPassword  from some_table  where id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>在某些情况下，Mybatis会自动创建一个ResultMap，再根据结果的列名来映射JavaBean的属性上，如果列名和属性名不能匹配上，可以在select查询语句的时候设置列别名来完成匹配工作。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  select    user_id             as &quot;id&quot;,    user_name           as &quot;userName&quot;,    hashed_password     as &quot;hashedPassword&quot;  from some_table  where id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h2 id="ResultMap-简易用法示例"><a href="#ResultMap-简易用法示例" class="headerlink" title="ResultMap 简易用法示例"></a>ResultMap 简易用法示例</h2><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hashed_password&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span>  select user_id, user_name, hashed_password  from some_table  where id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h2 id="ResultMap-属性"><a href="#ResultMap-属性" class="headerlink" title="ResultMap 属性"></a>ResultMap 属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>column</td><td>当使用多个结果集时，该属性指定结果集中用于与<strong>foreignColumn</strong>匹配的列（多个列名以逗号隔开),以识别关系中的父类型与子类型。</td></tr><tr><td>foreignColumn</td><td>指定外键对应的列名,指定的列将与父类型中<strong>column</strong>的给出的列匹配.</td></tr><tr><td>resultSet</td><td>指定用于加载复杂类型的结果集名字。</td></tr></tbody></table><ul><li>constructor - 用于在实例化类时，注入结果到构造方法中<ul><li>idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能</li><li>arg - 将被注入到构造方法的一个普通结果</li></ul></li><li>id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能</li><li>result – 注入到字段或 JavaBean 属性的普通结果</li><li>association – 一个复杂类型的关联；许多结果将包装成这种类型<ul><li>嵌套结果映射 – 关联可以是 resultMap 元素，或是对其它结果映射的引用</li></ul></li><li>collection – 一个复杂类型的集合<ul><li>嵌套结果映射 – 集合可以是 resultMap 元素，或是对其它结果映射的引用</li></ul></li><li>discriminator – 使用结果值来决定使用哪个 resultMap<ul><li>case – 基于某些值的结果映射<ul><li>嵌套结果映射 – case 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射</li></ul></li></ul></li></ul><h2 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h2><blockquote><p>实际使用过程中，数据库并不一定具备良好的第三范式和BCNF范式。<br>下面是比较复杂的查询语句的映射示例</p></blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlogDetails&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;detailedBlogResultMap&quot;</span>&gt;</span>  select       B.id as blog_id,       B.title as blog_title,       B.author_id as blog_author_id,       A.id as author_id,       A.username as author_username,       A.password as author_password,       A.email as author_email,       A.bio as author_bio,       A.favourite_section as author_favourite_section,       P.id as post_id,       P.blog_id as post_blog_id,       P.author_id as post_author_id,       P.created_on as post_created_on,       P.section as post_section,       P.subject as post_subject,       P.draft as draft,       P.body as post_body,       C.id as comment_id,       C.post_id as comment_post_id,       C.name as comment_name,       C.comment as comment_text,       T.id as tag_id,       T.name as tag_name  from Blog B       left outer join Author A on B.author_id = A.id       left outer join Post P on B.id = P.blog_id       left outer join Comment C on P.id = C.post_id       left outer join Post_Tag PT on PT.post_id = P.id       left outer join Tag T on PT.tag_id = T.id  where B.id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="comment">&lt;!-- 非常复杂的结果映射 --&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;detailedBlogResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">constructor</span>&gt;</span>    <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_password&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_email&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_bio&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;favouriteSection&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_favourite_section&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">association</span>&gt;</span>  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_id&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_subject&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;comments&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Comment&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;comment_id&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span>    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;tags&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Tag&quot;</span> &gt;</span>      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tag_id&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span>    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">column</span>=<span class="string">&quot;draft&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;DraftPost&quot;</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span>  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre>]]></content>
    
    
    <summary type="html">MyBatis select元素的使用以及结果映射...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="mybatis" scheme="https://mirsery.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>读写锁</title>
    <link href="https://mirsery.github.io/2021/07/27/java/2021/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>https://mirsery.github.io/2021/07/27/java/2021/%E8%AF%BB%E5%86%99%E9%94%81/</id>
    <published>2021-07-27T12:22:10.000Z</published>
    <updated>2021-07-27T12:22:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ReadWriteLock是JDK5中提供的读写分离锁.读写锁可以有效的减少锁竞争，提升系统的吞吐量。</p></blockquote><!-- toc --><ul><li><a href="#----------">读写锁的访问约束情况</a></li><li><a href="#----------------">样例比较读写锁和重入锁的性能差距</a></li><li><a href="#---">输出值</a></li><li><a href="#--">总结</a></li></ul><!-- tocstop --><h2 id="读写锁的访问约束情况"><a href="#读写锁的访问约束情况" class="headerlink" title="读写锁的访问约束情况"></a>读写锁的访问约束情况</h2><table><thead><tr><th></th><th>读</th><th>写</th></tr></thead><tbody><tr><td>读</td><td>非阻塞</td><td>阻塞</td></tr><tr><td>写</td><td>阻塞</td><td>阻塞</td></tr></tbody></table><p>读读之间不阻塞，读和写之间相互阻塞，写和写之间阻塞。系统中如果读操作比写操作多，则可以考虑使用读写锁增加系统的吞吐量，提高系统的性能。<br>读写锁允许多个读线程同时读，使得多个读线程真正并行。但是由于数据的完整性，所以读和写之间，写和写之间需要相互等待和持有锁。读操作占用的时间越长，则使用读写锁的优势越明显。</p><h2 id="样例比较读写锁和重入锁的性能差距"><a href="#样例比较读写锁和重入锁的性能差距" class="headerlink" title="样例比较读写锁和重入锁的性能差距"></a>样例比较读写锁和重入锁的性能差距</h2><blockquote><p>测试电脑 配置<br>2.7 GHz 双核Intel Core i5, RAM 8 GB 1867 MHz DDR3<br>openjdk 16.0.1 OpenJDK 64-Bit Server VM Homebrew (build 16.0.1+0, mixed mode, sharing)</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();    <span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = reentrantReadWriteLock.readLock();    <span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = reentrantReadWriteLock.writeLock();    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">20</span>);  <span class="comment">//多线程控制</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> readThreadNum = <span class="number">20</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> writeThreadNum = <span class="number">2</span>;    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch reentrantDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">20</span>);    <span class="keyword">private</span> <span class="keyword">int</span> value;    <span class="function"><span class="keyword">public</span> Object <span class="title">readSomething</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        <span class="keyword">try</span> &#123;            lock.lock();            Thread.sleep(<span class="number">1000</span>); <span class="comment">//模拟耗时操作</span>            <span class="keyword">return</span> value;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="function"><span class="keyword">public</span> Object <span class="title">writeSomething</span><span class="params">(Lock lock, <span class="keyword">int</span> newValue)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        <span class="keyword">try</span> &#123;            lock.lock();            Thread.sleep(<span class="number">1000</span>); <span class="comment">//模拟耗时操作</span>            <span class="keyword">this</span>.value = newValue;            <span class="keyword">return</span> <span class="keyword">this</span>.value;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        ReadWriteLockDemo demo = <span class="keyword">new</span> ReadWriteLockDemo();        Runnable readTask = () -&gt; &#123;            <span class="keyword">try</span> &#123;                demo.readSomething(readLock);                countDownLatch.countDown();            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;;        Runnable writeTask = () -&gt; &#123;            <span class="keyword">try</span> &#123;                demo.writeSomething(writeLock, <span class="keyword">new</span> Random().nextInt());                countDownLatch.countDown();            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;;        Runnable readTask2 = () -&gt; &#123;            <span class="keyword">try</span> &#123;                demo.readSomething(reentrantLock);                reentrantDownLatch.countDown();            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;;        Runnable writeTask2 = () -&gt; &#123;            <span class="keyword">try</span> &#123;                demo.writeSomething(reentrantLock, <span class="keyword">new</span> Random().nextInt());                reentrantDownLatch.countDown();            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;;        <span class="keyword">long</span> begin = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; readThreadNum; i++) <span class="keyword">new</span> Thread(readTask).start();        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; writeThreadNum; i++) <span class="keyword">new</span> Thread(writeTask).start();        countDownLatch.await(); <span class="comment">//等待子线程全部完成工作</span>        <span class="keyword">long</span> end = System.currentTimeMillis();        System.out.println(<span class="string">&quot;[readWriteLock cost] &quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);        <span class="keyword">long</span> begin2 = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; readThreadNum; i++) <span class="keyword">new</span> Thread(readTask2).start();        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; writeThreadNum; i++) <span class="keyword">new</span> Thread(writeTask2).start();        reentrantDownLatch.await(); <span class="comment">//等待子线程全部完成工作</span>        <span class="keyword">long</span> end2 = System.currentTimeMillis();        System.out.println(<span class="string">&quot;[reentrantLock cost] &quot;</span> + (end2 - begin2) + <span class="string">&quot;ms&quot;</span>);    &#125;&#125;</code></pre><h2 id="输出值"><a href="#输出值" class="headerlink" title="输出值"></a>输出值</h2><p>两者的输出值，在笔者电脑上为如下所示:</p><pre><code class="highlight plaintext">[readWriteLock cost] 1011ms[reentrantLock cost] 20069ms</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>性能相差20倍多，不同的电脑和jdk版本表现有所不同。如果将读线程的数量或者耗时增加，则读写锁的性能优势会更加明显。在读多的场景下可以采用读写锁提升性能。</p>]]></content>
    
    
    <summary type="html">ReadWriteLock是JDK5中提供的读写分离锁.读写锁可以有效的减少锁竞争...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="锁" scheme="https://mirsery.github.io/tags/%E9%94%81/"/>
    
    <category term="多线程" scheme="https://mirsery.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu内核升级降级和切换</title>
    <link href="https://mirsery.github.io/2021/07/27/linux/ubuntu%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7%E9%99%8D%E7%BA%A7%E5%92%8C%E5%88%87%E6%8D%A2/"/>
    <id>https://mirsery.github.io/2021/07/27/linux/ubuntu%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7%E9%99%8D%E7%BA%A7%E5%92%8C%E5%88%87%E6%8D%A2/</id>
    <published>2021-07-27T06:52:03.000Z</published>
    <updated>2021-07-27T06:52:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#------">内核下载地址</a></li><li><a href="#------">手动升级内核</a></li><li><a href="#------">切换内核版本</a></li></ul><!-- tocstop --><blockquote><p>背景 笔者目前运行的系统是Ubuntu 20.04.2 LTS</p></blockquote><h2 id="内核下载地址"><a href="#内核下载地址" class="headerlink" title="内核下载地址"></a>内核下载地址</h2><p>下面是内核下载地址 <a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/">https://kernel.ubuntu.com/~kernel-ppa/mainline/</a></p><p><img src="/2021/07/27/linux/ubuntu%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7%E9%99%8D%E7%BA%A7%E5%92%8C%E5%88%87%E6%8D%A2/BC9FEFBF-AE3C-4C86-95DB-36A36D1824F1.png"></p><h2 id="手动升级内核"><a href="#手动升级内核" class="headerlink" title="手动升级内核"></a>手动升级内核</h2><p>选择对应的内核版本点进去，根据系统硬件的架构选择相应的目录。</p><p><img src="/2021/07/27/linux/ubuntu%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7%E9%99%8D%E7%BA%A7%E5%92%8C%E5%88%87%E6%8D%A2/4145D291-1B70-4C41-99B8-5C2E15B2CE25.png"></p><blockquote><p>一般情况下pc都是选择amd64，arm板选择arm版本。</p></blockquote><p>下载对应的deb文件（headers、image、modules）即可。</p><p>下载完成后，进入到下载目录，执行以下 命令安装内核文件</p><pre><code class="highlight bash">sudo dpkg -i *.deb</code></pre><p>留意安装过程中是否会有报错信息，安装完成后重启计算机，运行以下命令:</p><pre><code class="highlight bash"><span class="comment"># 查看当前计算机运行的内核版本号是否为你刚刚下载的版本号</span>uanme -a</code></pre><h2 id="切换内核版本"><a href="#切换内核版本" class="headerlink" title="切换内核版本"></a>切换内核版本</h2><blockquote><p>首先需要下载和安装你想要切换的内核版本，操作方法和上述步骤一致。</p></blockquote><p>下载并安装对应的内核文件之后，你可以运行以下命令:</p><pre><code class="highlight bash">grep menuentry /boot/grub/grub.cfg</code></pre><p>查看对应的系统中安装的内核版本的列表是否存在你刚刚安装的内核版本，如果没有则返回上一步核对安装过程中是否有纰漏。如果没有问题则复制你想要运行的内核版本的名称的全称。<br>修改<code>/etc/default/grub</code>文件</p><pre><code class="highlight bash">GRUB_DEFALT=<span class="string">&quot;你刚刚复制的内核版本全名称&quot;</span></code></pre><p>执行更新命令</p><pre><code class="highlight bash">sudo update grub</code></pre><p>看是否有报错信息，如果有保存信息，根据报错信息的提示进行修改。修改完成之后重复上一步的更新操作直至成功为止。然后重启电脑。</p><pre><code class="highlight bash">sudo reboot</code></pre><p>重启电脑之后查看内核版本是否更换为对应的你所切换的版本，然后再次打开<code>/etc/default/grub</code>文件，将 GRUB_DEFALT值修改为原先的0.</p>]]></content>
    
    
    <summary type="html">ubuntu 内核版本切换、升级...</summary>
    
    
    
    <category term="linux" scheme="https://mirsery.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://mirsery.github.io/tags/linux/"/>
    
    <category term="ubuntu" scheme="https://mirsery.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>mac使用技巧</title>
    <link href="https://mirsery.github.io/2021/07/27/mac/2021/mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://mirsery.github.io/2021/07/27/mac/2021/mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2021-07-27T04:36:53.000Z</published>
    <updated>2021-07-27T04:36:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#icloud-drive-----ignore--">iCloud Drive同步中实现ignore功能</a></li></ul><!-- tocstop --><h2 id="iCloud-Drive同步中实现ignore功能"><a href="#iCloud-Drive同步中实现ignore功能" class="headerlink" title="iCloud Drive同步中实现ignore功能"></a>iCloud Drive同步中实现ignore功能</h2><blockquote><p>该方法来自于苹果帮助社区<a href="https://discussions.apple.com/thread/8137146">Sal the newyorker</a></p></blockquote><p>apple iCloud Drive中如果有不想同步的文件夹，则可修改该文件夹的名称。只需要在该文件夹（不需要同步）的名字后面新增**.nosync**后缀。如果希望apple iCloudDrive同步这个文件则可以去除该后缀。</p>]]></content>
    
    
    <summary type="html">iCloud Drive同步中实现ignore功能</summary>
    
    
    
    <category term="mac" scheme="https://mirsery.github.io/categories/mac/"/>
    
    
    <category term="mac" scheme="https://mirsery.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>Future模式</title>
    <link href="https://mirsery.github.io/2021/07/24/java/2021/Future%E6%A8%A1%E5%BC%8F/"/>
    <id>https://mirsery.github.io/2021/07/24/java/2021/Future%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-24T13:48:07.000Z</published>
    <updated>2022-01-09T08:56:45.660Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#future------">future 模式的概述</a></li><li><a href="#future--------">future 模式的简单实现</a></li><li><a href="#jdk--future--">JDK中的Future模式</a></li></ul><!-- tocstop --><blockquote><p>future 模式是多线程开发中比较常见的一种模式，他的核心思想是利用多线程来实现耗时操作的异步调用。主要利用多线程去处理耗时的任务，并支持异步回调处理相关的信息。</p></blockquote><h2 id="future-模式的概述"><a href="#future-模式的概述" class="headerlink" title="future 模式的概述"></a>future 模式的概述</h2><p>future模式优点类似快递订餐，比如我们利用xx软件进行外卖下单。下完单之后我们可以继续我们上班的摸鱼动作，等待骑手的电话。其中下完单之后会立刻返回一个订单号，我们可以根据这个订单号去获取相应的订单信息。对于future模式来说，虽然他并不能立刻给予我们所需要的数据（外卖），但是他会返回订单给到我们，我们可以借由订单去获取相应的骑手以及派送状态信息。可以充分的节约我们的摸鱼时间。</p><h2 id="future-模式的简单实现"><a href="#future-模式的简单实现" class="headerlink" title="future 模式的简单实现"></a>future 模式的简单实现</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;    <span class="function"><span class="keyword">public</span> String <span class="title">getFood</span><span class="params">()</span></span>; <span class="comment">//取餐</span>&#125;</code></pre><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> record <span class="title">RealData</span><span class="params">(String result)</span> implements Data </span>&#123;<span class="comment">//since @jdk14</span>    <span class="keyword">public</span> RealData &#123;        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);<span class="comment">// 午餐制作</span>        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">getFood</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">this</span>.result;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;    <span class="keyword">protected</span> RealData realData = <span class="keyword">null</span>;    <span class="keyword">protected</span> <span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span> </span>&#123; <span class="comment">// 骑手取餐</span>        <span class="keyword">if</span> (isReady)            <span class="keyword">return</span>;        <span class="keyword">this</span>.realData = realData;        isReady = <span class="keyword">true</span>;        notifyAll();<span class="comment">//唤醒当前对象上的等待线程</span>    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getFood</span><span class="params">()</span> </span>&#123;<span class="comment">//用户取餐</span>        <span class="keyword">while</span> (!isReady) &#123;            <span class="keyword">try</span> &#123;                wait();<span class="comment">//当前线程进入等待并释放锁</span>            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="keyword">return</span> realData.getFood();    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;        <span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(String order)</span> </span>&#123;            FutureData futureData = <span class="keyword">new</span> FutureData();            <span class="keyword">new</span> Thread(() -&gt; &#123;                RealData realData = <span class="keyword">new</span> RealData(order);                futureData.setRealData(realData);            &#125;).start();            <span class="keyword">return</span> futureData;        &#125;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Client client = <span class="keyword">new</span> Client();        Data data = client.request(<span class="string">&quot;鱼香肉丝&quot;</span>); <span class="comment">//开始订餐</span>        System.out.println(<span class="string">&quot;订单已经提交，骑手赶往店铺&quot;</span>);<span class="comment">//订餐完成</span>        <span class="keyword">try</span> &#123;<span class="comment">// do something 摸鱼时间</span>            Thread.sleep(<span class="number">3000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="string">&quot;food is: &quot;</span> + data.getFood()); <span class="comment">//拿到外卖</span>    &#125;&#125;</code></pre><h2 id="JDK中的Future模式"><a href="#JDK中的Future模式" class="headerlink" title="JDK中的Future模式"></a>JDK中的Future模式</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;    <span class="keyword">private</span> String food;    <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">(String food)</span> </span>&#123;        <span class="keyword">this</span>.food = food;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);<span class="comment">//配送</span>        <span class="keyword">return</span> <span class="keyword">this</span>.food;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Food(<span class="string">&quot;鱼香肉丝&quot;</span>));    ExecutorService service = Executors.newSingleThreadExecutor();    service.execute(futureTask);    System.out.println(<span class="string">&quot;下单完成&quot;</span>);        <span class="keyword">try</span> &#123;        Thread.sleep(<span class="number">6</span> * <span class="number">1000</span>);<span class="comment">//摸鱼</span>        System.out.println(<span class="string">&quot;lunch is : &quot;</span> + futureTask.get());        service.shutdown();    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">future 模式是多线程开发中比较常见的一种模式，他的核心思想是利用多线程来实现耗时操作的异步调用。主要利用多线程去处理耗时的任务，并支持异步回调...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://mirsery.github.io/tags/java/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mirsery</title>
  
  <subtitle>兴趣使然博客</subtitle>
  <link href="https://mirsery.github.io/atom.xml" rel="self"/>
  
  <link href="https://mirsery.github.io/"/>
  <updated>2022-06-02T05:47:31.000Z</updated>
  <id>https://mirsery.github.io/</id>
  
  <author>
    <name>mirsery</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>亚马逊电子书移除DeDRM</title>
    <link href="https://mirsery.github.io/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/"/>
    <id>https://mirsery.github.io/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/</id>
    <published>2022-06-02T05:47:31.000Z</published>
    <updated>2022-06-02T05:47:31.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--calibre---">安装calibre 软件</a></li><li><a href="#--dedrm-tools--">安装DeDRM_tools插件</a></li><li><a href="#-----">转换电子书</a></li></ul><!-- tocstop --><blockquote><p>前提纪要<br>采用此方法移除Dedrm需要以下的几个前提条件:</p></blockquote><ol><li>一个合法的kindle设备序列号</li><li><a href="https://calibre-ebook.com/">calibre</a> 客户端（本文按照mac版本进行讲解)</li><li><a href="https://github.com/apprenticeharper/DeDRM_tools/releases">DeDRM_tools</a> DRM移除插件</li></ol><h2 id="安装calibre-软件"><a href="#安装calibre-软件" class="headerlink" title="安装calibre 软件"></a>安装calibre 软件</h2><p>这个比较简单，直接傻瓜式点击下载安装即可完成</p><h2 id="安装DeDRM-tools插件"><a href="#安装DeDRM-tools插件" class="headerlink" title="安装DeDRM_tools插件"></a>安装DeDRM_tools插件</h2><p>下载DeDRM_tools插件，并解压。</p><p>点击calibre &gt; Preferences 在首选项中选择插件，如下图:<br><img src="/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/C4D57509-9AFB-4E56-8269-3344686772CC.png"></p><p>选择从文件加载插件,选取刚刚已经解压的<strong>DeDRM_plugin</strong>插件进行安装，安装结束之后在搜索栏搜索该插件，并双击该条目，显示如下：</p><p><img src="/2022/06/02/talk/2022/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%94%B5%E5%AD%90%E4%B9%A6%E7%A7%BB%E9%99%A4DeDRM/78D39828-FAB0-4CB8-9F81-3930725D20F2.png"></p><p>选择<strong>elnk kindle ebooks</strong>条目，新增一个合法的kindle设备序列号，并保存。</p><h2 id="转换电子书"><a href="#转换电子书" class="headerlink" title="转换电子书"></a>转换电子书</h2><p>亚马逊中购买电子书之后，选择<strong>通过电脑下载USB传输</strong>下载格式为<strong>azw3</strong>的电子书， 利用calibre进行电子书格式的转换可以自动移除相关的DRM。</p><p>注：自己移除的DRM电子书不能在网上私自发布仅供自己阅读，尊重版权。移除DRM实属Amazon的kindle客户端阅读起来台拉胯，iBooks中国不提供图书购买服务，不得已而为之，实属无奈。</p>]]></content>
    
    
    <summary type="html">‘移除亚马逊电子书DRM版权保护’</summary>
    
    
    
    <category term="电子书" scheme="https://mirsery.github.io/categories/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
    <category term="kindle" scheme="https://mirsery.github.io/categories/%E7%94%B5%E5%AD%90%E4%B9%A6/kindle/"/>
    
    
    <category term="电子书" scheme="https://mirsery.github.io/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>自定义类加载器加载类</title>
    <link href="https://mirsery.github.io/2022/01/10/java/2022/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%B1%BB/"/>
    <id>https://mirsery.github.io/2022/01/10/java/2022/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%B1%BB/</id>
    <published>2022-01-10T13:44:05.000Z</published>
    <updated>2022-01-10T13:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#-----------">自定义加载器的编码实现</a></li></ul><!-- tocstop --><p>一般情况下在程序中开发人员使用自己编写的自定义加载器来与默认的加载器共同执行类加载任务的情况并不多见。实现一个自定义类加载器是非常简单的，只需要继承抽象类ClassLoader，并重写其findClass()方法即可。</p><h2 id="自定义加载器的编码实现"><a href="#自定义加载器的编码实现" class="headerlink" title="自定义加载器的编码实现"></a>自定义加载器的编码实现</h2><pre><code class="highlight java"><span class="comment">//自定义类加载器 myClassLoader</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;    <span class="keyword">private</span> String codePath;    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String codePath)</span> </span>&#123;        <span class="keyword">this</span>.codePath = codePath;    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;        <span class="keyword">byte</span>[] value = <span class="keyword">null</span>;        BufferedInputStream in = <span class="keyword">null</span>;        <span class="keyword">try</span> &#123;            in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(codePath+name+<span class="string">&quot;.class&quot;</span>));            value = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];            in.read(value);        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;<span class="keyword">finally</span> &#123;            <span class="keyword">try</span> &#123;                in.close();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="keyword">assert</span> value != <span class="keyword">null</span>;        <span class="keyword">return</span> defineClass(<span class="keyword">this</span>.getClass().getPackageName()+<span class="string">&quot;.&quot;</span>+name,value,<span class="number">0</span>,value.length);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;/xxx/xxx/&quot;</span>);        Class carClass  = myClassLoader.loadClass(<span class="string">&quot;Car&quot;</span>);        Object o = carClass.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class&#125;).newInstance(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>&#125;);        Method method = o.getClass().getMethod(<span class="string">&quot;run&quot;</span>);        method.invoke(o);        System.out.println(o.getClass().getClassLoader());                System.out.println(myClassLoader.getClass().getClassLoader());    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">想要在程序中实现一个自定义类加载器是非常简单的，只需要继承抽象类ClassLoader，并重写其findClass()方法即可。在此大家需要注意，尽管Java虚拟机规范将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器，但是从严格意义上来说，由Java开发人员编写的自定义类加载其实并不属于Java体系结构的组成部分，实际上它仅仅只是属于Java运行时程序的一部分而已...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="jvm" scheme="https://mirsery.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>双亲委派模型</title>
    <link href="https://mirsery.github.io/2022/01/10/java/2022/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>https://mirsery.github.io/2022/01/10/java/2022/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-01-10T06:27:39.000Z</published>
    <updated>2022-01-10T06:27:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----">背景知识</a></li><li><a href="#------">双亲委派模型</a></li><li><a href="#--------">破坏双亲委派模型</a></li></ul><!-- tocstop --><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>详细见<a href="../2019/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">类加载器</a> 章节</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的委派机制约定了类加载器的加载机制。按照双亲委派模型的规则，除了启动加载器之外，程序中每一个类加载器都应该有一个超类加载器，比如AppClassLoader的超类加载器就是ExtClassLoader，开发者编写的自定义类加载器的超类就是AppClassLoader.<br>那么当一个类加载器接收到一个类加载任务的时候，它并不会立即展开加载，而是将加载的任务委派给他的超类加载器去执行，每一层的类加载器都采用相同的方式，直至派给最顶层的启动类加载器为止。如果超类加载器无法加载委派给他的类时，便会将类的加载任务退回给他的下一级类加载器去执行加载。<br>使用双亲委派模型的优点就是能够有效地确保一个类的全局唯一性，当程序中出现多个全限定名相同的类时，类加载器在执行加载的时候，始终只会加载其中某一个类，如果通过defindClas()方法进行显示加载则JVM会抛出异常。</p><p>以下是JDK 中双亲委派的实现</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">     * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.  The</span><span class="comment">     * default implementation of this method searches for classes in the</span><span class="comment">     * following order:</span><span class="comment">     *</span><span class="comment">     * &lt;ol&gt;</span><span class="comment">     *</span><span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke &#123;<span class="doctag">@link</span> #findLoadedClass(String)&#125; to check if the class</span><span class="comment">     *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span><span class="comment">     *</span><span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #loadClass(String) loadClass&#125; method</span><span class="comment">     *   on the parent class loader.  If the parent is &#123;<span class="doctag">@code</span> null&#125; the class</span><span class="comment">     *   loader built into the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span><span class="comment">     *</span><span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #findClass(String)&#125; method to find the</span><span class="comment">     *   class.  &lt;/p&gt;&lt;/li&gt;</span><span class="comment">     *</span><span class="comment">     * &lt;/ol&gt;</span><span class="comment">     *</span><span class="comment">     * &lt;p&gt; If the class was found using the above steps, and the</span><span class="comment">     * &#123;<span class="doctag">@code</span> resolve&#125; flag is true, this method will then invoke the &#123;<span class="doctag">@link</span></span><span class="comment">     * #resolveClass(Class)&#125; method on the resulting &#123;<span class="doctag">@code</span> Class&#125; object.</span><span class="comment">     *</span><span class="comment">     * &lt;p&gt; Subclasses of &#123;<span class="doctag">@code</span> ClassLoader&#125; are encouraged to override &#123;<span class="doctag">@link</span></span><span class="comment">     * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span><span class="comment">     *</span><span class="comment">     * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span><span class="comment">     * &#123;<span class="doctag">@link</span> #getClassLoadingLock getClassLoadingLock&#125; method</span><span class="comment">     * during the entire class loading process.</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span>   name</span><span class="comment">     *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span>   resolve</span><span class="comment">     *          If &#123;<span class="doctag">@code</span> true&#125; then resolve the class</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@return</span>  The resulting &#123;<span class="doctag">@code</span> Class&#125; object</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@throws</span>  ClassNotFoundException</span><span class="comment">     *          If the class could not be found</span><span class="comment">*/</span><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)        <span class="keyword">throws</span> ClassNotFoundException    &#123;        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;            <span class="comment">// First, check if the class has already been loaded</span>            Class&lt;?&gt; c = findLoadedClass(name);            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;                <span class="keyword">long</span> t0 = System.nanoTime();                <span class="keyword">try</span> &#123;                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;                        c = parent.loadClass(name, <span class="keyword">false</span>);                    &#125; <span class="keyword">else</span> &#123;                        c = findBootstrapClassOrNull(name);                    &#125;                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;                    <span class="comment">// ClassNotFoundException thrown if class not found</span>                    <span class="comment">// from the non-null parent class loader</span>                &#125;                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;                    <span class="comment">// If still not found, then invoke findClass in order</span>                    <span class="comment">// to find the class.</span>                    <span class="keyword">long</span> t1 = System.nanoTime();                    c = findClass(name);                    <span class="comment">// this is the defining class loader; record the stats</span>                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                    PerfCounter.getFindClasses().increment();                &#125;            &#125;            <span class="keyword">if</span> (resolve) &#123;                resolveClass(c);            &#125;            <span class="keyword">return</span> c;        &#125;    &#125;</code></pre><p>在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派机制有一定的区别，当缺省的类加载器接收到到一个类的加载任务时，他首先会自行加载，当它加载失败时，才会将类的加载任务委派给他的超类加载器去执行，这也是servlet规范推荐的一种做法。</p><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>JDk种破坏双亲委派模型</p><ul><li><p>JDK1.0<br>java.lang.ClassLoader 提供了loadClass() 方法，继承ClassLoader类，重写loadClass()方法</p></li><li><p>SPI<br>一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，<br>它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。</p></li></ul><p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。<br>这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<br>有了线程上下文加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。</p><p>Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p><ul><li><p>OSGi<br>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。<br>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。<br>在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。<br>当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：<br>1）将java.＊开头的类委派给父类加载器加载。<br>2）否则，将委派列表名单内的类委派给父类加载器加载。<br>3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。<br>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。<br>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。<br>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。<br>7）否则，类加载器失败</p></li><li><p>JKD9模块系统<br>模块化加载源码片段</p><pre><code class="highlight java">Class&lt;?&gt; c = findLoadedClass(cn);      <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;         <span class="comment">// 找到当前类属于哪个模块</span>         LoadedModule loadedModule = findLoadedModule(cn);         <span class="keyword">if</span> (loadedModule != <span class="keyword">null</span>) &#123;            <span class="comment">//获取当前模块的类加载器</span>            BuiltinClassLoader loader = loadedModule.loader();            <span class="comment">//进行类加载</span>            c = findClassInModuleOrNull(loadedModule, cn);         &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 找不到模块信息才会进行双亲委派</span>         <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;           c = parent.loadClassOrNull(cn);         &#125;       &#125;</code></pre></li></ul><p>整个JDK都基于模块化进行构建，以前的rt.jar, tool.jar被拆分成数十个模块，编译的时候只编译实际用到的模块，同时各个类加载器各司其职，只加载自己负责的模块。</p><p>经过破坏后的双亲委派模型更加高效，减少了很多类加载器之间不必要的委派操作<br>JDK9的模块化可以减少Java程序打包的体积，同时拥有更好的隔离线与封装性<br>每个moudle拥有专属的类加载器，程序在并发性上也会更加出色。</p>]]></content>
    
    
    <summary type="html">类加载器是JVM执行类加载机制的前提。简单来说，类加载器的主要任务就是根据一个类的全限定名来读取此类的二进制字节流到JVM内部，然后转换为一个与目标类对应的java.lang.Class对象实例。类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来，但如今类加载器却在OSGi、字节码加解密领域大放异彩。这主要归功于Java虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在JVM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="jvm" scheme="https://mirsery.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Springboot常用注解</title>
    <link href="https://mirsery.github.io/2022/01/09/java/2022/springBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://mirsery.github.io/2022/01/09/java/2022/springBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-01-09T15:00:03.000Z</published>
    <updated>2022-01-09T15:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1springboot-spring">1.SpringBoot/spring</a></li><li><a href="#2jpa">2.Jpa</a></li><li><a href="#3------">3.全局异常处理</a></li><li><a href="#4springcloud">4.springcloud</a></li></ul><!-- tocstop --><h2 id="1-SpringBoot-spring"><a href="#1-SpringBoot-spring" class="headerlink" title="1.SpringBoot/spring"></a>1.SpringBoot/spring</h2><ul><li>@SpringBootApplication:</li></ul><p>包含@Configuration、@EnableAutoConfiguration、@ComponentScan通常用在主类上；</p><ul><li>@Repository:</li></ul><p>用于标注数据访问组件，即DAO组件；</p><ul><li>@Service:</li></ul><p>用于标注业务层组件；</p><ul><li>@RestController:</li></ul><p>用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody；</p><ul><li>@Controller:</li></ul><p>用于标注是控制层组件，需要返回页面时请用@Controller而不是@RestController；</p><ul><li>@Component:</li></ul><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注；</p><ul><li>@ResponseBody:</li></ul><p>表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，<br>加上 <strong>@responsebody</strong> 后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中；比如异步获取json数据，加上 <strong>@responsebody</strong> 后，会直接返回json数据；</p><ul><li>@RequestBody:</li></ul><p>参数前加上这个注解之后，认为该参数必填。表示接受json字符串转为对象 List等；</p><ul><li>@ComponentScan:</li></ul><p>组件扫描。个人理解相当于，如果扫描到有 <strong>@Component</strong>  <strong>@Controller</strong> <strong>@Service</strong>等这些注解的类，则把这些类注册为bean*；</p><ul><li>@Configuration:</li></ul><p>指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上；</p><ul><li>@Bean:</li></ul><p>相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理；</p><ul><li>@EnableAutoConfiguration:</li></ul><p>让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上；</p><ul><li>@AutoWired:</li></ul><p>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作；</p><p>当加上（required=false）时，就算找不到bean也不报错；</p><ul><li>@Qualifier:</li></ul><p>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用；</p><ul><li>@Resource(name=”name”,type=”type”)：</li></ul><p>没有括号内内容的话，默认byName。与@Autowired干类似的事；</p><ul><li>@RequestMapping:    </li></ul><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径；</p><p>该注解有六个属性: </p><p>params:指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。  </p><p>value:指定请求的实际地址，指定的地址可以是URI Template 模式  </p><p>method:指定请求的method类型， GET、POST、PUT、DELETE等  </p><p>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;  </p><p>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。</p><p>@GetMapping、@PostMapping等:</p><p>相当于@RequestMapping（value=”/”，method=RequestMethod.Get\Post\Put\Delete等） 。是个组合注解；</p><ul><li>@RequestParam:</li></ul><p>用在方法的参数前面。相当于 request.getParameter()；</p><ul><li>@PathVariable:</li></ul><p>路径变量。如 RequestMapping(“user/get/mac/{macAddress}”) ；</p><p>public String getByMacAddress(<br>@PathVariable(“macAddress”) String macAddress){<br>//do something;<br>}</p><p>参数与大括号里的名字相同的话，注解后括号里的内容可以不填。</p><h2 id="2-Jpa"><a href="#2-Jpa" class="headerlink" title="2.Jpa"></a>2.Jpa</h2><ul><li>@Entity @Table(name=”“):</li></ul><p>表明这是一个实体类。一般用于jpa ，这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略；</p><ul><li>@MappedSuperClass:</li></ul><p>用在确定是父类的entity上。父类的属性子类可以继承；</p><ul><li>@NoRepositoryBean:</li></ul><p>一般用作父类的repository，有这个注解，spring不会去实例化该repository；</p><ul><li>@Column: </li></ul><p>如果字段名与列名相同，则可以省略；</p><ul><li>@Id:</li></ul><p>表示该属性为主键；</p><ul><li>@GeneratedValue(strategy=GenerationType.SEQUENCE,generator = “repair_seq”):</li></ul><p>表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq；</p><ul><li>@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1):</li></ul><p>name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致；</p><ul><li>@Transient:</li></ul><p>表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性. </p><p>如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic；</p><ul><li>@Basic(fetch=FetchType.LAZY):</li></ul><p>标记可以指定实体属性的加载方式；</p><ul><li>@JsonIgnore:</li></ul><p>作用是json序列化时将java bean中的一些属性忽略掉,序列化和反序列化都受影响；</p><ul><li>@JoinColumn(name=”loginId”):</li></ul><p>一对一：本表中指向另一个表的外键。</p><p>一对多：另一个表指向本表的外键。</p><ul><li><p>@OneToOne</p></li><li><p>@OneToMany</p></li><li><p>@ManyToOne:</p></li></ul><p>对应Hibernate配置文件中的一对一，一对多，多对一。</p><h2 id="3-全局异常处理"><a href="#3-全局异常处理" class="headerlink" title="3.全局异常处理"></a>3.全局异常处理</h2><ul><li>@ControllerAdvice:</li></ul><p>包含@Component。可以被扫描到。统一处理异常；</p><ul><li>@ExceptionHandler(Exception.class):</li></ul><p>用在方法上面表示遇到这个异常就执行以下方法。</p><h2 id="4-springcloud"><a href="#4-springcloud" class="headerlink" title="4.springcloud"></a>4.springcloud</h2><ul><li>@EnableEurekaServer:</li></ul><p>用在springboot启动类上，表示这是一个eureka服务注册中心；</p><ul><li>@EnableDiscoveryClient:</li></ul><p>用在springboot启动类上，表示这是一个服务，可以被注册中心找到；</p><ul><li>@LoadBalanced:</li></ul><p>开启负载均衡能力；</p><ul><li>@EnableCircuitBreaker:</li></ul><p>用在启动类上，开启断路器功能；</p><ul><li>@HystrixCommand(fallbackMethod=”backMethod”):</li></ul><p>用在方法上，fallbackMethod指定断路回调方法；</p><ul><li>@EnableConfigServer:</li></ul><p>用在启动类上，表示这是一个配置中心，开启Config Server；</p><ul><li>@EnableZuulProxy:</li></ul><p>开启zuul路由，用在启动类上；</p><ul><li>@SpringCloudApplication:</li></ul><blockquote><p>包含@SpringBootApplication @EnableDiscovertyClient @EnableCircuitBreaker</p></blockquote><p>分别是SpringBoot注解、注册服务中心Eureka注解、断路器注解。对于SpringCloud来说，这是每一微服务必须应有的三个注解，所以才推出了@SpringCloudApplication这一注解集合。</p>]]></content>
    
    
    <summary type="html">Springboot中常用的必须掌握的基础注解合集</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="spring" scheme="https://mirsery.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>java中创建对象的几种方法</title>
    <link href="https://mirsery.github.io/2022/01/09/java/2022/java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://mirsery.github.io/2022/01/09/java/2022/java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2022-01-09T13:38:03.000Z</published>
    <updated>2022-01-09T13:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----------">测试代码，看运行结果</a></li><li><a href="#clone">Clone</a></li></ul><!-- tocstop --><p>常见的对象常见方法有4种：</p><ol><li>使用<strong>new</strong>关键字</li><li>使用<strong>clone</strong>方法</li><li>反射机制</li><li>反序列化</li></ol><p>其中采用1，3新建对象时会调用构造函数，2和4并不会调用构造函数</p><h2 id="测试代码，看运行结果"><a href="#测试代码，看运行结果" class="headerlink" title="测试代码，看运行结果"></a>测试代码，看运行结果</h2><ul><li><p>简单的bean类 Car</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;    <span class="keyword">private</span> String name;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;        <span class="keyword">return</span> <span class="keyword">super</span>.clone();    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;        System.out.println(<span class="string">&quot;create car&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot; is run !&quot;</span>);    &#125;&#125;</code></pre></li><li><p>测试类的Main方法</p></li></ul><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throw Exception </span>&#123;    <span class="comment">//new 关键字创建对象</span>    Car car1 = <span class="keyword">new</span> Car(<span class="string">&quot;mike1&quot;</span>);    car1.run();    System.out.println(<span class="string">&quot;=================&quot;</span>);    <span class="comment">//序列化</span>    ObjectOutput objectOutput = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Car&quot;</span>));    objectOutput.writeObject(car1);    objectOutput.close();    <span class="comment">//</span>    <span class="comment">//clone 创建对象</span>    Car car2 = (Car) car1.clone();    car2.setName(<span class="string">&quot;mike2&quot;</span>);    car2.run();    System.out.println(<span class="string">&quot;=================&quot;</span>);    <span class="comment">//反射创建对象</span>    Class carClass = Class.forName(Car.class.getName());    Object obj = carClass.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class&#125;).newInstance(<span class="string">&quot;mike3&quot;</span>);    Method method = obj.getClass().getMethod(<span class="string">&quot;run&quot;</span>);    method.invoke(obj);    <span class="comment">// Car car3 = (Car) carClass.getDeclaredConstructor(new Class[]&#123;String.class&#125;).newInstance(&quot;mike3&quot;);</span>    <span class="comment">// car3.run();</span>    System.out.println(<span class="string">&quot;=================&quot;</span>);    <span class="comment">//反序列化创建对象</span>    ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;Car&quot;</span>));    Car car4 = (Car) inputStream.readObject();    car4.setName(<span class="string">&quot;mike4&quot;</span>);    car4.run();&#125;</code></pre><p>下面是测试代码输出结果</p><pre><code class="highlight plaintext">create carmike1 is run !=================mike2 is run !=================create carmike3 is run !=================mike4 is run !</code></pre><p>从结果中可以得出最直接的结论，Clone和反序列化都没有执行类的构造函数。</p><h2 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h2><p>clone拷贝对象返回的是一个新的对象，而不是一个对象的引用地址；拷贝对象已经包含原来对象的信息，而不是对象的初始信息，即每次拷贝动作不是针对一个全新对象的创建。</p><p>利用clone，在内存中进行数据块的拷贝，复制已有的对象，也是生成对象的一种方式。前提是类实现Cloneable接口，Cloneable接口没有任何方法，是一个空接口，也可以称这样的接口为标志接口，只有实现了该接口，才会支持clone操作。有的人也许会问了，java中的对象都有一个默认的父类Object。<br>Object中有一个clone方法，为什么还必须要实现Cloneable接口呢，这就是cloneable接口这个标志接口的意义，只有实现了这个接口才能实现复制操作，因为jvm在复制对象的时候，会检查对象的类是否实现了Cloneable这个接口，如果没有实现，则会报CloneNotSupportedException异常。类似这样的接口还有Serializable接口、RandomAccess接口等。<br>还有值得一提的是在执行clone操作的时候，不会调用构造函数。</p>]]></content>
    
    
    <summary type="html">常见的对象常见方法有4种：使用new关键字/使用clone方法/反射机制/反序列化</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="jvm" scheme="https://mirsery.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>vue模板的使用</title>
    <link href="https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-07T04:37:38.000Z</published>
    <updated>2022-01-07T04:37:38.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#vue--api--">vue社区api描述</a></li><li><a href="#--------">组件的使用和创建</a></li></ul><!-- tocstop --><p>在前端项目中经常会遇到需要动态渲染页面的功能，一般情况下我们可以采用原生的js进行手动的插入和编写。在vue项目中可以借用vue提供的方法进行模版渲染。<br>在vue3中可以采用component组件进行动态渲染，vue2中则可以采用extend来实现。本文基于vue2来展示动态渲染示例。</p><h2 id="vue社区api描述"><a href="#vue社区api描述" class="headerlink" title="vue社区api描述"></a>vue社区api描述</h2><p>Vue.extend( options )</p><ul><li>参数<ul><li>{Object} options</li></ul></li><li>用法<br> 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</li></ul><p><strong>data</strong> 选项是特例，需要注意 - 在 <strong>Vue.extend()</strong> 中它必须是函数</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mount-point&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><pre><code class="highlight js"><span class="comment">// 创建构造器</span><span class="keyword">var</span> Profile = Vue.extend(&#123;  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&#x27;</span>,  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> &#123;      <span class="attr">firstName</span>: <span class="string">&#x27;Walter&#x27;</span>,      <span class="attr">lastName</span>: <span class="string">&#x27;White&#x27;</span>,      <span class="attr">alias</span>: <span class="string">&#x27;Heisenberg&#x27;</span>    &#125;  &#125;&#125;)<span class="comment">// 创建 Profile 实例，并挂载到一个元素上。</span><span class="keyword">new</span> Profile().$mount(<span class="string">&#x27;#mount-point&#x27;</span>)</code></pre><p>结果如下：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Walter White aka Heisenberg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre><h2 id="组件的使用和创建"><a href="#组件的使用和创建" class="headerlink" title="组件的使用和创建"></a>组件的使用和创建</h2><ul><li>基本示例</li></ul><pre><code class="highlight js"><span class="comment">// 定义一个名为 button-counter 的新组件</span>Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> &#123;      <span class="attr">count</span>: <span class="number">0</span>    &#125;  &#125;,  <span class="attr">template</span>: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span>&#125;)</code></pre><p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 **<button-counter>**。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><pre><code class="highlight js"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">&#x27;#components-demo&#x27;</span> &#125;)</code></pre><p>因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。</p>]]></content>
    
    
    <summary type="html">vuejs中使用模版渲染的示例</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://mirsery.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>新增配置webstorm和vscode支持vue别名的识别</title>
    <link href="https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AEwebstorm%E5%92%8Cvscode%E6%94%AF%E6%8C%81vue%E5%88%AB%E5%90%8D%E7%9A%84%E8%AF%86%E5%88%AB/"/>
    <id>https://mirsery.github.io/2022/01/07/%E5%89%8D%E7%AB%AF/%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AEwebstorm%E5%92%8Cvscode%E6%94%AF%E6%8C%81vue%E5%88%AB%E5%90%8D%E7%9A%84%E8%AF%86%E5%88%AB/</id>
    <published>2022-01-07T01:08:33.000Z</published>
    <updated>2022-01-07T01:08:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#vue3------">vue3项目设置别名</a></li><li><a href="#-webstorm------">为webstorm配置别名识别</a></li><li><a href="#-vscode------">为vscode配置别名识别</a></li></ul><!-- tocstop --><p>vue3项目中，默认别名”@”为”src”路径。在开发的过程中我们的集成开发环境并不能很好的识别这个别名路径，导致我们不能在开发环境中实现代码依赖的跳转，影响我们的开发体验以及开发速率.</p><h2 id="vue3项目设置别名"><a href="#vue3项目设置别名" class="headerlink" title="vue3项目设置别名"></a>vue3项目设置别名</h2><p>vue项目设置别名可以在vue.config.js中进行配置</p><pre><code class="highlight js"><span class="built_in">module</span>.exports = &#123;    <span class="attr">configureWebpack</span>: &#123;        <span class="attr">resolve</span>: &#123;            <span class="attr">alias</span>: &#123;                <span class="string">&#x27;@&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>),            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="为webstorm配置别名识别"><a href="#为webstorm配置别名识别" class="headerlink" title="为webstorm配置别名识别"></a>为webstorm配置别名识别</h2><p>在项目根目录创建<strong>websotrm.config.js</strong>文件，内容大致如下所示:</p><pre><code class="highlight js"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)<span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;    <span class="keyword">return</span> path.join(__dirname, <span class="string">&#x27;.&#x27;</span>, dir)&#125;<span class="built_in">module</span>.exports = &#123;    <span class="attr">context</span>:path.resolve(__dirname,<span class="string">&#x27;./&#x27;</span>),    <span class="attr">resolve</span>: &#123;        <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],        <span class="attr">alias</span>: &#123;            <span class="string">&#x27;@&#x27;</span>: resolve(<span class="string">&#x27;src&#x27;</span>)        &#125;    &#125;&#125;</code></pre><p>在webstorm中，选择Preferences &gt; Languages &amp; Feameworks &gt; JavaScript &gt; WebPack ,选择 resolution 的mode，选择Automatically即可。</p><h2 id="为vscode配置别名识别"><a href="#为vscode配置别名识别" class="headerlink" title="为vscode配置别名识别"></a>为vscode配置别名识别</h2><p>在项目根目录创建<strong>jsconfig.json</strong>文件，内容大致如下所示:</p><pre><code class="highlight json">&#123;  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>,    <span class="attr">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,    <span class="attr">&quot;paths&quot;</span>: &#123;      <span class="attr">&quot;@/*&quot;</span>: [        <span class="string">&quot;./src/*&quot;</span>      ]    &#125;  &#125;,  <span class="attr">&quot;exclude&quot;</span>: [    <span class="string">&quot;node_modules&quot;</span>,    <span class="string">&quot;dist&quot;</span>  ]&#125;</code></pre><p>关闭vscode，重新打开项目，vscode即可实现对别名的识别。</p>]]></content>
    
    
    <summary type="html">vue项目中增加配置文件，使得开发环境可以识别自定义的vue别名能够实现代码跳转</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://mirsery.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>前端包管理私服搭建</title>
    <link href="https://mirsery.github.io/2021/12/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/"/>
    <id>https://mirsery.github.io/2021/12/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/</id>
    <published>2021-12-17T08:01:56.000Z</published>
    <updated>2021-12-17T08:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--dokcer----verdaccio">使用dokcer容器运行verdaccio</a></li><li><a href="#verdaccio--">verdaccio配置</a></li><li><a href="#----">创建用户</a></li></ul><!-- tocstop --><p>verdaccio 是一个简单的，零配置本地私有npm软件包代理注册表。verdaccio开箱即用，拥有自己的小型数据库，能够代理其他注册表（例如npmjs.org)，缓存下载的模块。</p><p><a href="https://github.com/verdaccio/verdaccio">verdaccio项目地址</a></p><h2 id="使用dokcer容器运行verdaccio"><a href="#使用dokcer容器运行verdaccio" class="headerlink" title="使用dokcer容器运行verdaccio"></a>使用dokcer容器运行verdaccio</h2><p><a href="https://hub.docker.com/r/verdaccio/verdaccio">verdaccio docker 仓库地址 </a></p><pre><code class="highlight shell">docker run --restart=always --name verdaccio --privileged=true -v /&#123;location&#125;:/verdaccio -p 4873:4873 -d verdaccio/verdaccio</code></pre><h2 id="verdaccio配置"><a href="#verdaccio配置" class="headerlink" title="verdaccio配置"></a>verdaccio配置</h2><blockquote><p>容器内 /verdaccio/conf  配置文件</p></blockquote><pre><code class="highlight yaml"><span class="comment">#</span><span class="comment"># This is the config file used for the docker images.</span><span class="comment"># It allows all users to do anything, so don&#x27;t use it on production systems.</span><span class="comment">#</span><span class="comment"># Do not configure host and port under `listen` in this file</span><span class="comment"># as it will be ignored when using docker.</span><span class="comment"># see https://verdaccio.org/docs/en/docker#docker-and-custom-port-configuration</span><span class="comment">#</span><span class="comment"># Look here for more config file examples:</span><span class="comment"># https://github.com/verdaccio/verdaccio/tree/master/conf</span><span class="comment">#</span><span class="comment"># path to a directory with all packages</span><span class="attr">storage:</span> <span class="string">/verdaccio/storage/data</span><span class="comment"># path to a directory with plugins to include</span><span class="attr">plugins:</span> <span class="string">/verdaccio/plugins</span><span class="attr">web:</span>  <span class="comment"># WebUI is enabled as default, if you want disable it, just uncomment this line</span>  <span class="comment">#enable: false</span>  <span class="attr">title:</span> <span class="string">Verdaccio</span>  <span class="comment"># comment out to disable gravatar support</span>  <span class="comment"># gravatar: false</span>  <span class="comment"># by default packages are ordercer ascendant (asc|desc)</span>  <span class="comment"># sort_packages: asc</span>  <span class="comment"># darkMode: true</span>  <span class="comment"># logo: http://somedomain/somelogo.png</span>  <span class="comment"># favicon: http://somedomain/favicon.ico | /path/favicon.ico</span><span class="comment"># translate your registry, api i18n not available yet</span><span class="comment"># i18n:</span><span class="comment"># list of the available translations https://github.com/verdaccio/ui/tree/master/i18n/translations</span><span class="comment">#   web: en-US</span><span class="attr">auth:</span>  <span class="attr">htpasswd:</span>    <span class="attr">file:</span> <span class="string">/verdaccio/storage/htpasswd</span>    <span class="comment"># Maximum amount of users allowed to register, defaults to &quot;+infinity&quot;.</span>    <span class="comment"># You can set this to -1 to disable registration.</span>    <span class="comment"># max_users: 1000</span><span class="comment"># a list of other known repositories we can talk to</span><span class="attr">uplinks:</span>  <span class="attr">taobao:</span>    <span class="attr">url:</span> <span class="string">https://registry.npm.taobao.org/</span>  <span class="attr">npmjs:</span>    <span class="attr">url:</span> <span class="string">https://registry.npmjs.org/</span><span class="attr">packages:</span>  <span class="string">&#x27;@*/*&#x27;</span><span class="string">:</span>    <span class="comment"># scoped packages</span>    <span class="attr">access:</span> <span class="string">$all</span>    <span class="attr">publish:</span> <span class="string">$authenticated</span>    <span class="attr">unpublish:</span> <span class="string">$authenticated</span>    <span class="attr">proxy:</span> <span class="string">taobao</span>  <span class="string">&#x27;**&#x27;</span><span class="string">:</span>    <span class="comment"># allow all users (including non-authenticated users) to read and</span>    <span class="comment"># publish all packages</span>    <span class="comment">#</span>    <span class="comment"># you can specify usernames/groupnames (depending on your auth plugin)</span>    <span class="comment"># and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;</span>    <span class="attr">access:</span> <span class="string">$all</span>    <span class="comment"># allow all known users to publish/publish packages</span>    <span class="comment"># (anyone can register by default, remember?)</span>    <span class="attr">publish:</span> <span class="string">$authenticated</span>    <span class="attr">unpublish:</span> <span class="string">$authenticated</span>    <span class="comment"># if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry</span>    <span class="attr">proxy:</span> <span class="string">taobao</span><span class="comment"># You can specify HTTP/1.1 server keep alive timeout in seconds for incoming connections.</span><span class="comment"># A value of 0 makes the http server behave similarly to Node.js versions prior to 8.0.0, which did not have a keep-alive timeout.</span><span class="comment"># WORKAROUND: Through given configuration you can workaround following issue https://github.com/verdaccio/verdaccio/issues/301. Set to 0 in case 60 is not enough.</span><span class="attr">server:</span>  <span class="attr">keepAliveTimeout:</span> <span class="number">60</span><span class="attr">middlewares:</span>  <span class="attr">audit:</span>    <span class="attr">enabled:</span> <span class="literal">true</span><span class="comment"># log settings</span><span class="attr">logs:</span> &#123; <span class="attr">type:</span> <span class="string">stdout</span>, <span class="attr">format:</span> <span class="string">pretty</span>, <span class="attr">level:</span> <span class="string">http</span> &#125;<span class="comment">#experiments:</span><span class="comment">#  # support for npm token command</span><span class="comment">#  token: false</span><span class="comment">#  # enable tarball URL redirect for hosting tarball with a different server, the tarball_url_redirect can be a template string</span><span class="comment">#  tarball_url_redirect: &#x27;https://mycdn.com/verdaccio/$&#123;packageName&#125;/$&#123;filename&#125;&#x27;</span><span class="comment">#  # the tarball_url_redirect can be a function, takes packageName and filename and returns the url, when working with a js configuration file</span><span class="comment">#  tarball_url_redirect(packageName, filename) &#123;</span><span class="comment">#    const signedUrl = // generate a signed url</span><span class="comment">#    return signedUrl;</span><span class="comment">#  &#125;</span><span class="comment"># This affect the web and api (not developed yet)</span><span class="comment">#i18n:</span><span class="comment">#web: en-US</span></code></pre><p>上面是一些默认配置，我们可以简单的进行一些个性化的修改。</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>在容器内执行如下命令:</p><pre><code class="highlight shell">npm adduser --registry http://localhost:4873 # 该地址为登录地址</code></pre><p>接着输入用户名和密码以及邮箱完成注册，完成注册之后可以登录web页面查看信息。</p>]]></content>
    
    
    <summary type="html">利用verdaccio搭建私有npm源</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>docker磁盘占用与清理问题</title>
    <link href="https://mirsery.github.io/2021/12/10/docker/docker%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E6%B8%85%E7%90%86%E9%97%AE%E9%A2%98/"/>
    <id>https://mirsery.github.io/2021/12/10/docker/docker%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E4%B8%8E%E6%B8%85%E7%90%86%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-10T09:50:54.000Z</published>
    <updated>2021-12-10T09:50:54.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#--docker----">查看docker占用分布</a></li><li><a href="#----">清理方法</a><ul><li><a href="#------">自动清理命令</a></li><li><a href="#----">手动清除</a></li></ul></li></ul><!-- tocstop --><h2 id="查看docker占用分布"><a href="#查看docker占用分布" class="headerlink" title="查看docker占用分布"></a>查看docker占用分布</h2><pre><code class="highlight shell">docker system df</code></pre><pre><code class="highlight shell">docker system df -v #可以进一步查看空间占用的细节以确定是哪个镜像，容器活着本地卷占用过高的空间</code></pre><h2 id="清理方法"><a href="#清理方法" class="headerlink" title="清理方法"></a>清理方法</h2><h3 id="自动清理命令"><a href="#自动清理命令" class="headerlink" title="自动清理命令"></a>自动清理命令</h3><blockquote><p>该命令自动清理的对象如下：</p></blockquote><ul><li>已经停止的容器</li><li>未被任何容器使用的卷</li><li>未被任何容器所关联的网络</li><li>所有悬空的镜像</li></ul><pre><code class="highlight shell">docker system prune # 对空间进行自动清理docker system prune -a #清除所有未被使用的镜像和悬空镜像docker system prune -f #用以强制删除不提示信息</code></pre><p>针对容器和镜像的删除命令:</p><pre><code class="highlight shell">docker image prune #删除悬空的镜像docker container prune #删除无用的容器<span class="meta">#</span><span class="bash"></span><span class="bash"><span class="comment"># 默认情况下docker container prune命令会清理掉所有处于stopped状态的容器</span></span><span class="meta">#</span><span class="bash"></span><span class="bash">docker volume prune <span class="comment"># 删除无用的卷</span></span>docker network prune # 删除无用的网络</code></pre><h3 id="手动清除"><a href="#手动清除" class="headerlink" title="手动清除"></a>手动清除</h3><ul><li>清理卷<br>如果卷占用过高，可以清除一些不使用的卷，包括一些未被任何容器调用的卷（-v 详细信息中若显示LINKS=0，则未被调用)<pre><code class="highlight shell">docker volume rm $(docker volume ls -qf dangling=true)</code></pre></li><li>容器清理<br>如果发现是容器占用过高的空间，可以手动删除一些:<br>删除所有已退出的容器:<pre><code class="highlight shell">docker rm -v $(docker ps -aq -f status=exited)</code></pre>删除所有状态为dead的容器<pre><code class="highlight shell">docker rm -v $(docker ps -aq -f status=dead)</code></pre></li></ul>]]></content>
    
    
    <summary type="html">docker在使用一段时间后会发现宿主磁盘很容易被占满，手动清除image之后似乎并不能释放磁盘...</summary>
    
    
    
    <category term="docker" scheme="https://mirsery.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://mirsery.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu深度学习驱动安装</title>
    <link href="https://mirsery.github.io/2021/12/10/web/2021/ubuntu%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/"/>
    <id>https://mirsery.github.io/2021/12/10/web/2021/ubuntu%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/</id>
    <published>2021-12-10T06:25:31.000Z</published>
    <updated>2021-12-10T06:25:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu安装-Nvidia驱动"><a href="#Ubuntu安装-Nvidia驱动" class="headerlink" title="Ubuntu安装 Nvidia驱动"></a>Ubuntu安装 Nvidia驱动</h1><!-- toc --><ul><li><a href="#--------------">首先查看本机所安装的显卡型号</a></li><li><a href="#------">官网下载驱动</a></li><li><a href="#---------------">删除原有的开源驱动程序(可选)</a></li><li><a href="#--nouveau--">禁用nouveau驱动</a></li><li><a href="#--">重启</a></li><li><a href="#--nouveau------">验证nouveau是否已经禁用</a></li><li><a href="#--nvidia--">安装nvidia驱动</a></li><li><a href="#----------">查看驱动是否安装成功</a></li><li><a href="#----">其他问题</a></li></ul><!-- tocstop --><h2 id="首先查看本机所安装的显卡型号"><a href="#首先查看本机所安装的显卡型号" class="headerlink" title="首先查看本机所安装的显卡型号"></a>首先查看本机所安装的显卡型号</h2><pre><code class="highlight shell">lspci|grep VGA</code></pre><p><img src="/2021/12/10/web/2021/ubuntu%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/C5902CF2-5023-414E-9BBA-D7FE625ECA55.png"></p><p>根据如上所述的显卡型号，去官网下载对应的系统和对应显卡的驱动。</p><h2 id="官网下载驱动"><a href="#官网下载驱动" class="headerlink" title="官网下载驱动"></a>官网下载驱动</h2><p><a href="https://www.nvidia.cn/Download/index.aspx">nvidia驱动下载地址</a></p><p>选择对应的产品类型，产品系列以及产品型号再根据操作系统系统下载对应的驱动程序。</p><h2 id="删除原有的开源驱动程序-可选"><a href="#删除原有的开源驱动程序-可选" class="headerlink" title="删除原有的开源驱动程序(可选)"></a>删除原有的开源驱动程序(可选)</h2><pre><code class="highlight shell">sudo apt-get remove --pure nvidia*</code></pre><h2 id="禁用nouveau驱动"><a href="#禁用nouveau驱动" class="headerlink" title="禁用nouveau驱动"></a>禁用nouveau驱动</h2><p>编辑 <strong>/etc/modprobe.d/blacklist.conf</strong> ,添加以下内容:</p><pre><code class="highlight plaintext">blacklist nouveaublacklist lbm-nouveauoptions nouveau modeset=0alias nouveau offalias lbm-nouveau off</code></pre><p>关闭nouveau</p><pre><code class="highlight shell">echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</code></pre><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><pre><code class="highlight shell">update-initramfs -u reboot</code></pre><h2 id="验证nouveau是否已经禁用"><a href="#验证nouveau是否已经禁用" class="headerlink" title="验证nouveau是否已经禁用"></a>验证nouveau是否已经禁用</h2><pre><code class="highlight shell">lsmod|grep nouveau</code></pre><p>没有信息显示，说明nouveau已被禁用，接下来可以安装nvdia的显卡驱动。</p><h2 id="安装nvidia驱动"><a href="#安装nvidia驱动" class="headerlink" title="安装nvidia驱动"></a>安装nvidia驱动</h2><ul><li>给文件可执行权限</li></ul><pre><code class="highlight shell">sudo chmod +x NVIDIA-Linux-x86_64-470.86.run</code></pre><ul><li>安装</li></ul><pre><code class="highlight shell">sudo ./NVIDIA-Linux-x86_64-470.86.run -no-x-check -no-nouveau-check -no-opengl-files</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-no-x-check</td><td>安装驱动时关闭X服务</td></tr><tr><td>-no-nouveau-check</td><td>安装驱动时禁用nouveau</td></tr><tr><td>-no-opengl-files</td><td>只安装驱动文件，不安装OpenGL文件</td></tr></tbody></table><h2 id="查看驱动是否安装成功"><a href="#查看驱动是否安装成功" class="headerlink" title="查看驱动是否安装成功"></a>查看驱动是否安装成功</h2><pre><code class="highlight shell">nvidia-smi</code></pre><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>如果出现以下类似的问题</p><pre><code class="highlight plaintext">NVIDIA-SMI has failed because it couldn‘t communicate with NVIDIA driver. Make sure that the latest driver is installed and running.</code></pre><p>解决方案:</p><pre><code class="highlight shell">sudo apt-get install dkmssudo dkms install -m nvidia -v 470.86</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu安装-Nvidia驱动&quot;&gt;&lt;a href=&quot;#Ubuntu安装-Nvidia驱动&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu安装 Nvidia驱动&quot;&gt;&lt;/a&gt;Ubuntu安装 Nvidia驱动&lt;/h1&gt;&lt;!-- toc --&gt;
</summary>
      
    
    
    
    <category term="软件安装" scheme="https://mirsery.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="深度学习" scheme="https://mirsery.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>typescript笔记1</title>
    <link href="https://mirsery.github.io/2021/12/10/web/2021/typescript%E7%AC%94%E8%AE%B01/"/>
    <id>https://mirsery.github.io/2021/12/10/web/2021/typescript%E7%AC%94%E8%AE%B01/</id>
    <published>2021-12-10T05:03:42.000Z</published>
    <updated>2021-12-10T05:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="typescript-笔记-1"><a href="#typescript-笔记-1" class="headerlink" title="typescript 笔记 1"></a>typescript 笔记 1</h1><!-- toc --><ul><li><a href="#typescript---">typescript的安装</a></li><li><a href="#typescript-----">TypeScript的类型注解</a></li><li><a href="#--">接口</a></li><li><a href="#-">类</a></li><li><a href="#symbol--">symbol类型</a></li><li><a href="#-----symbols">众所周知的Symbols</a></li></ul><!-- tocstop --><h2 id="typescript的安装"><a href="#typescript的安装" class="headerlink" title="typescript的安装"></a>typescript的安装</h2><p>使用npm包的形式安装</p><pre><code class="highlight shell">npm install -g typescript</code></pre><h2 id="TypeScript的类型注解"><a href="#TypeScript的类型注解" class="headerlink" title="TypeScript的类型注解"></a>TypeScript的类型注解</h2><pre><code class="highlight typeScript"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: <span class="built_in">string</span></span>)</span>&#123;    <span class="keyword">return</span> <span class="string">&quot;hello, &quot;</span>+person;&#125;<span class="keyword">let</span> user = <span class="string">&quot;Jane User&quot;</span>;<span class="built_in">document</span>.body.innerHtml = greeter(user)</code></pre><p>TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。如果传入的参数不符合类型，则会编译器会给出相应的警告内容.</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>TypeScript里可以定义类似java中的接口，如下所示:</p><pre><code class="highlight typeScript"><span class="keyword">interface</span> Person &#123;    <span class="attr">firstName</span>: <span class="built_in">string</span>;    lastName: <span class="built_in">string</span>&#125;<span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: Person</span>) </span>&#123;    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + person.firstName + <span class="string">&quot;&quot;</span> + person.lastName;&#125;<span class="keyword">let</span> user = &#123;<span class="attr">firstName</span>:<span class="string">&quot;Jane&quot;</span>,<span class="attr">lastName</span>:<span class="string">&quot;User&quot;</span>&#125;;<span class="built_in">document</span>.body.innerHTML = greeter(user)</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>TypeScript支持JavaScript的新特性，比如支持基于类的面向对象编程。以下是官网的例子:</p><blockquote><p>在构造函数上使用public等同于创建了同名的成员变量</p></blockquote><pre><code class="highlight typeScript"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;    <span class="attr">fullName</span>: <span class="built_in">string</span>,    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> firstName,<span class="keyword">public</span> middleInitial,<span class="keyword">public</span> lastName</span>)</span>&#123;        <span class="built_in">this</span>.fullName = firstName + <span class="string">&quot; &quot;</span> + middleInitial + <span class="string">&quot; &quot;</span> + lastName;    &#125;&#125;<span class="keyword">interface</span> Person&#123;    <span class="attr">firstName</span>: <span class="built_in">string</span>,    <span class="attr">lastName</span>: <span class="built_in">string</span>;&#125;<span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: Person</span>)</span>&#123;    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + person.firstName + <span class="string">&quot; &quot;</span> + person.lastName;&#125;<span class="keyword">let</span> user = <span class="keyword">new</span> Student(<span class="string">&quot;Jane&quot;</span>,<span class="string">&quot;M.&quot;</span>,<span class="string">&quot;User&quot;</span>);<span class="built_in">document</span>.body.innerHTML = greeter(user);</code></pre><h2 id="symbol类型"><a href="#symbol类型" class="headerlink" title="symbol类型"></a>symbol类型</h2><blockquote><p>自ECMAScript 2015起，symbol成为了一种新的原生类型，就像number和string一样。</p></blockquote><p>symbol类型的值是通过Symbol构造函数创建的。</p><pre><code class="highlight typeScript"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>();<span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&quot;key&quot;</span>); <span class="comment">// 可选的字符串key</span></code></pre><p>Symbols是不可以改变且唯一的。</p><pre><code class="highlight typeScript"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&quot;key&quot;</span>);<span class="keyword">let</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">&quot;key&quot;</span>);sym2 === sym3; <span class="comment">// false, symbols是唯一的</span></code></pre><p>像字符串一样，symbols也可以被用做对象属性的键。</p><pre><code class="highlight typeScript"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();<span class="keyword">let</span> obj = &#123;    [sym]: <span class="string">&quot;value&quot;</span>&#125;;<span class="built_in">console</span>.log(obj[sym]); <span class="comment">// &quot;value&quot;</span></code></pre><p>Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员.</p><pre><code class="highlight typeScript"><span class="keyword">const</span> getClassNameSymbol = <span class="built_in">Symbol</span>();<span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;    [getClassNameSymbol]()&#123;       <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;    &#125;&#125;<span class="keyword">let</span> c = <span class="keyword">new</span> C();<span class="keyword">let</span> className = c[getClassNameSymbol](); <span class="comment">// &quot;C&quot;</span></code></pre><h2 id="众所周知的Symbols"><a href="#众所周知的Symbols" class="headerlink" title="众所周知的Symbols"></a>众所周知的Symbols</h2><p>除了用户定义的symbols，还有一些已经众所周知的内置symbols。 内置symbols用来表示语言内部的行为。</p><p>以下为这些symbols的列表：</p><ul><li><p>Symbol.hasInstance</p><p>  方法，会被<strong>instanceof</strong>运算符调用。构造器对象用来识别一个对象是否是其实例。</p></li><li><p>Symbol.isConcatSpreadable</p><p>  布尔值，表示当在一个对象上调用<strong>Array.prototype.concat</strong>时，这个对象的数组元素是否可展开。</p></li><li><p>Symbol.iterator</p><p>  方法，被<strong>for-of</strong>语句调用。返回对象的默认迭代器。</p></li><li><p>Symbol.match</p><p>  方法，被<strong>String.prototype.match</strong>调用。正则表达式用来匹配字符串。</p></li><li><p>Symbol.replace</p><p>  方法，被<strong>String.prototype.replace</strong>调用。正则表达式用来替换字符串中匹配的子串。</p></li><li><p>Symbol.search</p><p>  方法，被<strong>String.prototype.search</strong>调用。正则表达式返回被匹配部分在字符串中的索引。</p></li><li><p>Symbol.species</p><p>  函数值，为一个构造函数。用来创建派生对象。</p></li><li><p>Symbol.split</p><p>  方法，被<strong>String.prototype.split</strong>调用。正则表达式来用分割字符串。</p></li><li><p>Symbol.toPrimitive</p><p>  方法，被<strong>ToPrimitive</strong>抽象操作调用。把对象转换为相应的原始值。</p></li><li><p>Symbol.toStringTag</p><p>  方法，被内置方法<strong>Object.prototype.toString</strong>调用。返回创建对象时默认的字符串描述。</p></li><li><p>Symbol.unscopables</p><p>  对象，它自己拥有的属性会被with作用域排除在外。</p></li></ul>]]></content>
    
    
    <summary type="html">typescript是javaScript的超集，他可以编译成javaScript....</summary>
    
    
    
    <category term="js" scheme="https://mirsery.github.io/categories/js/"/>
    
    
    <category term="前端" scheme="https://mirsery.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://mirsery.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>electron-builder打包依赖存放位置</title>
    <link href="https://mirsery.github.io/2021/11/25/web/2021/electron-builder%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE/"/>
    <id>https://mirsery.github.io/2021/11/25/web/2021/electron-builder%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE/</id>
    <published>2021-11-25T06:08:42.000Z</published>
    <updated>2021-11-25T06:08:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#electron-builder-----">electron-builder 打包问题</a><ul><li><a href="#-----">缓存的位置</a></li></ul></li></ul><!-- tocstop --><h1 id="electron-builder-打包问题"><a href="#electron-builder-打包问题" class="headerlink" title="electron-builder 打包问题"></a>electron-builder 打包问题</h1><p>由于国内某些神秘力量会导致采用electron-builder打包app时，从GitHub等地下载依赖时导致文件的下载超时。为此，我们需要手动将依赖下载到指定的目录下面，才能进行下一步的打包工作。</p><h2 id="缓存的位置"><a href="#缓存的位置" class="headerlink" title="缓存的位置"></a>缓存的位置</h2><ul><li>macos</li></ul><pre><code class="highlight shell">~/Library/Caches/electron~/Library/Caches/electron-builder~/Library/Application Support/Caches</code></pre><ul><li><p>Linux </p><pre><code class="highlight shell">~/.cache/electron-builder</code></pre></li><li><p>windows</p><pre><code class="highlight shell"><span class="meta">%</span><span class="bash">LOCALAPPDATA%\\electron\\cache</span><span class="meta">%</span><span class="bash">LOCALAPPDATA%\\electron-builder\\cache</span></code></pre></li></ul>]]></content>
    
    
    <summary type="html">使用 electron-builder 打包的时候会自动下载所需的依赖，但是下载过程可能因某些神秘力量而失败。因此需要手动下载，再将工具放于指定路径...</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>npm镜像源管理</title>
    <link href="https://mirsery.github.io/2021/11/25/web/2021/npm%E9%95%9C%E5%83%8F%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>https://mirsery.github.io/2021/11/25/web/2021/npm%E9%95%9C%E5%83%8F%E6%BA%90%E7%AE%A1%E7%90%86/</id>
    <published>2021-11-25T05:42:58.000Z</published>
    <updated>2021-11-25T05:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----nrm">全局安装nrm</a></li><li><a href="#--nrm">使用nrm</a></li></ul><!-- tocstop --><p>国内由于众所周知的原因，在我们使用npm工具构建前端项目时总会发生一些令人沮丧的事情，每次都需要手动更换镜像源。nrm(npm registry manager)是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换。</p><h2 id="全局安装nrm"><a href="#全局安装nrm" class="headerlink" title="全局安装nrm"></a>全局安装nrm</h2><pre><code class="highlight shell">npm i -g nrm</code></pre><h2 id="使用nrm"><a href="#使用nrm" class="headerlink" title="使用nrm"></a>使用nrm</h2><blockquote><p>查看可用镜像源</p></blockquote><pre><code class="highlight shell">nrm list</code></pre><blockquote><p>选择使用镜像源</p></blockquote><pre><code class="highlight shell">nrm use &lt;name&gt;</code></pre><blockquote><p>增加定制源</p></blockquote><pre><code class="highlight plaintext">nrm add &lt;registry&gt; &lt;url&gt;</code></pre><p>其中reigstry为源名，url为源的路径。</p><blockquote><p>删除镜像源</p></blockquote><pre><code class="highlight shell">nrm del &lt;registry&gt;</code></pre><blockquote><p>测试源速度</p></blockquote><pre><code class="highlight shell">nrm test npm</code></pre>]]></content>
    
    
    <summary type="html">‘nrm npm镜像源管理工具’</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>npm下载包路径设置</title>
    <link href="https://mirsery.github.io/2021/11/18/web/2021/npm%E4%B8%8B%E8%BD%BD%E5%8C%85%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/"/>
    <id>https://mirsery.github.io/2021/11/18/web/2021/npm%E4%B8%8B%E8%BD%BD%E5%8C%85%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/</id>
    <published>2021-11-18T08:39:45.000Z</published>
    <updated>2021-11-18T08:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#mac-npm--------">MAC npm 下载包路径设置</a><ul><li><a href="#--npm-prefix-cache------">查看npm的prefix和cache路径配置信息</a></li><li><a href="#-----------">设置下载路径 缓存路径</a></li><li><a href="#--npm----">查看npm配置信息</a></li><li><a href="#--npm--">清空npm缓存</a></li><li><a href="#---------------------">验证缓存数据的有效性和完整性，清理垃圾数据</a></li></ul></li></ul><!-- tocstop --><h1 id="MAC-npm-下载包路径设置"><a href="#MAC-npm-下载包路径设置" class="headerlink" title="MAC npm 下载包路径设置"></a>MAC npm 下载包路径设置</h1><h2 id="查看npm的prefix和cache路径配置信息"><a href="#查看npm的prefix和cache路径配置信息" class="headerlink" title="查看npm的prefix和cache路径配置信息"></a>查看npm的prefix和cache路径配置信息</h2><pre><code class="highlight shell">npm config get cachenpm config get prefix</code></pre><h2 id="设置下载路径-缓存路径"><a href="#设置下载路径-缓存路径" class="headerlink" title="设置下载路径 缓存路径"></a>设置下载路径 缓存路径</h2><pre><code class="highlight shell">npm config set cache &quot;/cachePath&quot;npm config set prefix &quot;/prefixPath&quot;</code></pre><h2 id="查看npm配置信息"><a href="#查看npm配置信息" class="headerlink" title="查看npm配置信息"></a>查看npm配置信息</h2><pre><code class="highlight shell">npm config list</code></pre><h2 id="清空npm缓存"><a href="#清空npm缓存" class="headerlink" title="清空npm缓存"></a>清空npm缓存</h2><pre><code class="highlight shell">npm cache clean -f</code></pre><h2 id="验证缓存数据的有效性和完整性，清理垃圾数据"><a href="#验证缓存数据的有效性和完整性，清理垃圾数据" class="headerlink" title="验证缓存数据的有效性和完整性，清理垃圾数据"></a>验证缓存数据的有效性和完整性，清理垃圾数据</h2><pre><code class="highlight shell">npm cache verfy</code></pre>]]></content>
    
    
    <summary type="html">MAC npm 下载包路径设置</summary>
    
    
    
    <category term="前端" scheme="https://mirsery.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://mirsery.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>hls测试流部署</title>
    <link href="https://mirsery.github.io/2021/11/17/talk/2021/hls%E6%B5%8B%E8%AF%95%E6%B5%81%E9%83%A8%E7%BD%B2/"/>
    <id>https://mirsery.github.io/2021/11/17/talk/2021/hls%E6%B5%8B%E8%AF%95%E6%B5%81%E9%83%A8%E7%BD%B2/</id>
    <published>2021-11-17T02:36:39.000Z</published>
    <updated>2021-11-17T02:36:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用nginx/ffmpeg将mp4格式的文件转换成m3u8流，并利用web服务器进行发布</p></blockquote><!-- toc --><ul><li><a href="#hls----------">hls测试流简易部署全过程</a><ul><li><a href="#------------m3u8">第一步将下载的视频切片成m3u8</a></li><li><a href="#------------web------">第二步将切片的文件部署到web服务器中发布</a></li></ul></li></ul><!-- tocstop --><h1 id="hls测试流简易部署全过程"><a href="#hls测试流简易部署全过程" class="headerlink" title="hls测试流简易部署全过程"></a>hls测试流简易部署全过程</h1><p>web开发的过程中有时候会遇到缺少hls在线测试流的情况，这个时候就需要我们自己搭建可用的测试流服务。</p><h2 id="第一步将下载的视频切片成m3u8"><a href="#第一步将下载的视频切片成m3u8" class="headerlink" title="第一步将下载的视频切片成m3u8"></a>第一步将下载的视频切片成m3u8</h2><p>在此操作之前我们需要用到ffmpeg（<a href="https://ffmpeg.org/download.html">点击下载</a>). FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec。</p><p>下载安装完之后我们可以调用如下命令:</p><pre><code class="highlight shell">ffmpeg -i yoursource.mp4 -f segment -segment_time 60 -segment_format mpegts -segment_list yourtarget.m3u8 -c copy -bsf:v h264_mp4toannexb -map 0 yourtarget-%04d.ts</code></pre><p>上述命令会按照60s的间隔对mp4文件进行切片。</p><h2 id="第二步将切片的文件部署到web服务器中发布"><a href="#第二步将切片的文件部署到web服务器中发布" class="headerlink" title="第二步将切片的文件部署到web服务器中发布"></a>第二步将切片的文件部署到web服务器中发布</h2><p>以下是nginx服务器的简单部署配置示例</p><pre><code class="highlight plaintext">server &#123;        listen 80;        index index.html;        server_name xxxxxx; // 服务名        location /&#123;            add_header Access-Control-Allow-Origin *; //允许跨域            root /xxxx/videoPath; //视频切片存放路径        &#125; &#125;</code></pre><p>完成以上配置之后直接访问m3u8文件的web地址即可播放视频流</p>]]></content>
    
    
    <summary type="html">hls测试流简易部署全过程</summary>
    
    
    
    <category term="生活" scheme="https://mirsery.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="闲谈" scheme="https://mirsery.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>PostMan 接口调试指南</title>
    <link href="https://mirsery.github.io/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>https://mirsery.github.io/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/</id>
    <published>2021-08-27T01:59:48.000Z</published>
    <updated>2021-08-27T01:59:48.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----host--">设置线上host地址</a></li><li><a href="#-collection------------">在Collection中设置所有接口的认证方式</a></li><li><a href="#------">新建登录接口</a></li><li><a href="#------">新建其他接口</a></li></ul><!-- tocstop --><blockquote><p>Postman是API开发的一个协作平台。Postman简化构建API的每个步骤，简化了协作过程，方便开发者更快地创建更好的API。</p></blockquote><p>在web开发中接口的调试是必不可少的一环，为了方便接口的测试我们采用了多种调试工具。Postman提供了一种较为舒适的方式来测试接口，接下来我简要记录下postman的一些个人常用的功能。采用postman调试需要传入token的接口</p><h2 id="设置线上host地址"><a href="#设置线上host地址" class="headerlink" title="设置线上host地址"></a>设置线上host地址</h2><p>postman提供的environment,开发者可以在environment中定义环境的变量以及给环境赋值，environment中可以配置线上host地址用来快捷切换不同环境下的接口调试。<br><img src="/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/85996362-D0F8-46C6-AB94-87139309B230.png"></p><h2 id="在Collection中设置所有接口的认证方式"><a href="#在Collection中设置所有接口的认证方式" class="headerlink" title="在Collection中设置所有接口的认证方式"></a>在Collection中设置所有接口的认证方式</h2><blockquote><p>提供设置Collection域下的Authorization/Tests/Pre-request Script/Variables</p></blockquote><ul><li>Authorization<br>支持多种方式验证方式<br><img src="/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/AB620B7D-F13F-48CE-BFA1-36A7FFDA255E.png"></li></ul><p>下面以简单的<strong>API key</strong>类型接口测试为示例</p><ol><li><p>单击对应的Collection，选择<strong>Authorization</strong>，并在类型中选择并填入如下内容,其中<strong>token</strong> 为接口认证的key值(按照实际项目修改)，value中填入<strong>Collection变量</strong> <em></em> ,并选择认证的域为请求头<strong>header</strong>(按照实际项目修改).<br><img src="/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/FD4485D2-F81D-4EE6-9D6B-FA7B0BC7986F.png"></p></li><li><p>点击<strong>Variables</strong> ，新增以下2个变量（<strong>token</strong>,<strong>host</strong>).添加<strong>host</strong>主要是为了接口调用的时候，默认调用本地的接口，而不借助环境变量的形式访问。</p><blockquote><p>环境变量的参数会覆盖Collection下的参数</p></blockquote></li></ol><!-- **lnherit auth from parent** --><h2 id="新建登录接口"><a href="#新建登录接口" class="headerlink" title="新建登录接口"></a>新建登录接口</h2><p>在collection中新建接口，选择对应的GET、POST。在Authorization下的type选择<strong>No Auth</strong>,接着传入其余自定义的参数完成方法的构建。在tests中可以编写一些脚本对数据结果进行处理。</p><p><img src="/2021/08/27/web/2021/PostMan-%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/9DCF84DB-D287-43E8-A262-FABC5C0A8DAF.png"></p><p>请求接口中 <strong></strong> 是该请求所在的collection的变量或environment的引用（优先级如上文所述)<br>**pm.response.json()**将返回的变量解析成一个json对象（如果返回值为json格式的话），解析出登录接口返回的token值，并将token值赋给对应的collection中的变量。<br>**pm.collectionVariables.set(“token”, “token value”);**将token值传递给相应的collection变量</p><h2 id="新建其他接口"><a href="#新建其他接口" class="headerlink" title="新建其他接口"></a>新建其他接口</h2><p>新建其他的接口的时候，在Authorization下的type选择<strong>lnherit auth from parent</strong>即可继承该collection下的请求认证参数，即接口调试无须手动传入token值，方便了接口调试。</p>]]></content>
    
    
    <summary type="html">Postman是API开发的一个协作平台。Postman简化构建API的每个步骤，简化了协作过程，方便开发者更快地创建更好的API...</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Mybatis xml映射器(四)</title>
    <link href="https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%BA%94/"/>
    <id>https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%BA%94/</id>
    <published>2021-08-24T13:50:24.000Z</published>
    <updated>2021-08-24T13:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#discriminator----">discriminator 鉴别器</a><ul><li><a href="#discriminator--------">discriminator 鉴别器用法示例</a></li></ul></li><li><a href="#----">自动映射</a><ul><li><a href="#------">自动映射例子</a></li><li><a href="#------">自动映射等级</a></li></ul></li></ul><!-- tocstop --><blockquote><p>该文档摘抄自<a href="https://blog.mybatis.org./">https://blog.mybatis.org。</a></p></blockquote><h1 id="discriminator-鉴别器"><a href="#discriminator-鉴别器" class="headerlink" title="discriminator 鉴别器"></a>discriminator 鉴别器</h1><p>有时候，一个数据库查询可能会返回多个不同的结果集（但总体上还是有一定的联系的）。 鉴别器（discriminator）元素就是被设计来应对这种情况的，另外也能处理其它情况，例如类的继承层次结构。 鉴别器的概念很好理解——它很像 Java 语言中的 switch 语句。</p><h2 id="discriminator-鉴别器用法示例"><a href="#discriminator-鉴别器用法示例" class="headerlink" title="discriminator 鉴别器用法示例"></a>discriminator 鉴别器用法示例</h2><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">column</span>=<span class="string">&quot;draft&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;DraftPost&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></code></pre><p>一个鉴别器的定义需要指定 column 和 javaType 属性。column 指定了 MyBatis 查询被比较值的地方。 而 javaType 用来确保使用正确的相等测试（虽然很多情况下字符串的相等测试都可以工作）。例如：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;vehicleResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Vehicle&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;vin&quot;</span> <span class="attr">column</span>=<span class="string">&quot;vin&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;year&quot;</span> <span class="attr">column</span>=<span class="string">&quot;year&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;make&quot;</span> <span class="attr">column</span>=<span class="string">&quot;make&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;model&quot;</span> <span class="attr">column</span>=<span class="string">&quot;model&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;color&quot;</span> <span class="attr">column</span>=<span class="string">&quot;color&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">column</span>=<span class="string">&quot;vehicle_type&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;carResult&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;truckResult&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;vanResult&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;suvResult&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><p>在这个示例中，MyBatis 会从结果集中得到每条记录，然后比较它的 vehicle type 值。 如果它匹配任意一个鉴别器的 case，就会使用这个 case 指定的结果映射。 这个过程是互斥的，也就是说，剩余的结果映射将被忽略（除非它是扩展的，我们将在稍后讨论它）。 如果不能匹配任何一个 case，MyBatis 就只会使用鉴别器块外定义的结果映射。 所以，如果 carResult 的声明如下：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;carResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Car&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;doorCount&quot;</span> <span class="attr">column</span>=<span class="string">&quot;door_count&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><p>那么只有 doorCount 属性会被加载。这是为了即使鉴别器的 case 之间都能分为完全独立的一组，尽管和父结果映射可能没有什么关系。在上面的例子中，我们当然知道 cars 和 vehicles 之间有关系，也就是 Car 是一个 Vehicle。因此，我们希望剩余的属性也能被加载。而这只需要一个小修改。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;carResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Car&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;vehicleResult&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;doorCount&quot;</span> <span class="attr">column</span>=<span class="string">&quot;door_count&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><p>现在 vehicleResult 和 carResult 的属性都会被加载了，下面是等同的简洁风格:</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;vehicleResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Vehicle&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;vin&quot;</span> <span class="attr">column</span>=<span class="string">&quot;vin&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;year&quot;</span> <span class="attr">column</span>=<span class="string">&quot;year&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;make&quot;</span> <span class="attr">column</span>=<span class="string">&quot;make&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;model&quot;</span> <span class="attr">column</span>=<span class="string">&quot;model&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;color&quot;</span> <span class="attr">column</span>=<span class="string">&quot;color&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">column</span>=<span class="string">&quot;vehicle_type&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;carResult&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;doorCount&quot;</span> <span class="attr">column</span>=<span class="string">&quot;door_count&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">case</span>&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;truckResult&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;boxSize&quot;</span> <span class="attr">column</span>=<span class="string">&quot;box_size&quot;</span> /&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;extendedCab&quot;</span> <span class="attr">column</span>=<span class="string">&quot;extended_cab&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">case</span>&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;vanResult&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;powerSlidingDoor&quot;</span> <span class="attr">column</span>=<span class="string">&quot;power_sliding_door&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">case</span>&gt;</span>    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;suvResult&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;allWheelDrive&quot;</span> <span class="attr">column</span>=<span class="string">&quot;all_wheel_drive&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">case</span>&gt;</span>  <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><h1 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h1><p>当自动映射查询结果时，MyBatis 会获取结果中返回的列名并在 Java 类中查找相同名字的属性（忽略大小写）。 这意味着如果发现了 ID 列和 id 属性，MyBatis 会将列 ID 的值赋给 id 属性。<br>通常<strong>数据库列使用大写字母组成的单词命名，单词间用下划线分隔</strong>；而 <strong>Java 属性一般遵循驼峰命名法约定</strong>。为了在这两种命名方式之间启用自动映射，需要将 <strong>mapUnderscoreToCamelCase</strong> 设置为 <strong>true</strong>。</p><h2 id="自动映射例子"><a href="#自动映射例子" class="headerlink" title="自动映射例子"></a>自动映射例子</h2><p>提供了结果映射后，自动映射也能工作。在这种情况下，对于每一个结果映射，在 ResultSet 出现的列，如果没有设置手动映射，将被自动映射。在自动映射处理完毕后，再处理手动映射。 在下面的例子中，id 和 userName 列将被自动映射，hashed_password 列将根据配置进行映射.</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span>  select    user_id             as &quot;id&quot;,    user_name           as &quot;userName&quot;,    hashed_password  from some_table  where id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hashed_password&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><h2 id="自动映射等级"><a href="#自动映射等级" class="headerlink" title="自动映射等级"></a>自动映射等级</h2><p>有三种自动映射等级：</p><ul><li>NONE - 禁用自动映射。仅对手动映射的属性进行映射。</li><li>PARTIAL - 对除在内部定义了嵌套结果映射（也就是连接的属性）以外的属性进行映射(DEFAULT 默认等级s)</li><li>FULL - 自动映射所有属性。</li></ul><blockquote><p>默认值是 PARTIAL，这是有原因的。当对连接查询的结果使用 FULL 时，连接查询会在同一行中获取多个不同实体的数据，因此可能导致非预期的映射。 </p></blockquote><p>下面是可能导致风险的例子</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  select    B.id,    B.title,    A.username,  from Blog B left outer join Author A on B.author_id = A.id  where B.id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;authorResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Author&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><p>在该结果映射中，Blog 和 Author 均将被自动映射。但是注意 Author 有一个 id 属性，在 ResultSet 中也有一个名为 id 的列，所以 Author 的 id 将填入 Blog 的 id，这可不是你期望的行为。 所以，要谨慎使用 FULL。无论设置的自动映射等级是哪种，你都可以通过在结果映射上设置 autoMapping 属性来为指定的结果映射设置启用/禁用自动映射。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;false&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hashed_password&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre>]]></content>
    
    
    <summary type="html">mybatis鉴别器discriminator和自动映射</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="mybatis" scheme="https://mirsery.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis xml映射器(四)</title>
    <link href="https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E5%9B%9B/"/>
    <id>https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E5%9B%9B/</id>
    <published>2021-08-24T08:55:24.000Z</published>
    <updated>2021-08-24T08:55:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#------select---">关联的嵌套 Select 查询</a><ul><li><a href="#---------">关联的嵌套使用示例</a></li><li><a href="#---------">关联的嵌套结果映射</a></li></ul></li></ul><!-- tocstop --><blockquote><p>该文档摘抄自<a href="https://blog.mybatis.org./">https://blog.mybatis.org。</a></p></blockquote><h1 id="关联的嵌套-Select-查询"><a href="#关联的嵌套-Select-查询" class="headerlink" title="关联的嵌套 Select 查询"></a>关联的嵌套 Select 查询</h1><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>column</td><td>数据中的列名或者是列的别名。一般情况下，这和传递给<strong>resultSet.getString(columnName)</strong> 方法的参数一样。 注意：在使用复合主键的时候，你可以使用<strong>column=”{prop1=col1,prop2=col2}”<strong>这样的语法来指定多个传递给嵌套</strong>Select</strong>查询语句的列名。这会使得<strong>prop1</strong>和<strong>prop2</strong>作为参数对象，被设置为对应嵌套 Select 语句的参数。</td></tr><tr><td>select</td><td>用于加载复杂类型属性的映射语句的 ID，它会从<strong>column</strong>属性指定的列中检索数据，作为参数传递给目标<strong>select</strong>语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用<strong>column=”{prop1=col1,prop2=col2}”<strong>这样的语法来指定多个传递给嵌套</strong>Select</strong>查询语句的列名。这会使得<strong>prop1</strong>和<strong>prop2</strong>作为参数对象，被设置为对应嵌套<strong>Select</strong>语句的参数。</td></tr><tr><td>fetchType</td><td>可选的，有效值为<strong>lazy</strong>和<strong>eager</strong>.该属性设置会覆盖全局配置参数lazyLoadingEnabled</td></tr></tbody></table><h2 id="关联的嵌套使用示例"><a href="#关联的嵌套使用示例" class="headerlink" title="关联的嵌套使用示例"></a>关联的嵌套使用示例</h2><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectAuthor&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAuthor&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span>  SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><blockquote><p>这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为“N+1 查询问题”。 </p></blockquote><p>概括地讲，N+1 查询问题是这样子的：<br>你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。<br>对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。</p><h2 id="关联的嵌套结果映射"><a href="#关联的嵌套结果映射" class="headerlink" title="关联的嵌套结果映射"></a>关联的嵌套结果映射</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>resultMap</td><td>结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 ResultSet。这样的 ResultSet 有部分数据是重复的。 为了将结果集正确地映射到嵌套的对象树中, MyBatis 允许你“串联”结果映射，以便解决嵌套结果集的问题。</td></tr><tr><td>columnPrefix</td><td>当连接多个表时，你可能会不得不使用列别名来避免在 ResultSet 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。</td></tr><tr><td>notNullColumn</td><td>默认情况下，在至少一个被映射到属性的列不为空时，子对象才会被创建。 你可以在这个属性上指定非空的列来改变默认行为，指定后，Mybatis 将只在这些列非空时才创建一个子对象。可以使用逗号分隔来指定多个列。默认值：未设置（unset）。</td></tr><tr><td>autoMapping</td><td>如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。注意，本属性对外部的结果映射无效，所以不能搭配 select 或 resultMap 元素使用。默认值：未设置（unset）。</td></tr></tbody></table><p>下面是一个简单的关联嵌套结果映射</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  select    B.id            as blog_id,    B.title         as blog_title,    B.author_id     as blog_author_id,    A.id            as author_id,    A.username      as author_username,    A.password      as author_password,    A.email         as author_email,    A.bio           as author_bio  from Blog B left outer join Author A on B.author_id = A.id  where B.id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;authorResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Author&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_password&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_email&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_bio&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><blockquote><pre><div class="caption"><span>id 元素在嵌套结果映射中扮演着非常重要的角色。你应该总是指定一个或多个可以唯一标识结果的属性。 虽然，即使不指定这个属性，MyBatis 仍然可以工作，但是会产生严重的性能问题。 只需要指定可以唯一标识结果的最少属性。显然，你可以选择主键（复合主键也可以）。</span></div><code class="highlight !!!非常重要```：">上面的示例使用了外部的结果映射元素来映射关联。这使得 Author 的结果映射可以被重用。 然而，如果你不打算重用它，或者你更喜欢将你所有的结果映射放在一个具有描述性的结果映射元素中。 你可以直接将结果映射作为子元素嵌套在内。这里给出使用这种方式的等效例子：```xml&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt;   &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;   &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;   &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;   &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;   &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;</code></pre></blockquote><p>那如果博客（blog）有一个共同作者（co-author）该怎么办？select 语句看起来会是这样的：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  select    B.id            as blog_id,    B.title         as blog_title,    A.id            as author_id,    A.username      as author_username,    A.password      as author_password,    A.email         as author_email,    A.bio           as author_bio,    CA.id           as co_author_id,    CA.username     as co_author_username,    CA.password     as co_author_password,    CA.email        as co_author_email,    CA.bio          as co_author_bio  from Blog B  left outer join Author A on B.author_id = A.id  left outer join Author CA on B.co_author_id = CA.id  where B.id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;authorResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Author&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_password&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_email&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_bio&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span></span><span class="tag">    <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;coAuthor&quot;</span></span><span class="tag">    <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span></span><span class="tag">    <span class="attr">columnPrefix</span>=<span class="string">&quot;co_&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><h2 id="关联的多结果集（ResultSet）"><a href="#关联的多结果集（ResultSet）" class="headerlink" title="关联的多结果集（ResultSet）"></a>关联的多结果集（ResultSet）</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>column</td><td>当使用多个结果集时，该属性指定结果集中用于与 foreignColumn 匹配的列（多个列名以逗号隔开），以识别关系中的父类型与子类型。</td></tr><tr><td>foreignColumn</td><td>指定外键对应的列名，指定的列将与父类型中 column 的给出的列进行匹配。</td></tr><tr><td>resultSet</td><td>指定用于加载复杂类型的结果集名字。</td></tr></tbody></table><blockquote><p>解决 N+1 查询问题的方法</p></blockquote><pre><code class="highlight sql">DELIMITER $$<span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> getBlogsAndAuthors(<span class="keyword">IN</span> blog_id <span class="type">INT</span>, <span class="keyword">IN</span> author_id <span class="type">INT</span>)<span class="keyword">BEGIN</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> BLOG <span class="keyword">WHERE</span> ID <span class="operator">=</span> blog_id;<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> AUTHOR <span class="keyword">WHERE</span> ID <span class="operator">=</span> author_id;<span class="keyword">END</span> $$</code></pre><p>在映射语句中，必须通过<strong>resultSets</strong>属性为每个结果集指定一个名字，多个名字使用逗号隔开。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultSets</span>=<span class="string">&quot;blogs,authors&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">statementType</span>=<span class="string">&quot;CALLABLE&quot;</span>&gt;</span>  &#123;call getBlogsAndAuthors(#&#123;id,jdbcType=INTEGER,mode=IN&#125;)&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>现在我们可以指定使用 “authors” 结果集的数据来填充 “author” 关联：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;title&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">resultSet</span>=<span class="string">&quot;authors&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span> <span class="attr">foreignColumn</span>=<span class="string">&quot;id&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;bio&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">association</span>&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><h2 id="集合的嵌套-Select-查询"><a href="#集合的嵌套-Select-查询" class="headerlink" title="集合的嵌套 Select 查询"></a>集合的嵌套 Select 查询</h2><p>如何使用嵌套 Select 查询来为博客加载文章</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectPostsForBlog&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostsForBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span>  SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h2 id="集合的嵌套结果映射"><a href="#集合的嵌套结果映射" class="headerlink" title="集合的嵌套结果映射"></a>集合的嵌套结果映射</h2><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span>  select  B.id as blog_id,  B.title as blog_title,  B.author_id as blog_author_id,  P.id as post_id,  P.subject as post_subject,  P.body as post_body,  from Blog B  left outer join Post P on B.id = P.blog_id  where B.id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_id&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_subject&quot;</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;body&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_body&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><p>等价于</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogPostResult&quot;</span> <span class="attr">columnPrefix</span>=<span class="string">&quot;post_&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogPostResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Post&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">column</span>=<span class="string">&quot;subject&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;body&quot;</span> <span class="attr">column</span>=<span class="string">&quot;body&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></code></pre><h2 id="集合的多结果集"><a href="#集合的多结果集" class="headerlink" title="集合的多结果集"></a>集合的多结果集</h2><p>集合的多结果集的映射类似关联的多结果集映射，都是采用存储过程来实现。</p>]]></content>
    
    
    <summary type="html">关联/集合嵌套结果映射和关联/集合嵌套查询</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="mybatis" scheme="https://mirsery.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis xml映射器(三)</title>
    <link href="https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%89/"/>
    <id>https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%89/</id>
    <published>2021-08-24T07:35:59.000Z</published>
    <updated>2021-08-24T07:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#mybatis-----">Mybatis 参数映射</a><ul><li><a href="#-----">字符串替换</a></li></ul></li><li><a href="#--sql">动态sql</a><ul><li><a href="#if">if</a></li><li><a href="#choose-when-otherwise">choose、when、otherwise</a></li><li><a href="#trim-where-set">trim、where、set</a></li><li><a href="#foreach">foreach</a></li></ul></li><li><a href="#script">script</a></li></ul><!-- tocstop --><blockquote><p>该文档摘抄自<a href="https://blog.mybatis.org./">https://blog.mybatis.org。</a></p></blockquote><h1 id="Mybatis-参数映射"><a href="#Mybatis-参数映射" class="headerlink" title="Mybatis 参数映射"></a>Mybatis 参数映射</h1><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p>默认情况下，使用 <strong>#{}</strong> 参数语法时，MyBatis 会创建 <strong>PreparedStatement</strong> 参数占位符，并通过占位符安全地设置参数（就像使用 ? 一样）。 这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL 语句中直接插入一个<strong>不转义的字符串</strong>。 比如 ORDER BY 子句，这时候你可以：</p><pre><code class="highlight xml">ORDER BY $&#123;columnName&#125;</code></pre><p>如果你想<strong>select</strong>一个表，任意一个列数据时，可以写成如下方式:</p><pre><code class="highlight java"><span class="meta">@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)</span><span class="function">User <span class="title">findByColumn</span><span class="params">(<span class="meta">@Param(&quot;column&quot;)</span> String column, <span class="meta">@Param(&quot;value&quot;)</span> String value)</span></span>;</code></pre><blockquote><p> 用这种方式接受用户的输入，并用作语句参数是不安全的，会导致潜在的 SQL 注入攻击。因此，要么不允许用户输入这些字段，要么自行转义并检验这些参数。</p></blockquote><h1 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h1><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>example:</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span>    AND title like #&#123;title&#125;  <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span>    AND author_name like #&#123;author.name&#125;  <span class="tag">&lt;/<span class="name">if</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><p>choose 元素有点类似Java中的switch语句，多个条件中选择一个使用.</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  SELECT * FROM BLOG WHERE state = &#x27;ACTIVE&#x27;  <span class="tag">&lt;<span class="name">choose</span>&gt;</span>    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span>      AND title like #&#123;title&#125;    <span class="tag">&lt;/<span class="name">when</span>&gt;</span>    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span>      AND author_name like #&#123;author.name&#125;    <span class="tag">&lt;/<span class="name">when</span>&gt;</span>    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>      AND featured = 1    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span>  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><h2 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h2><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  SELECT * FROM BLOG  <span class="tag">&lt;<span class="name">where</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span>         state = #&#123;state&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span>        AND title like #&#123;title&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span>        AND author_name like #&#123;author.name&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  <span class="tag">&lt;/<span class="name">where</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。<br>如果 where 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 where 元素的功能。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span>         state = #&#123;state&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span>        AND title like #&#123;title&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span>        AND author_name like #&#123;author.name&#125;    <span class="tag">&lt;/<span class="name">if</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></code></pre><p><strong>prefixOverrides</strong> 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容。用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span>  update Author    <span class="tag">&lt;<span class="name">set</span>&gt;</span>      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;/<span class="name">set</span>&gt;</span>  where id=#&#123;id&#125;<span class="tag">&lt;/<span class="name">update</span>&gt;</span></code></pre><p>这个例子中，set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。下面是和set等价的trim写法：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></code></pre><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>foreach 常见使用场景一般是批量插入和对集合进行遍历（构造IN条件语句时).</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span>  SELECT *  FROM POST P  WHERE ID in  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span>        #&#123;item&#125;  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre><p>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符。</p><blockquote><p>你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p></blockquote><h1 id="script"><a href="#script" class="headerlink" title="script"></a>script</h1><p>要在带注解的映射器接口类中使用动态 SQL，可以使用 script 元素,比如:</p><pre><code class="highlight java"><span class="meta">@Update(&#123;&quot;&lt;script&gt;&quot;,</span><span class="meta">     &quot;update Author&quot;,</span><span class="meta">     &quot;  &lt;set&gt;&quot;,</span><span class="meta">     &quot;    &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;,</span><span class="meta">     &quot;    &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;,</span><span class="meta">     &quot;    &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;,</span><span class="meta">     &quot;    &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;,</span><span class="meta">     &quot;  &lt;/set&gt;&quot;,</span><span class="meta">     &quot;where id=#&#123;id&#125;&quot;,</span><span class="meta">     &quot;&lt;/script&gt;&quot;&#125;)</span>   <span class="function"><span class="keyword">void</span> <span class="title">updateAuthorValues</span><span class="params">(Author author)</span></span>;</code></pre>]]></content>
    
    
    <summary type="html">Mybatis的参数映射、字符串替换、动态sql、if、choose 等...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="mybatis" scheme="https://mirsery.github.io/tags/mybatis/"/>
    
    <category term="动态sql" scheme="https://mirsery.github.io/tags/%E5%8A%A8%E6%80%81sql/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis xml映射器(二)</title>
    <link href="https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%BA%8C/"/>
    <id>https://mirsery.github.io/2021/08/24/java/2021/Mybatis-xml%E6%98%A0%E5%B0%84%E5%99%A8-%E4%BA%8C/</id>
    <published>2021-08-24T07:09:18.000Z</published>
    <updated>2021-08-24T07:09:18.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><!-- tocstop --><blockquote><p>该文档摘抄自<a href="https://blog.mybatis.org./">https://blog.mybatis.org。</a><br>Mybatis xml映射器insert、update 和 delete 标签</p></blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">insert</span></span><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span></span><span class="tag">  <span class="attr">parameterType</span>=<span class="string">&quot;domain.blog.Author&quot;</span></span><span class="tag">  <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">  <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span><span class="tag">  <span class="attr">keyProperty</span>=<span class="string">&quot;&quot;</span></span><span class="tag">  <span class="attr">keyColumn</span>=<span class="string">&quot;&quot;</span></span><span class="tag">  <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;&quot;</span></span><span class="tag">  <span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">update</span></span><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;updateAuthor&quot;</span></span><span class="tag">  <span class="attr">parameterType</span>=<span class="string">&quot;domain.blog.Author&quot;</span></span><span class="tag">  <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">  <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span><span class="tag">  <span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">delete</span></span><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;deleteAuthor&quot;</span></span><span class="tag">  <span class="attr">parameterType</span>=<span class="string">&quot;domain.blog.Author&quot;</span></span><span class="tag">  <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">  <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span><span class="tag">  <span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></code></pre><p>example:</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span>&gt;</span>  insert into Author (id,username,password,email,bio)  values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)<span class="tag">&lt;/<span class="name">insert</span>&gt;</span><span class="comment">&lt;!-- 返回生成的主键id的值 --&gt;</span><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">    <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span>  insert into Author (username,password,email,bio)  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)<span class="tag">&lt;/<span class="name">insert</span>&gt;</span><span class="comment">&lt;!-- 批量插入示例 !--&gt;</span><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span><span class="tag">    <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span>  insert into Author (username, password, email, bio) values  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span>    (#&#123;item.username&#125;, #&#123;item.password&#125;, #&#123;item.email&#125;, #&#123;item.bio&#125;)  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span><span class="tag">&lt;/<span class="name">insert</span>&gt;</span><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthor&quot;</span>&gt;</span>  update Author set    username = #&#123;username&#125;,    password = #&#123;password&#125;,    email = #&#123;email&#125;,    bio = #&#123;bio&#125;  where id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">update</span>&gt;</span><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteAuthor&quot;</span>&gt;</span>  delete from Author where id = #&#123;id&#125;<span class="tag">&lt;/<span class="name">delete</span>&gt;</span></code></pre><p>Insert, Update, Delete 元素的属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>–</td></tr><tr><td>parameterType</td><td>将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td>flushCache</td><td>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td>statementType</td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td>useGeneratedKeys</td><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td>keyProperty</td><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td>keyColumn</td><td>（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td>databaseId</td><td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Mybatis xml映射器insert、update 和 delete 标签...</summary>
    
    
    
    <category term="java" scheme="https://mirsery.github.io/categories/java/"/>
    
    
    <category term="mybatis" scheme="https://mirsery.github.io/tags/mybatis/"/>
    
  </entry>
  
</feed>

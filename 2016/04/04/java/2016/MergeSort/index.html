<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 归并排序 · mirsery</title><meta name="description" content="归并排序 - mirsery"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="stylesheet" href="/css/dracula.css"><link rel="search" type="application/opensearchdescription+xml" href="https://mirsery.github.io/atom.xml" title="mirsery"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="mirsery" type="application/atom+xml">
<!-- hexo-inject:begin --><script src='https://unpkg.com/echarts@3.3.2/dist/echarts.min.js'></script><!-- hexo-inject:end --></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">mirsery</h2></a></div><a class="li component-nav-item" href="/" target="_self"><p>首页</p></a><a class="li component-nav-item" href="/archives" target="_self"><p>归档</p></a><a class="li component-nav-item" href="/categories" target="_self"><p>分类</p></a><a class="li component-nav-item" href="/tags" target="_self"><p>标签</p></a><ul class="shortcut-icons"><a href="https://github.com/mirsery" target="_blank"><img class="icon" src="/images/github.svg"></a><a href="/atom.xml" target="_blank"><img class="icon" src="/images/rss.svg"></a><a href="https://www.zhihu.com/people/mirsery" target="_blank"><img class="icon" src="/images/zhihu.svg"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post article post-block"><h1 class="post-title">归并排序</h1><div class="post-info">作者: mirsery         创建日期: 2016年4月5日</div><div class="post-content"><p>#MergeSort<br>The algorithms that we consider in this section are based on a simple operation known as merging: combining two ordered arrays to make one larger ordered array. This operation immediately leads to a simple recursive sort method known as merge- sort: to sort an array, divide it into two halves, sort the two halves (recursively), and then merge the results. As you will see, one of mergesort’s most attractive properties is that it guarantees to sort any array of N items in time proportional to N log N. Its prime disadvantage is that it uses extra space proportional to N.<br>##Abstract in-place merge<br>The straightforward approach to implementing merg- ing is to design a method that merges two disjoint ordered arrays of Comparable ob- jects into a third array. This strategy is easy to implement: create an output array of the requisite size and then choose successively the smallest remaining item from the two<br>input arrays to be the next item added to the output array.<br>However, when we mergesort a large array, we are doing a huge number of merges,<br>so the cost of creating a new array to hold the output every time that we do a merge is problematic. It would be much more desirable to have an in-place method so that we could sort the first half of the array in place, then sort the second half of the array in place, then do the merge of the two halves by moving the items around within the ar- ray, without using a significant amount of other extra space. It is worthwhile to pause momentarily to consider how you might do that. At first blush, this problem seems to be one that must be simple to solve, but solutions that are known are quite complicated, especially by comparison to alternatives that use extra space.<br>Still, the abstraction of an in-place merge is useful. Accordingly, we use the method signaturemerge(a, lo, mid, hi)tospecifyamergemethodthatputstheresultof merging the subarrays a[lo..mid] with a[mid+1..hi] into a single ordered array, leaving the result in a[lo..hi]. The code on the next page implements this merge method in just a few lines by copying everything to an auxiliary array and then merging back to the original. </p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span>
  &#123;  <span class="comment">// Merge a[lo..mid] with a[mid+1..hi].</span>
     <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid+<span class="number">1</span>;
     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo; k &lt;= hi; k++)  <span class="comment">// Copy a[lo..hi] to aux[lo..hi].</span>
        aux[k] = a[k];
     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo; k &lt;= hi; k++)  <span class="comment">// Merge back to a[lo..hi].</span>
        <span class="keyword">if</span>      (i &gt; mid)              a[k] = aux[j++];
        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi )              a[k] = aux[i++];
        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) a[k] = aux[j++];
        <span class="keyword">else</span>                           a[k] = aux[i++];
  &#125;</code></pre>
<p>This method merges by first copying into the auxiliary array aux[] then merging back to a[]. In the merge (the second for loop), there are four conditions: left half exhausted (take from the right), right half exhausted (take from the left), current key on right less than current key on left (take from the right), and current key on right greater than or equal to current key on left (take from the left).<br>##Top-down mergesort<br>It is one of the best-known examples of the utility of the divide-and-conquer paradigm for efficient algorithm design. This recursive code is the basis for an inductive proof that the algorithm sorts the array: if it sorts the two subarrays, it sorts the whole array, by merg- ing together the subarrays.<br>To understand mergesort, it is worthwhile to consider carefully the dynamics of the method calls, shown in the trace at right. To sort a[0..15], the sort() method calls itself to sort a[0..7] then calls itself to sort a[0..3] and a[0..1] before finally doing the first merge of a[0] with a[1] after calling itself to sort a[0] and then a[1] (for brevity, we omit the calls for the base-case 1-entry sorts in the trace). Then the next merge is a[2] with a[3] and then a[0..1] with a[2..3] and so forth. From this trace, we see that the sort code simply provides an orga- nized way to sequence the calls to the merge() method. This insight will be useful later in this section.<br>The recursive code also provides us with the basis for analyzing mergesort’s running time. Because mergesort is a prototype of the divide-and-conquer algorithm de- sign paradigm, we will consider this analysis in detail.</p>
<pre><code class="highlight java">
  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Merge</span>
  &#123;
     <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;      <span class="comment">// auxiliary array for merges</span>
     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>
     &#123;
        aux = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];    <span class="comment">// Allocate space just once.</span>
        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);
     &#125;
     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>
     &#123;  <span class="comment">// Sort a[lo..hi].</span>
        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;
        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo)/<span class="number">2</span>;
        sort(a, lo, mid);       <span class="comment">// Sort left half.</span>
        sort(a, mid+<span class="number">1</span>, hi);     <span class="comment">// Sort right half.</span>
        merge(a, lo, mid, hi);  <span class="comment">// Merge results (code on page 271).</span>
&#125; &#125;</code></pre>
<p>##Use insertion sort for small subarrays.<br>We can improve most recursive algorithms by handling small cases differently, because the recursion guarantees that the method will be used often for small cases, so improvements in handling them lead to improvements in the whole algorithm. In the case of sorting, we know that insertion sort (or selection sort) is simple and therefore likely to be faster than mergesort for tiny subarrays. As usual, a visual trace provides insight into the operation of mergesort. The visual trace on the facing page shows the operation of a mergesort implementation with a cutoff for small subarrays. Switching to insertion sort for small subarrays (length 15 or less, say) will improve the running time of a typical mergesort implementation by 10 to 15 percent (see Exercise 2.2.23).<br>Test whether the array is already in order. We can reduce the running time to be linear for arrays that are already in order by adding a test to skip the call to merge() if a[mid] is less than or equal to a[mid+1].<br>##Eliminatethecopytotheauxiliaryarray.<br>It is possible to eliminate the time(but not the space) taken to copy to the auxiliary array used for merging. To do so, we use two invocations of the sort method: one takes its input from the given array and puts the sorted output in the auxiliary array; the other takes its input from the auxiliary array and puts the sorted output in the given array. </p>
<p>![](.&#x2F;_image&#x2F;屏幕快照 2017-01-28 00.54.31.png)<br>It is appropriate to repeat here a point raised in Chapter 1 that is easily forgotten and needs reemphasis. Locally, we treat each algorithm in this book as if it were critical in some application. Globally, we try to reach general conclusions about which approach to recommend. Our discussion of such improvements is not necessarily a recommen- dation to always implement them, rather a warning not to draw absolute conclusions about performance from initial implementations. When addressing a new problem, your best bet is to use the simplest implementation with which you are comfortable and then refine it if it becomes a bottleneck. Addressing improvements that decrease running time just by a constant factor may not otherwise be worthwhile. You need to test the effectiveness of specific improvements by running experiments, as we indicate in exercises throughout.<br>In the case of mergesort, the three improvements just listed are simple to implement and are of interest when mergesort is the method of choice—for example, in situations discussed at the end of this chapter.<br>##Bottom-up mergesort<br>The recursive implementation of mergesort is prototypi- cal of the divide-and-conquer algorithm design paradigm, where we solve a large prob- lem by dividing it into pieces, solving the subproblems, then using the solutions for the pieces to solve the whole problem. Even though we are thinking in terms of merging together two large subarrays, the fact is that most merges are merging together tiny subarrays. Another way to implement mergesort is to organize the merges so that we do all the merges of tiny subarrays on one pass, then do a second pass to merge those sub- arrays in pairs, and so forth, continuing until we do a merge that encompasses the whole array. This method requires even less code than the standard recursive implementation. We start by doing a pass 2 of 1-by-1 merges (considering individual items as subarrays of size 1), then a pass of 2-by-2 merges (merge subarrays of size 2 to make subarrays of size 4), then 4-by-4 merges, and so forth. The sec- ond subarray may be smaller than the first in the last merge on each pass (which is no problem for merge()), but otherwise all merges involve subar- rays of equal size, doubling the sorted subarray size for the next pass.</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeBU</span>
  &#123;
     <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;      <span class="comment">// auxiliary array for merges</span>
     <span class="comment">// See page 271 for merge() code.</span>
     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>
     &#123;  <span class="comment">// Do lg N passes of pairwise merges.</span>
 &#125; &#125;
<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;
aux = <span class="keyword">new</span> <span class="title class_">Comparable</span>[N];
<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> <span class="number">1</span>; sz &lt; N; sz = sz+sz)
                                         <span class="comment">// sz: subarray size</span>
<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>; lo &lt; N-sz; lo += sz+sz) <span class="comment">// lo: subarray index</span>
merge(a, lo, lo+sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, N-<span class="number">1</span>));</code></pre>
<pre><code class="highlight java">
 * Created by mirsery on <span class="number">2017</span>/<span class="number">1</span>/<span class="number">20.</span>
 */
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;

            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; <span class="comment">// i是第一段序列的下标</span>

            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>; <span class="comment">// j是第二段序列的下标</span>

            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// k是临时存放合并序列的下标</span>

            <span class="type">int</span>[] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[high - low + <span class="number">1</span>]; <span class="comment">// array2是临时合并序列</span>

            <span class="comment">// 扫描第一段和第二段序列，直到有一个扫描结束</span>
            <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;
                <span class="comment">// 判断第一段和第二段取出的数哪个更小，将其存入合并序列，并继续向下扫描</span>
                <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;
                    array2[k] = array[i];
                    i++;
                    k++;
                &#125; <span class="keyword">else</span> &#123;
                    array2[k] = array[j];
                    j++;
                    k++;
                &#125;
            &#125;

            <span class="comment">// 若第一段序列还没扫描完，将其全部复制到合并序列</span>
            <span class="keyword">while</span> (i &lt;= mid) &#123;
                array2[k] = array[i];
                i++;
                k++;
            &#125;

            <span class="comment">// 若第二段序列还没扫描完，将其全部复制到合并序列</span>
            <span class="keyword">while</span> (j &lt;= high) &#123;
                array2[k] = array[j];
                j++;
                k++;
            &#125;

            <span class="comment">// 将合并序列复制到原始序列中</span>
            <span class="keyword">for</span> (k = <span class="number">0</span>, i = low; i &lt;= high; i++, k++) &#123;
                array[i] = array2[k];
            &#125;

        &#125;

        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MergePass</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> gap, <span class="type">int</span> length)</span> &#123;
            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;

            <span class="comment">// 归并gap长度的两个相邻子表</span>
            <span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">2</span> * gap - <span class="number">1</span> &lt; length; i = i + <span class="number">2</span> * gap) &#123;
                Merge(array, i, i + gap - <span class="number">1</span>, i + <span class="number">2</span> * gap - <span class="number">1</span>);
            &#125;

            <span class="comment">// 余下两个子表，后者长度小于gap</span>
            <span class="keyword">if</span> (i + gap - <span class="number">1</span> &lt; length) &#123;
                Merge(array, i, i + gap - <span class="number">1</span>, length - <span class="number">1</span>);
            &#125;

        &#125;

        <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] list) &#123;
            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>; gap &lt; list.length; gap = <span class="number">2</span> * gap) &#123;
                MergePass(list, gap, list.length);
                System.out.print(<span class="string">&quot;gap = &quot;</span> + gap + <span class="string">&quot;:\t&quot;</span>);
                <span class="built_in">this</span>.printAll(list);
            &#125;
            <span class="keyword">return</span> list;
        &#125;

        <span class="comment">// 打印完整序列</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAll</span><span class="params">(<span class="type">int</span>[] list)</span> &#123;
            <span class="keyword">for</span> (<span class="type">int</span> value : list) &#123;
                System.out.print(value + <span class="string">&quot;\t&quot;</span>);
            &#125;
            System.out.println();
        &#125;

        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;

            <span class="type">int</span>[] array = &#123;
               <span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>
            &#125;;

            <span class="type">MergeSort</span> <span class="variable">merge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MergeSort</span>();
            System.out.print(<span class="string">&quot;排序前:\t\t&quot;</span>);
            merge.printAll(array);

            merge.sort(array);
            System.out.print(<span class="string">&quot;排序后:\t\t&quot;</span>);
            merge.printAll(array);
        &#125;
&#125;</code></pre></div></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'mirsery';
var disqus_identifier = '2016/04/04/java/2016/MergeSort/';
var disqus_title = '归并排序';
var disqus_url = 'https://mirsery.github.io/2016/04/04/java/2016/MergeSort/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a class="prev" href="/2016/04/14/linux/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84linux%E5%91%BD%E4%BB%A4/">上一篇</a><a class="next" href="/2015/12/05/docker/Docker%E6%B5%85%E8%B0%88/">下一篇</a></div><div class="copyright"><p>© 2015 - 2024 <a href="https://mirsery.github.io">mirsery</a> </p><p>powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and  <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a></p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"mirsery",'auto');ga('send','pageview');</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7201423389984397" crossorigin="anonymous"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>
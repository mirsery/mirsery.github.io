<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> java内存模型 · mirsery</title><meta name="description" content="java内存模型 - mirsery"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="stylesheet" href="/css/dracula.css"><link rel="search" type="application/opensearchdescription+xml" href="https://mirsery.github.io/atom.xml" title="mirsery"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="mirsery" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">mirsery</h2></a></div><a class="li component-nav-item" href="/" target="_self"><p>首页</p></a><a class="li component-nav-item" href="/archives" target="_self"><p>归档</p></a><a class="li component-nav-item" href="/categories" target="_self"><p>分类</p></a><a class="li component-nav-item" href="/tags" target="_self"><p>标签</p></a><ul class="shortcut-icons"><a href="https://github.com/mirsery" target="_blank"><img class="icon" src="/images/github.svg"></a><a href="/atom.xml" target="_blank"><img class="icon" src="/images/rss.svg"></a><a href="https://www.zhihu.com/people/mirsery" target="_blank"><img class="icon" src="/images/zhihu.svg"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post article post-block"><h1 class="post-title">java内存模型</h1><div class="post-info">作者: mirsery         创建日期: 2016年6月24日</div><div class="post-content"><p>#volatile变量<br>    关键字volatile是java虚拟机提供的轻量级的同步机制。<br>volatile修饰的变量具备的特性：</p>
<pre><code>- 保证此变量对所有线程的可见性，这里的可见性指的是当一条线程修改了这个变量的值，新的值对于其他线程是可以立即知道的，而普通变量不       能做到这点，普通变量的值在线程间传递需要通过主内存完成。例如：线程A修改一个普通变量的值，然后向主内存进行回写，另一条线程B在线程A回写完了之后再从主内存进行读取操作，新变量值才会对线程B可见。
- 使用volarile变量的第二个语义就是禁止指令重新排序优化，普通的变量仅仅会保证在该方法执行的过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序于程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这就是java内存模型中描述的所谓的“线程内表现为串行的语义”。
</code></pre>
<p>volatile变量只能保证可见性，在不符合以下规则的情况下，仍然需要加锁来保持原子性。</p>
<pre><code>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
变量不需要于其他的状态变量共同参与不变约束。
</code></pre>
<p>#对于long和double型变量的特殊规则<br>    java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性。但是对于64位的机器，在模型中提出了一个相对宽松的规定：允许虚拟机将没有被volatile修饰的64为数据的读写操作划分为2此32位来进行，及虚拟机实现选择可以不保证64位数据类型的load、store、read、write这4个操作的原子性。这点就是所谓的long和double的非原子协定。<br>#原子性、可见性于有序性<br>##原子性<br>    原子性（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。<br>    如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。<br>##可见性<br>    可见性（Visibility）：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。上文在讲解volatile变量的时候我们已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。<br>    除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。如代码清单12-7所示，变量i与j都具备可见性，它们无须同步就能被其他线程正确访问。<br>##有序性<br>    Java内存模型的有序性在前面讲解volatile时也详细地讨论过了，Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。<br>    Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。<br>#先行发生原则<br>    先行发生是java内存模型中定义的两项操作之间的偏序关系，如果说操作A先于操作B，其实就是说发生操作B之前，操作A产生的影响能被操作B观察到，“影响包括修改了内存中共享变量的值、发送了消息、调用了方法等。”<br>java语言无需任何同步手段保障就能成立的先行发生规则如下：<br>##程序次序规则<br>    在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。<br>##管程锁定规则<br>    一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。<br>##volatile变量规则<br>    对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。<br>##线程启动规则<br>    Thread对象的start（）方法先行发生于此线程的每一个动作。<br>##线程终止规则<br>    线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。<br>##线程中断规则<br>    对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。<br>##对象终结原则<br>    一个对象的初始化完成（构造方法执行结束）先行发生于他的finalize()方法的开始。<br>##传递性<br>    如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。<br>衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p>
</div></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'mirsery';
var disqus_identifier = '2016/06/24/java/2016/java内存模型/';
var disqus_title = 'java内存模型';
var disqus_url = 'https://mirsery.github.io/2016/06/24/java/2016/java内存模型/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a class="prev" href="/2016/06/24/java/2016/java%E4%B8%8E%E7%BA%BF%E7%A8%8B/">上一篇</a><a class="next" href="/2016/06/20/java/2016/jvm%E7%9A%84%E6%BA%A2%E5%87%BA/">下一篇</a></div><div class="copyright"><p>© 2015 - 2023 <a href="https://mirsery.github.io">mirsery</a> </p><p>powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and  <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a></p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"mirsery",'auto');ga('send','pageview');</script></body></html>
<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> git的rebase和merge · mirsery</title><meta name="description" content="git的rebase和merge - mirsery"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="stylesheet" href="/css/dracula.css"><link rel="search" type="application/opensearchdescription+xml" href="https://mirsery.github.io/atom.xml" title="mirsery"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="mirsery" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">mirsery</h2></a></div><a class="li component-nav-item" href="/" target="_self"><p>首页</p></a><a class="li component-nav-item" href="/archives" target="_self"><p>归档</p></a><a class="li component-nav-item" href="/categories" target="_self"><p>分类</p></a><a class="li component-nav-item" href="/tags" target="_self"><p>标签</p></a><ul class="shortcut-icons"><a href="https://github.com/mirsery" target="_blank"><img class="icon" src="/images/github.svg"></a><a href="/atom.xml" target="_blank"><img class="icon" src="/images/rss.svg"></a><a href="https://www.zhihu.com/people/mirsery" target="_blank"><img class="icon" src="/images/zhihu.svg"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post article post-block"><h1 class="post-title">git的rebase和merge</h1><div class="post-info">作者: mirsery         创建日期: 2016年8月6日</div><div class="post-content"><h1 id="衍合"><a href="#衍合" class="headerlink" title="衍合"></a>衍合</h1><p>把一个分支整合到另一个分支的办法有两种：merge（合并） 和 rebase（衍合）。</p>
<h2 id="衍合基础"><a href="#衍合基础" class="headerlink" title="衍合基础"></a>衍合基础</h2><p>假设在接下来的一次软件发布中，你决定把客户端的修改先合并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。你可以仅提取对客户端的改变（C8 和 C9），然后通过使用 git rebase 的 –onto 选项来把它们在 master 分支上重演：</p>
<p>$ git rebase –onto master server client<br>这基本上等于在说“检出 client 分支，找出 client 分支和 server 分支的共同祖先之后的变化，然后把它们在 master 上重演一遍”。是不是有点复杂？不过它的结果，如图 3-32 所示，非常酷：<br><img src="/2016/08/06/git/git%E7%9A%84rebase%E5%92%8Cmerge/15-52-03.png"><br>现在可以快进 master 分支了（见图 3-33）：<br>$ git checkout master<br>$ git merge client<br><img src="/2016/08/06/git/git%E7%9A%84rebase%E5%92%8Cmerge/15-53-30.png"><br>现在你决定把 server 分支的变化也包含进来。可以直接把 server 分支衍合到 master 而不用手工转到 server 分支再衍合。git rebase [主分支] [特性分支] 命令会先检出特性分支 server，然后在主分支 master 上重演：</p>
<p>$ git rebase master server<br>于是 server 的进度应用到 master 的基础上，如图 3-34：</p>
<p><img src="/2016/08/06/git/git%E7%9A%84rebase%E5%92%8Cmerge/15-54-04.png"><br>然后快进主分支 master：</p>
<p>$ git checkout master<br>$ git merge server<br>现在 client 和 server 分支的变化都被整合了，不妨删掉它们，把你的提交历史变成图 3-35 的样子：</p>
<p><img src="/2016/08/06/git/git%E7%9A%84rebase%E5%92%8Cmerge/15-54-50.png"><br>$ git branch -d client<br>$ git branch -d server</p>
<p>##衍合的风险</p>
<p>呃，奇妙的衍合也不是完美无缺的，一句话可以总结这点：</p>
<p>永远不要衍合那些已经推送到公共仓库的更新。</p>
<p>如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>
<p>在衍合的时候，实际上抛弃了一些现存的 commit 而创造了一些类似但不同的新 commit。如果你把commit 推送到某处然后其他人下载并在其基础上工作，然后你用 git rebase 重写了这些commit 再推送一次，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容的时候事情就会变得一团糟。</p>
<p>下面我们用一个实际例子来说明为什么公开的衍合会带来问题。<br>假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图 3-36：<br><img src="/2016/08/06/git/git%E7%9A%84rebase%E5%92%8Cmerge/15-56-06.jpg"><br>现在，其他人进行了一些包含一次合并的工作（得到结果 C6），然后把它推送到了中央服务器。你获取了这些数据并把它们合并到你本地的开发进程里，让你的历史变成类似图 3-37 这样：<br><img src="/2016/08/06/git/git%E7%9A%84rebase%E5%92%8Cmerge/15-56-43.jpg"><br>接下来，那个推送 C6 上来的人决定用衍合取代那次合并；他们用 git push –force 覆盖了服务器上的历史，得到 C4’。然后你再从服务器上获取更新：<br><img src="/2016/08/06/git/git%E7%9A%84rebase%E5%92%8Cmerge/15-57-18.jpg"><br>这时候，你需要再次合并这些内容，尽管之前已经做过一次了。衍合会改变这些 commit 的 SHA-1 校验值，这样 Git 会把它们当作新的 commit，然而这时候在你的提交历史早就有了 C4 的内容（见图 3-39）:<br><img src="/2016/08/06/git/git%E7%9A%84rebase%E5%92%8Cmerge/15-58-12.jpg"><br>你迟早都是要并入其他协作者提交的内容的，这样才能保持同步。当你做完这些，你的提交历史里会同时包含 C4 和 C4’，两者有着不同的 SHA-1 校验值，但却拥有一样的作者日期与提交说明，令人费解！更糟糕的是，当你把这样的历史推送到服务器，会再次把这些衍合的提交引入到中央服务器，进一步迷惑其他人。</p>
<p>如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些永远不会公开的 commit，那就不会有任何问题。如果衍合那些已经公开的 commit，而与此同时其他人已经用这些 commit 进行了后续的开发工作，那你有得麻烦了。</p>
</div></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'mirsery';
var disqus_identifier = '2016/08/06/git/git的rebase和merge/';
var disqus_title = 'git的rebase和merge';
var disqus_url = 'https://mirsery.github.io/2016/08/06/git/git的rebase和merge/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a class="prev" href="/2016/08/10/linux/linux%E4%B8%8B%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7/">上一篇</a><a class="next" href="/2016/08/06/git/git%E6%89%93%E6%A0%87%E7%AD%BE/">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://mirsery.github.io">mirsery</a> </p><p>powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and  <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a></p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"mirsery",'auto');ga('send','pageview');</script></body></html>
<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Springboot常用注解 · mirsery</title><meta name="description" content="Springboot常用注解 - mirsery"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="stylesheet" href="/css/dracula.css"><link rel="search" type="application/opensearchdescription+xml" href="https://mirsery.github.io/atom.xml" title="mirsery"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="mirsery" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">mirsery</h2></a></div><a class="li component-nav-item" href="/" target="_self"><p>首页</p></a><a class="li component-nav-item" href="/archives" target="_self"><p>归档</p></a><a class="li component-nav-item" href="/categories" target="_self"><p>分类</p></a><a class="li component-nav-item" href="/tags" target="_self"><p>标签</p></a><ul class="shortcut-icons"><a href="https://github.com/mirsery" target="_blank"><img class="icon" src="/images/github.svg"></a><a href="/atom.xml" target="_blank"><img class="icon" src="/images/rss.svg"></a><a href="https://www.zhihu.com/people/mirsery" target="_blank"><img class="icon" src="/images/zhihu.svg"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post article post-block"><h1 class="post-title">Springboot常用注解</h1><div class="post-info">作者: mirsery         创建日期: 2022年1月9日</div><div class="post-content"><!-- toc -->

<ul>
<li><a href="#1springbootspring">1.SpringBoot/spring</a></li>
<li><a href="#2jpa">2.Jpa</a></li>
<li><a href="#3%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">3.全局异常处理</a></li>
<li><a href="#4springcloud">4.springcloud</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1springbootspring">1.SpringBoot/spring</span></h2><ul>
<li>@SpringBootApplication:</li>
</ul>
<p>包含@Configuration、@EnableAutoConfiguration、@ComponentScan通常用在主类上；</p>
<ul>
<li>@Repository:</li>
</ul>
<p>用于标注数据访问组件，即DAO组件；</p>
<ul>
<li>@Service:</li>
</ul>
<p>用于标注业务层组件；</p>
<ul>
<li>@RestController:</li>
</ul>
<p>用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody；</p>
<ul>
<li>@Controller:</li>
</ul>
<p>用于标注是控制层组件，需要返回页面时请用@Controller而不是@RestController；</p>
<ul>
<li>@Component:</li>
</ul>
<p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注；</p>
<ul>
<li>@ResponseBody:</li>
</ul>
<p>表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，<br>加上 <strong>@responsebody</strong> 后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中；比如异步获取json数据，加上 <strong>@responsebody</strong> 后，会直接返回json数据；</p>
<ul>
<li>@RequestBody:</li>
</ul>
<p>参数前加上这个注解之后，认为该参数必填。表示接受json字符串转为对象 List等；</p>
<ul>
<li>@ComponentScan:</li>
</ul>
<p>组件扫描。个人理解相当于，如果扫描到有 <strong>@Component</strong>  <strong>@Controller</strong> <strong>@Service</strong>等这些注解的类，则把这些类注册为bean*；</p>
<ul>
<li>@Configuration:</li>
</ul>
<p>指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上；</p>
<ul>
<li>@Bean:</li>
</ul>
<p>相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理；</p>
<ul>
<li>@EnableAutoConfiguration:</li>
</ul>
<p>让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上；</p>
<ul>
<li>@AutoWired:</li>
</ul>
<p>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作；</p>
<p>当加上（required=false）时，就算找不到bean也不报错；</p>
<ul>
<li>@Qualifier:</li>
</ul>
<p>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用；</p>
<ul>
<li>@Resource(name=”name”,type=”type”)：</li>
</ul>
<p>没有括号内内容的话，默认byName。与@Autowired干类似的事；</p>
<ul>
<li>@RequestMapping:    </li>
</ul>
<p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径；</p>
<p>该注解有六个属性: </p>
<p>params:指定request中必须包含某些参数值是，才让该方法处理。</p>
<p>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。  </p>
<p>value:指定请求的实际地址，指定的地址可以是URI Template 模式  </p>
<p>method:指定请求的method类型， GET、POST、PUT、DELETE等  </p>
<p>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;  </p>
<p>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。</p>
<p>@GetMapping、@PostMapping等:</p>
<p>相当于@RequestMapping（value=”/”，method=RequestMethod.Get\Post\Put\Delete等） 。是个组合注解；</p>
<ul>
<li>@RequestParam:</li>
</ul>
<p>用在方法的参数前面。相当于 request.getParameter()；</p>
<ul>
<li>@PathVariable:</li>
</ul>
<p>路径变量。如 RequestMapping(“user/get/mac/{macAddress}”) ；</p>
<p>public String getByMacAddress(<br>@PathVariable(“macAddress”) String macAddress){<br>//do something;<br>}</p>
<p>参数与大括号里的名字相同的话，注解后括号里的内容可以不填。</p>
<h2><span id="2jpa">2.Jpa</span></h2><ul>
<li>@Entity @Table(name=”“):</li>
</ul>
<p>表明这是一个实体类。一般用于jpa ，这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略；</p>
<ul>
<li>@MappedSuperClass:</li>
</ul>
<p>用在确定是父类的entity上。父类的属性子类可以继承；</p>
<ul>
<li>@NoRepositoryBean:</li>
</ul>
<p>一般用作父类的repository，有这个注解，spring不会去实例化该repository；</p>
<ul>
<li>@Column: </li>
</ul>
<p>如果字段名与列名相同，则可以省略；</p>
<ul>
<li>@Id:</li>
</ul>
<p>表示该属性为主键；</p>
<ul>
<li>@GeneratedValue(strategy=GenerationType.SEQUENCE,generator = “repair_seq”):</li>
</ul>
<p>表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq；</p>
<ul>
<li>@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1):</li>
</ul>
<p>name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致；</p>
<ul>
<li>@Transient:</li>
</ul>
<p>表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性. </p>
<p>如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic；</p>
<ul>
<li>@Basic(fetch=FetchType.LAZY):</li>
</ul>
<p>标记可以指定实体属性的加载方式；</p>
<ul>
<li>@JsonIgnore:</li>
</ul>
<p>作用是json序列化时将java bean中的一些属性忽略掉,序列化和反序列化都受影响；</p>
<ul>
<li>@JoinColumn(name=”loginId”):</li>
</ul>
<p>一对一：本表中指向另一个表的外键。</p>
<p>一对多：另一个表指向本表的外键。</p>
<ul>
<li><p>@OneToOne</p>
</li>
<li><p>@OneToMany</p>
</li>
<li><p>@ManyToOne:</p>
</li>
</ul>
<p>对应Hibernate配置文件中的一对一，一对多，多对一。</p>
<h2><span id="3全局异常处理">3.全局异常处理</span></h2><ul>
<li>@ControllerAdvice:</li>
</ul>
<p>包含@Component。可以被扫描到。统一处理异常；</p>
<ul>
<li>@ExceptionHandler(Exception.class):</li>
</ul>
<p>用在方法上面表示遇到这个异常就执行以下方法。</p>
<h2><span id="4springcloud">4.springcloud</span></h2><ul>
<li>@EnableEurekaServer:</li>
</ul>
<p>用在springboot启动类上，表示这是一个eureka服务注册中心；</p>
<ul>
<li>@EnableDiscoveryClient:</li>
</ul>
<p>用在springboot启动类上，表示这是一个服务，可以被注册中心找到；</p>
<ul>
<li>@LoadBalanced:</li>
</ul>
<p>开启负载均衡能力；</p>
<ul>
<li>@EnableCircuitBreaker:</li>
</ul>
<p>用在启动类上，开启断路器功能；</p>
<ul>
<li>@HystrixCommand(fallbackMethod=”backMethod”):</li>
</ul>
<p>用在方法上，fallbackMethod指定断路回调方法；</p>
<ul>
<li>@EnableConfigServer:</li>
</ul>
<p>用在启动类上，表示这是一个配置中心，开启Config Server；</p>
<ul>
<li>@EnableZuulProxy:</li>
</ul>
<p>开启zuul路由，用在启动类上；</p>
<ul>
<li>@SpringCloudApplication:</li>
</ul>
<blockquote>
<p>包含@SpringBootApplication @EnableDiscovertyClient @EnableCircuitBreaker</p>
</blockquote>
<p>分别是SpringBoot注解、注册服务中心Eureka注解、断路器注解。对于SpringCloud来说，这是每一微服务必须应有的三个注解，所以才推出了@SpringCloudApplication这一注解集合。</p>
</div></div></div></main><footer class="footer-container"><div class="paginator"><a class="prev" href="/2022/01/10/java/2022/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/">上一篇</a><a class="next" href="/2022/01/09/java/2022/java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/">下一篇</a></div><div class="copyright"><p>© 2015 - 2023 <a href="https://mirsery.github.io">mirsery</a> </p><p>powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and  <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a></p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"mirsery",'auto');ga('send','pageview');</script></body></html>
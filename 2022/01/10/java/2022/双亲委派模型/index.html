<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 双亲委派模型 · mirsery</title><meta name="description" content="双亲委派模型 - mirsery"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="stylesheet" href="/css/dracula.css"><link rel="search" type="application/opensearchdescription+xml" href="https://mirsery.github.io/atom.xml" title="mirsery"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="mirsery" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">mirsery</h2></a></div><a class="li component-nav-item" href="/" target="_self"><p>首页</p></a><a class="li component-nav-item" href="/archives" target="_self"><p>归档</p></a><a class="li component-nav-item" href="/categories" target="_self"><p>分类</p></a><a class="li component-nav-item" href="/tags" target="_self"><p>标签</p></a><ul class="shortcut-icons"><a href="https://github.com/mirsery" target="_blank"><img class="icon" src="/images/github.svg"></a><a href="/atom.xml" target="_blank"><img class="icon" src="/images/rss.svg"></a><a href="https://www.zhihu.com/people/mirsery" target="_blank"><img class="icon" src="/images/zhihu.svg"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post article post-block"><h1 class="post-title">双亲委派模型</h1><div class="post-info">作者: mirsery         创建日期: 2022年1月10日</div><div class="post-content"><!-- toc -->

<ul>
<li><a href="#----">背景知识</a></li>
<li><a href="#------">双亲委派模型</a></li>
<li><a href="#--------">破坏双亲委派模型</a></li>
</ul>
<!-- tocstop -->

<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>详细见<a href="../2019/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">类加载器</a> 章节</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的委派机制约定了类加载器的加载机制。按照双亲委派模型的规则，除了启动加载器之外，程序中每一个类加载器都应该有一个超类加载器，比如AppClassLoader的超类加载器就是ExtClassLoader，开发者编写的自定义类加载器的超类就是AppClassLoader.<br>那么当一个类加载器接收到一个类加载任务的时候，它并不会立即展开加载，而是将加载的任务委派给他的超类加载器去执行，每一层的类加载器都采用相同的方式，直至派给最顶层的启动类加载器为止。如果超类加载器无法加载委派给他的类时，便会将类的加载任务退回给他的下一级类加载器去执行加载。<br>使用双亲委派模型的优点就是能够有效地确保一个类的全局唯一性，当程序中出现多个全限定名相同的类时，类加载器在执行加载的时候，始终只会加载其中某一个类，如果通过defindClas()方法进行显示加载则JVM会抛出异常。</p>
<p>以下是JDK 中双亲委派的实现</p>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment">     * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.  The</span>
<span class="comment">     * default implementation of this method searches for classes in the</span>
<span class="comment">     * following order:</span>
<span class="comment">     *</span>
<span class="comment">     * &lt;ol&gt;</span>
<span class="comment">     *</span>
<span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke &#123;<span class="doctag">@link</span> #findLoadedClass(String)&#125; to check if the class</span>
<span class="comment">     *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span>
<span class="comment">     *</span>
<span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #loadClass(String) loadClass&#125; method</span>
<span class="comment">     *   on the parent class loader.  If the parent is &#123;<span class="doctag">@code</span> null&#125; the class</span>
<span class="comment">     *   loader built into the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span>
<span class="comment">     *</span>
<span class="comment">     *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #findClass(String)&#125; method to find the</span>
<span class="comment">     *   class.  &lt;/p&gt;&lt;/li&gt;</span>
<span class="comment">     *</span>
<span class="comment">     * &lt;/ol&gt;</span>
<span class="comment">     *</span>
<span class="comment">     * &lt;p&gt; If the class was found using the above steps, and the</span>
<span class="comment">     * &#123;<span class="doctag">@code</span> resolve&#125; flag is true, this method will then invoke the &#123;<span class="doctag">@link</span></span>
<span class="comment">     * #resolveClass(Class)&#125; method on the resulting &#123;<span class="doctag">@code</span> Class&#125; object.</span>
<span class="comment">     *</span>
<span class="comment">     * &lt;p&gt; Subclasses of &#123;<span class="doctag">@code</span> ClassLoader&#125; are encouraged to override &#123;<span class="doctag">@link</span></span>
<span class="comment">     * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span>
<span class="comment">     *</span>
<span class="comment">     * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span>
<span class="comment">     * &#123;<span class="doctag">@link</span> #getClassLoadingLock getClassLoadingLock&#125; method</span>
<span class="comment">     * during the entire class loading process.</span>
<span class="comment">     *</span>
<span class="comment">     * <span class="doctag">@param</span>   name</span>
<span class="comment">     *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
<span class="comment">     *</span>
<span class="comment">     * <span class="doctag">@param</span>   resolve</span>
<span class="comment">     *          If &#123;<span class="doctag">@code</span> true&#125; then resolve the class</span>
<span class="comment">     *</span>
<span class="comment">     * <span class="doctag">@return</span>  The resulting &#123;<span class="doctag">@code</span> Class&#125; object</span>
<span class="comment">     *</span>
<span class="comment">     * <span class="doctag">@throws</span>  ClassNotFoundException</span>
<span class="comment">     *          If the class could not be found</span>
<span class="comment">*/</span>
<span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)
        <span class="keyword">throws</span> ClassNotFoundException
    &#123;
        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;
            <span class="comment">// First, check if the class has already been loaded</span>
            Class&lt;?&gt; c = findLoadedClass(name);
            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;
                <span class="keyword">long</span> t0 = System.nanoTime();
                <span class="keyword">try</span> &#123;
                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;
                        c = parent.loadClass(name, <span class="keyword">false</span>);
                    &#125; <span class="keyword">else</span> &#123;
                        c = findBootstrapClassOrNull(name);
                    &#125;
                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;
                    <span class="comment">// ClassNotFoundException thrown if class not found</span>
                    <span class="comment">// from the non-null parent class loader</span>
                &#125;

                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;
                    <span class="comment">// If still not found, then invoke findClass in order</span>
                    <span class="comment">// to find the class.</span>
                    <span class="keyword">long</span> t1 = System.nanoTime();
                    c = findClass(name);

                    <span class="comment">// this is the defining class loader; record the stats</span>
                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    PerfCounter.getFindClasses().increment();
                &#125;
            &#125;
            <span class="keyword">if</span> (resolve) &#123;
                resolveClass(c);
            &#125;
            <span class="keyword">return</span> c;
        &#125;
    &#125;</code></pre>

<p>在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派机制有一定的区别，当缺省的类加载器接收到到一个类的加载任务时，他首先会自行加载，当它加载失败时，才会将类的加载任务委派给他的超类加载器去执行，这也是servlet规范推荐的一种做法。</p>
<h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>JDk种破坏双亲委派模型</p>
<ul>
<li><p>JDK1.0<br>java.lang.ClassLoader 提供了loadClass() 方法，继承ClassLoader类，重写loadClass()方法</p>
</li>
<li><p>SPI<br>一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，<br>它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。</p>
</li>
</ul>
<p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。<br>这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<br>有了线程上下文加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。</p>
<p>Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p>
<ul>
<li><p>OSGi<br>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。<br>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。<br>在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。<br>当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：<br>1）将java.＊开头的类委派给父类加载器加载。<br>2）否则，将委派列表名单内的类委派给父类加载器加载。<br>3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。<br>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。<br>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。<br>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。<br>7）否则，类加载器失败</p>
</li>
<li><p>JKD9模块系统<br>模块化加载源码片段</p>
<pre><code class="highlight java">Class&lt;?&gt; c = findLoadedClass(cn);
      <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;
         <span class="comment">// 找到当前类属于哪个模块</span>
         LoadedModule loadedModule = findLoadedModule(cn);
         <span class="keyword">if</span> (loadedModule != <span class="keyword">null</span>) &#123;
            <span class="comment">//获取当前模块的类加载器</span>
            BuiltinClassLoader loader = loadedModule.loader();
            <span class="comment">//进行类加载</span>
            c = findClassInModuleOrNull(loadedModule, cn);
         &#125; <span class="keyword">else</span> &#123;
            <span class="comment">// 找不到模块信息才会进行双亲委派</span>
         <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;
           c = parent.loadClassOrNull(cn);
         &#125;
       &#125;</code></pre></li>
</ul>
<p>整个JDK都基于模块化进行构建，以前的rt.jar, tool.jar被拆分成数十个模块，编译的时候只编译实际用到的模块，同时各个类加载器各司其职，只加载自己负责的模块。</p>
<p>经过破坏后的双亲委派模型更加高效，减少了很多类加载器之间不必要的委派操作<br>JDK9的模块化可以减少Java程序打包的体积，同时拥有更好的隔离线与封装性<br>每个moudle拥有专属的类加载器，程序在并发性上也会更加出色。</p>
</div></div></div></main><footer class="footer-container"><div class="paginator"><a class="next" href="/2022/01/09/java/2022/springBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://mirsery.github.io">mirsery</a> </p><p>powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and  <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a></p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"mirsery",'auto');ga('send','pageview');</script></body></html>
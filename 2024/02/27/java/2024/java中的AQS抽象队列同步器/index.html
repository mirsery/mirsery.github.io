<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> java中的AQS抽象队列同步器 · mirsery</title><meta name="description" content="java中的AQS抽象队列同步器 - mirsery"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="stylesheet" href="/css/dracula.css"><link rel="search" type="application/opensearchdescription+xml" href="https://mirsery.github.io/atom.xml" title="mirsery"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="mirsery" type="application/atom+xml">
<!-- hexo-inject:begin --><script src='https://unpkg.com/echarts@3.3.2/dist/echarts.min.js'></script><!-- hexo-inject:end --></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">mirsery</h2></a></div><a class="li component-nav-item" href="/" target="_self"><p>首页</p></a><a class="li component-nav-item" href="/archives" target="_self"><p>归档</p></a><a class="li component-nav-item" href="/categories" target="_self"><p>分类</p></a><a class="li component-nav-item" href="/tags" target="_self"><p>标签</p></a><ul class="shortcut-icons"><a href="https://github.com/mirsery" target="_blank"><img class="icon" src="/images/github.svg"></a><a href="/atom.xml" target="_blank"><img class="icon" src="/images/rss.svg"></a><a href="https://www.zhihu.com/people/mirsery" target="_blank"><img class="icon" src="/images/zhihu.svg"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post article post-block"><h1 class="post-title">java中的AQS抽象队列同步器</h1><div class="post-info">作者: mirsery         创建日期: 2024年2月27日</div><div class="post-content"><!-- toc -->

<!-- hexo-inject:begin --><!-- hexo-inject:end --><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFaqs">什么是AQS</a></li>
<li><a href="#abstractqueuedsynchronizer%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90">AbstractQueuedSynchronizer方法解析</a></li>
<li><a href="#%E8%87%AA%E6%97%8B%E5%92%8C%E9%98%BB%E5%A1%9E">自旋和阻塞</a></li>
<li><a href="#reentrantlocksemaphore%E4%BB%A5%E5%8F%8Acountdownlatch%E5%AF%B9%E6%AF%94">ReentrantLock，Semaphore以及CountDownLatch对比</a></li>
<li><a href="#reentrantlock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">ReentrantLock实现原理</a></li>
<li><a href="#semaphore%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">Semaphore实现原理</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97-aqs-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E7%8B%AC%E5%8D%A0%E9%94%81">使用抽象同步队列 AQS 构建一个不可重入的独占锁</a></li>
</ul>
<!-- tocstop -->

<h2><span id="什么是aqs">什么是AQS</span></h2><p>AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面。</p>
<p>AbstractQueuedSynchronizer抽象队列同步器——用于构建锁或其他同步组件的基础框架，子类通过继承AQS并实现它的抽象方法来实现锁</p>
<p>AQS支持两种模式——独占模式，共享模式。</p>
<p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了， ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式 连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队 列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。<br>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可 以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p>
<h2><span id="abstractqueuedsynchronizer方法解析">AbstractQueuedSynchronizer方法解析</span></h2><p>AbstractQueuedSynchronizer（AQS）是Java并发编程中的一个基础框架，它提供了一种实现同步器的通用方法。AQS内部维护了一个同步队列，通过“自旋”和“阻塞”两种方式来实现同步操作。</p>
<p>AQS提供了一些核心方法，其含义和作用如下：</p>
<p>acquire(int arg): 尝试获取同步状态，如果获取失败则加入同步队列并阻塞等待唤醒，直到获取同步状态成功。参数arg表示获取同步状态所需的资源数量。</p>
<p>tryAcquire(int arg): 尝试获取同步状态，如果获取成功则返回true，否则返回false。参数arg表示获取同步状态所需的资源数量。</p>
<p>release(int arg): 释放同步状态，通知其他线程可以尝试获取同步状态。参数arg表示释放的资源数量。</p>
<p>tryRelease(int arg): 尝试释放同步状态，如果释放成功则返回true，否则返回false。参数arg表示释放的资源数量。</p>
<p>acquireInterruptibly(int arg): 尝试获取同步状态，如果获取失败则加入同步队列并阻塞等待唤醒，直到获取同步状态成功或者被中断。参数arg表示获取同步状态所需的资源数量。</p>
<p>acquireShared(int arg): 尝试获取共享同步状态，如果获取失败则加入同步队列并阻塞等待唤醒，直到获取共享同步状态成功。参数arg表示获取共享同步状态所需的资源数量。</p>
<p>tryAcquireShared(int arg): 尝试获取共享同步状态，如果获取成功则返回非负数，否则返回负数。返回值表示当前线程获取到的共享资源数量。参数arg表示获取共享同步状态所需的资源数量。</p>
<p>releaseShared(int arg): 释放共享同步状态，通知其他线程可以尝试获取共享同步状态。参数arg表示释放的资源数量。</p>
<p>tryAcquireNanos(int arg, long nanosTimeout): 在规定时间内尝试获取同步状态，如果获取失败则加入同步队列并阻塞等待唤醒，直到获取同步状态成功或者超时。参数arg表示获取同步状态所需的资源数量，参数nanosTimeout表示等待超时时间。</p>
<p>AQS提供了一些核心方法来实现同步操作，可以用于实现不同类型的同步器，如ReentrantLock、Semaphore、CountDownLatch等。这些方法可以满足不同的并发编程需求，需要根据具体的场景选择合适的同步方式和同步策略。</p>
<h2><span id="自旋和阻塞">自旋和阻塞</span></h2><p>自旋和阻塞是Java并发编程中两种不同的线程等待方式。</p>
<p>自旋是指线程在等待某个条件满足时，不断地循环检查条件是否满足，如果不满足就一直循环等待，直到条件满足。自旋的好处是可以减少线程上下文切换的开销，因为线程一直处于执行状态，不需要进行线程状态的切换。但是自旋需要占用CPU资源，如果自旋时间过长会导致CPU资源浪费，降低系统性能。</p>
<p>阻塞是指线程在等待某个条件满足时，将自己挂起，不再占用CPU资源，直到条件满足时再被唤醒继续执行。阻塞的好处是可以释放CPU资源，避免浪费，但是阻塞需要进行线程状态的切换，如果线程频繁地阻塞和唤醒会增加系统开销。</p>
<p>在Java中，阻塞通常是通过调用wait()方法或者阻塞式IO来实现的，而自旋通常是在锁等待时实现的。例如，在ReentrantLock中，当线程尝试获取锁失败时，它会在同步队列中自旋等待锁的释放，直到锁被释放或者等待时间超过一定阈值才会阻塞等待。因此，在选择线程等待方式时需要根据具体的场景和需求进行权衡和选择。</p>
<h2><span id="reentrantlocksemaphore以及countdownlatch对比">ReentrantLock，Semaphore以及CountDownLatch对比</span></h2><p>ReentrantLock、Semaphore和CountDownLatch都是Java并发编程中常用的同步工具类，它们都使用了AQS的实现方式。<br>ReentrantLock（可重入锁）：是一种独占锁，它允许一个线程多次获取锁，支持公平锁和非公平锁。与synchronized关键字相比，ReentrantLock提供了更多的灵活性和功能，如可中断锁、限时锁、公平锁等。<br>Semaphore（信号量）：是一种共享锁，它用于控制对资源的访问数量。Semaphore维护了一个计数器，当有线程获取信号量时，计数器减1，当计数器为0时，其他线程需要等待。Semaphore可以用于实现限流、资源池等功能。<br>CountDownLatch（倒计时器）：是一种同步工具类，它可以让一个或多个线程等待其他线程执行完毕后再继续执行。CountDownLatch维护了一个计数器，当计数器为0时，等待的线程可以继续执行。它可以用于协调多个线程的执行顺序。</p>
<h2><span id="reentrantlock实现原理">ReentrantLock实现原理</span></h2><p>获取锁：当一个线程请求获取锁时，ReentrantLock会首先尝试获取锁，如果锁未被占用，则该线程可以立即获取锁；否则，该线程将被加入到同步队列中等待获取锁。<br>可重入性：如果当前线程已经持有锁，那么它可以重复获取该锁，而不需要重新等待。为了实现可重入性，ReentrantLock需要维护一个记录锁持有者的ThreadLocal变量，以及一个记录锁持有次数的计数器。<br>公平性和非公平性：ReentrantLock支持公平锁和非公平锁。公平锁是指多个线程获取锁的顺序与它们加入同步队列的顺序相同；非公平锁则不保证获取锁的顺序与加入队列的顺序相同。在公平锁模式下，线程获取锁的顺序是有序的，但是会降低并发性能；在非公平锁模式下，线程获取锁的顺序是不确定的，但是可以提高并发性能。<br>释放锁：当一个线程释放锁时，ReentrantLock会将state变量置为0，以表示该锁已经被释放。同时，它会从同步队列中选择一个等待的线程唤醒，使其重新尝试获取锁。如果当前线程还持有该锁，那么需要将计数器减1，直到计数器为0才能完全释放锁。<br>ReentrantLock源码中compareAndSetState的方法</p>
<p>在ReentrantLock的源码中，比较并交换（CompareAndSet）状态值是实现锁的核心部分之一。在ReentrantLock中，状态值的改变可以表示锁的获取和释放，因此状态值的比较并交换是实现锁的关键。</p>
<p>在ReentrantLock中，状态值是由AQS（AbstractQueuedSynchronizer）的内部类Node中的state字段表示的。具体来说，当线程获取锁时，它会创建一个Node节点并尝试将状态值从0（表示锁未被占用）改变为1（表示锁已被占用）。当线程释放锁时，它会将状态值从1改变为0，表示锁已被释放。</p>
<p>在AQS中，compareAndSetState(int expect, int update)方法用于比较并交换状态值。具体来说，该方法会比较当前状态值是否等于expect，如果是则将状态值修改为update，否则不进行修改。这个方法是原子的，可以保证状态值的改变是线程安全的。在ReentrantLock中，使用compareAndSetState方法实现锁的获取和释放，比如在获取锁时将状态值从0修改为1，在释放锁时将状态值从1修改为0。</p>
<p>下面是ReentrantLock源码中compareAndSetState方法的具体实现：</p>
<pre><code class="highlight java"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;
    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);
&#125;</code></pre>
<p>该方法调用了unsafe类的compareAndSwapInt方法，该方法是一个本地方法，用于实现原子的比较并交换操作。其中，this表示当前对象，stateOffset表示state字段在对象中的偏移量，expect表示期望的状态值，update表示要修改的状态值。如果当前状态值等于expect，则将状态值修改为update并返回true，否则返回false。<br>总之，ReentrantLock中的compareAndSetState方法实现了状态值的原子性修改，是实现锁的关键部分之一。</p>
<h2><span id="semaphore实现原理">Semaphore实现原理</span></h2><p>Semaphore是一个计数信号量，它可以用于控制同时访问某个资源的线程数量。Semaphore内部维护了一个计数器，表示可以访问资源的线程数量，线程在访问资源时需要先获取Semaphore的许可，当计数器的值大于0时，线程可以获取许可并访问资源，计数器的值减一；当计数器的值为0时，线程需要等待其他线程释放许可才能获取许可并访问资源。</p>
<p>Semaphore的实现原理主要是基于AQS（AbstractQueuedSynchronizer）类，Semaphore通过AQS实现了许可的获取和释放，并且保证了线程之间的互斥和同步。</p>
<p>Semaphore的实现可以分为两个部分：获取许可和释放许可。</p>
<ul>
<li><p>获取许可<br>Semaphore的acquire方法用于获取许可，如果当前有可用的许可则获取成功，如果没有则线程会被阻塞等待。acquire方法的具体实现如下：</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;
    sync.acquireSharedInterruptibly(<span class="number">1</span>);
&#125;</code></pre>
<p>acquire方法内部调用了AQS的acquireSharedInterruptibly方法，该方法实现了阻塞等待。如果当前计数器的值大于0，线程可以获取许可并将计数器的值减一，如果计数器的值为0，则线程会被阻塞等待其他线程释放许可。在AQS中，线程的阻塞等待是通过将线程添加到同步队列中实现的。</p>
</li>
<li><p>释放许可<br>Semaphore的release方法用于释放许可，如果当前没有线程等待许可则将许可的数量加一，如果有线程等待许可则唤醒一个等待线程并将许可的数量加一。release方法的具体实现如下：</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;
    sync.releaseShared(<span class="number">1</span>);
&#125;</code></pre>
<p>release方法内部调用了AQS的releaseShared方法，该方法实现了许可的释放和等待线程的唤醒。如果当前有等待线程，则会从同步队列中唤醒一个线程，让其获取许可并执行；如果当前没有等待线程，则将许可的数量加一。</p>
</li>
</ul>
<p>Semaphore是基于AQS实现的一个计数信号量，通过计数器实现了对许可的控制，并通过同步队列实现了线程之间的同步和互斥。Semaphore的实现为线程的访问资源提供了一个简单而可靠的机制。</p>
<h2><span id="使用抽象同步队列-aqs-构建一个不可重入的独占锁">使用抽象同步队列 AQS 构建一个不可重入的独占锁</span></h2><pre><code class="highlight java:n">
public class UnReentrantLock implements Lock &#123;

    private static class Sync extends AbstractQueuedSynchronizer&#123;

        @Override
        protected boolean isHeldExclusively() &#123;
           return getState() == 1;
        &#125;

        @Override
        protected boolean tryRelease(int arg) &#123;
            if(getState()==0)&#123;
                throw new IllegalMonitorStateException();
            &#125;else &#123;
                setState(0);
                setExclusiveOwnerThread(null);
                return true;
            &#125;
        &#125;

        @Override
        protected boolean tryAcquire(int arg) &#123;
            assert arg == 1;
            if(compareAndSetState(0,1))&#123;
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            &#125;
            return false;
        &#125;

        public ConditionObject newCondition()&#123;
            return new ConditionObject();
        &#125;


    &#125;

    private final Sync sync = new Sync();

    @Override
    public void lock() &#123;
        sync.acquire(1);
    &#125;

    @Override
    public void lockInterruptibly() throws InterruptedException &#123;
        sync.acquireInterruptibly(1);
    &#125;

    @Override
    public boolean tryLock() &#123;
        return sync.tryAcquire(1);
    &#125;

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;
        return sync.tryAcquireNanos(1,unit.toNanos(time));
    &#125;

    @Override
    public void unlock() &#123;
        sync.release(1);
    &#125;

    @Override
    public Condition newCondition() &#123;
        return sync.newCondition();
    &#125;

    public boolean isLocked()&#123;
        return sync.isHeldExclusively();
    &#125;
&#125;</code></pre>

<p>利用自定义的锁实现一个消费者和生产者线程</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUnReentrantLock</span> &#123;

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">UnReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnReentrantLock</span>();

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">prodCondition</span> <span class="operator">=</span> lock.newCondition(); <span class="comment">// 信号</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">customCondition</span> <span class="operator">=</span> lock.newCondition();

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Queue&lt;String&gt; taskQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">limitSize</span> <span class="operator">=</span> <span class="number">10</span>;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;

        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;
            lock.lock();
            <span class="keyword">try</span> &#123;
                <span class="keyword">while</span>(taskQueue.size() &gt;= limitSize) &#123;
                    prodCondition.await();
                &#125;
                taskQueue.add(<span class="string">&quot;Hello&quot;</span>);
                System.out.println(<span class="string">&quot;prod &quot;</span>+ <span class="string">&quot;Hello&quot;</span>);
                customCondition.signalAll();
            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125; <span class="keyword">finally</span> &#123;
                lock.unlock();
            &#125;
        &#125;);

        <span class="type">Thread</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;
            lock.lock();
            <span class="keyword">try</span>&#123;
                <span class="keyword">while</span>(taskQueue.isEmpty())&#123;
                    customCondition.await();
                &#125;
                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> taskQueue.poll();
                System.out.println(<span class="string">&quot;customer &quot;</span>+ msg);
                prodCondition.signalAll();
            &#125;<span class="keyword">catch</span> (Exception e)&#123;
                e.printStackTrace();
            &#125;<span class="keyword">finally</span> &#123;
                lock.unlock();
            &#125;

        &#125;);

        producer.start();
        customer.start();
    &#125;
&#125;
</code></pre></div></div></div></main><footer class="footer-container"><div class="paginator"><a class="prev" href="/2024/06/13/java/2024/Java-SPI-%E6%9C%BA%E5%88%B6/">上一篇</a><a class="next" href="/2024/02/27/java/2024/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0/">下一篇</a></div><div class="copyright"><p>© 2015 - 2024 <a href="https://mirsery.github.io">mirsery</a> </p><p>powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and  <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a></p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"mirsery",'auto');ga('send','pageview');</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7201423389984397" crossorigin="anonymous"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>
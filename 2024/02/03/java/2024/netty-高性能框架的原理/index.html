<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> netty 高性能框架的原理 · mirsery</title><meta name="description" content="netty 高性能框架的原理 - mirsery"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="stylesheet" href="/css/dracula.css"><link rel="search" type="application/opensearchdescription+xml" href="https://mirsery.github.io/atom.xml" title="mirsery"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="mirsery" type="application/atom+xml">
<!-- hexo-inject:begin --><script src='https://unpkg.com/echarts@3.3.2/dist/echarts.min.js'></script><!-- hexo-inject:end --></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">mirsery</h2></a></div><a class="li component-nav-item" href="/" target="_self"><p>首页</p></a><a class="li component-nav-item" href="/archives" target="_self"><p>归档</p></a><a class="li component-nav-item" href="/categories" target="_self"><p>分类</p></a><a class="li component-nav-item" href="/tags" target="_self"><p>标签</p></a><ul class="shortcut-icons"><a href="https://github.com/mirsery" target="_blank"><img class="icon" src="/images/github.svg"></a><a href="/atom.xml" target="_blank"><img class="icon" src="/images/rss.svg"></a><a href="https://www.zhihu.com/people/mirsery" target="_blank"><img class="icon" src="/images/zhihu.svg"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post article post-block"><h1 class="post-title">netty 高性能框架的原理</h1><div class="post-info">作者: mirsery         创建日期: 2024年2月3日</div><div class="post-content"><!-- toc -->

<!-- hexo-inject:begin --><!-- hexo-inject:end --><ul>
<li><a href="#netty-%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E5%9B%A0">netty 高性能原因</a><ul>
<li><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a></li>
<li><a href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF-io">异步通讯 IO</a></li>
<li><a href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF">零拷贝技术</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E6%B1%A0%E6%8A%80%E6%9C%AF">内存池技术</a></li>
<li><a href="#%E9%AB%98%E6%95%88%E7%9A%84-reactor-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">高效的 Reactor 线程模型</a></li>
<li><a href="#reactor-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">Reactor 单线程模型</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="netty-高性能原因">netty 高性能原因</span></h2><h3><span id="多路复用">多路复用</span></h3><p>Netty 的 IO 线程 NioEventLoop 由于聚合了多路复用器 Selector、epoll，可以同时并发处理成百上千个客户端 Channel。<br>由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 IO 阻塞导致的线程挂起。</p>
<h3><span id="异步通讯-io">异步通讯 IO</span></h3><p>Netty 采用了异步通信模式，一个IO 线程可以并发处理N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p>
<h3><span id="零拷贝技术">零拷贝技术</span></h3><p>netty 接收和发送 Bytebuffer 采用堆外直接内存进行 socket 读写。<br>传统网络传输情况下，网卡首先接收到数据，并将数据拷贝至操作系统的缓冲区，此时内核态切换至用户态，应用程序读取内核缓冲区的数据，用户态切换成内核态，cpu 将数据拷贝至用户缓存空间中，这样用户程序就可以操作这些数据。用户处理完数据之后，向用户缓冲区中发送数据并刷新缓存。此时用户态转换成内核态，cpu 将数据拷贝至操作内核 socket缓冲区，利用 DMA技术将数据拷贝至网卡然后发送出去。<br>netty 框架使用Bytebuf 来接收处理这些数据，netty 读取数据的时候采用内存映射 <strong>mmap 技术</strong>，此时用户态可以直接访问内核缓冲区的数据并不需要 cpu 进行拷贝，减少了一次上下文切换以及数据的拷贝。<br>当 netty 发送数据时，采用 Bytebuf，利用底层的 sendfile 方法（linux2.1 之后提供的方法，java 中对应的是FileChannel.transferTo方法）文件映射的技术直接访问向内核缓冲区发送数据，减少一次上下文切换以及 cpu 的拷贝。采用零拷贝技术减少了 2 次上下文切换以及避免了数据发送过程中 cpu 参与的数据拷贝降低的 cpu 的负载使得系统性能得以提升。</p>
<h3><span id="内存池技术">内存池技术</span></h3><p>随着 JVM 虚拟机和 JIT 即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区 Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。</p>
<h3><span id="高效的-reactor-线程模型">高效的 Reactor 线程模型</span></h3><p>常用的 Reactor 线程模型有三种，Reactor 单线程模型, Reactor 多线程模型, 主从 Reactor 多线程模型。</p>
<h3><span id="reactor-单线程模型">Reactor 单线程模型</span></h3><p>Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程的职责如下：</p>
<ol>
<li><p>作为 NIO 服务端，接收客户端的 TCP 连接；</p>
</li>
<li><p>作为 NIO 客户端，向服务端发起 TCP 连接；</p>
</li>
<li><p>读取通信对端的请求或者应答消息</p>
</li>
<li><p>向通信对端发送消息请求或者应答消息。</p>
</li>
</ol>
<p>由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独立处理所有 IO 相关的操作。从架构层面看，一个 NIO 线程确实可以完成其承担的职责。例如，通过Acceptor 接收客户端的 TCP 连接请求消息，链路建立成功之后，通过 Dispatch 将对应的 ByteBuffer 派发到指定的 Handler 上进行消息解码。用户 Handler 可以通过 NIO 线程将消息发送给客户端。</p>
</div></div></div></main><footer class="footer-container"><div class="paginator"><a class="prev" href="/2024/02/27/java/2024/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0/">上一篇</a><a class="next" href="/2024/01/30/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/">下一篇</a></div><div class="copyright"><p>© 2015 - 2024 <a href="https://mirsery.github.io">mirsery</a> </p><p>powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and  <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a></p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"mirsery",'auto');ga('send','pageview');</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7201423389984397" crossorigin="anonymous"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>
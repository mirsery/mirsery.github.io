<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> netty重链接 · mirsery</title><meta name="description" content="netty重链接 - mirsery"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="stylesheet" href="/css/dracula.css"><link rel="search" type="application/opensearchdescription+xml" href="https://mirsery.github.io/atom.xml" title="mirsery"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="mirsery" type="application/atom+xml">
<!-- hexo-inject:begin --><script src='https://unpkg.com/echarts@3.3.2/dist/echarts.min.js'></script><!-- hexo-inject:end --></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">mirsery</h2></a></div><a class="li component-nav-item" href="/" target="_self"><p>首页</p></a><a class="li component-nav-item" href="/archives" target="_self"><p>归档</p></a><a class="li component-nav-item" href="/categories" target="_self"><p>分类</p></a><a class="li component-nav-item" href="/tags" target="_self"><p>标签</p></a><ul class="shortcut-icons"><a href="https://github.com/mirsery" target="_blank"><img class="icon" src="/images/github.svg"></a><a href="/atom.xml" target="_blank"><img class="icon" src="/images/rss.svg"></a><a href="https://www.zhihu.com/people/mirsery" target="_blank"><img class="icon" src="/images/zhihu.svg"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post article post-block"><h1 class="post-title">netty重链接</h1><div class="post-info">作者: mirsery         创建日期: 2018年7月9日</div><div class="post-content"><p>在socket客户端编程中涉及到最多的就是长连接的问题。在netty框架中客户端和服务器之间的连接断开的话会触发channel的inactive方法，此时我们可以在inactive方法中实现客户端的断线重连机制。<br>    下面是示例代码</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><pre><code class="highlight java"><span class="keyword">public</span> Bootstrap <span class="title function_">createBootStrap</span><span class="params">(<span class="keyword">final</span> Bootstrap bootstrap, <span class="keyword">final</span> EventLoopGroup eventLoop)</span> &#123;
       <span class="keyword">if</span>(bootstrap != <span class="literal">null</span>)&#123;
           bootstrap.group(eventLoop).channel(NioSocketChannel.class).handler(janusChannelInitializer);


           <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(configuration.getServerIP(), configuration.getPort()));

           future.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;
               <span class="meta">@Override</span>
               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception &#123;
                   <span class="keyword">if</span> (future.isSuccess()) &#123;
                       log.info(<span class="string">&quot;janusClient connect to server &quot;</span>+ configuration.getServerIP()+<span class="string">&quot; at port: &#123;&#125;&quot;</span>, configuration.getPort());
                   &#125; <span class="keyword">else</span> &#123;
                       log.error(<span class="string">&quot;janusClient can&#x27;t connect to server &quot;</span>+configuration.getServerIP()+<span class="string">&quot; at port: &#123;&#125;!&quot;</span>, configuration.getPort());
                       eventLoop.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;
                           <span class="meta">@Override</span>
                           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;
                               createBootStrap(<span class="keyword">new</span> <span class="title class_">Bootstrap</span>(),eventLoop);
                               log.info(<span class="string">&quot;reconnect jsonClient.....&quot;</span>);
                           &#125;
                       &#125;,<span class="number">30L</span>, TimeUnit.SECONDS);
                   &#125;
               &#125;
           &#125;);
           future.syncUninterruptibly();
       &#125;
       <span class="keyword">return</span> bootstrap;
   &#125;</code></pre>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment">    * Once channel is inactive</span>
<span class="comment">    */</span>
   <span class="meta">@Override</span>
   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;
       log.info(<span class="string">&quot;enter inactive function . . .&quot;</span>);
       <span class="keyword">final</span> <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> ctx.channel().eventLoop();
       eventLoop.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;
           <span class="meta">@Override</span>
           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;
               JsonClient.getJsonClent().createBootStrap(<span class="keyword">new</span> <span class="title class_">Bootstrap</span>(),eventLoop);
               log.info(<span class="string">&quot;reconnect .....&quot;</span>);
           &#125;
       &#125;,<span class="number">10L</span>, TimeUnit.SECONDS);
       <span class="built_in">super</span>.channelInactive(ctx);
   &#125;</code></pre></div></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'mirsery';
var disqus_identifier = '2018/07/08/java/2018/Netty的重连机制/';
var disqus_title = 'netty重链接';
var disqus_url = 'https://mirsery.github.io/2018/07/08/java/2018/Netty的重连机制/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a class="prev" href="/2018/07/08/java/2018/ByteBuffer%20%E8%AF%A6%E8%A7%A3/">上一篇</a><a class="next" href="/2018/07/08/java/2018/%E6%94%B9%E5%96%84java%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/">下一篇</a></div><div class="copyright"><p>© 2015 - 2024 <a href="https://mirsery.github.io">mirsery</a> </p><p>powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and  <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a></p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"mirsery",'auto');ga('send','pageview');</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7201423389984397" crossorigin="anonymous"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>